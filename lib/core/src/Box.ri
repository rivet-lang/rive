// Copyright (C) 2023-present Jose Mendoza - All rights reserved. Use of this
// source code is governed by an MIT license that can be found in the LICENSE
// file.

struct Box {
    mut value: rawptr;
    mut ref_count: uint;
    mut dtor: ?func(rawptr);

    func new(size: uint, dtor: ?func(rawptr)) -> rawptr {
        mut boxed := @as(&Self, mem_alloc(@size_of(Self) + size));
        boxed.ref_count = 1;
        boxed.dtor = dtor;
        boxed.value = unsafe { @ptr_add(@as([&]uint8, boxed), @size_of(Self)) };
        return boxed.value;
    }

    func retain(ptr: rawptr) {
        mut boxed := @as(&Self, unsafe { @ptr_diff(@as([&]uint8, ptr), @size_of(Self)) });
        boxed.ref_count += 1;
    }

    func release(ptr: rawptr) {
        mut boxed := @as(&Self, unsafe { @ptr_diff(@as([&]uint8, ptr), @size_of(Self)) });
        boxed.ref_count -= 1;
        if boxed.ref_count == 0 {
            if dtor := boxed.dtor {
                dtor(boxed.value);
            }
            unsafe {
                mem_dealloc(boxed);
            }
        }
    }
}
