// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

use pkg::mem;
use pkg::process { panic };

#[used]
let empty_slice: Slice = Slice();

#[used]
struct Slice {
    ptr: *mut void;
    elem_size: usize;
    pub len: usize;

    #[used; unsafe]
    pub fn from_array(arr: *mut void, elem_size: usize, len: usize) Slice {
        return Slice(unsafe { arr }, elem_size, len);
    }

    #[used]
    fn get(self, idx: usize) *mut void {
        if (idx >= self.len) {
            panic("slice index out of range (index: {}, len: {})", idx, self.len);
        }
        return unsafe { ptr_add!(as(*mut u8, self.ptr), idx * self.elem_size) };
    }

    #[used; unsafe]
    fn raw_get(self, idx: usize) *mut void {
        return unsafe { ptr_add!(as(*mut u8, self.ptr), idx * self.elem_size) };
    }

    #[used]
    fn set(self, idx: usize, val: *void) void {
        if (idx >= self.len) {
            panic("slice index out of range (index: {}, len: {})", idx, self.len);
        }
        unsafe {
            mem::copy(
                ptr_add!(as(*mut u8, self.ptr), self.elem_size * idx), val, self.elem_size
            );
        }
    }

    #[used]
    fn ==(self, rhs: Self) bool {
        if (self.len != rhs.len) {
            return false;
        }
        return unsafe { mem::cmp(self.ptr, rhs.ptr, self.len) == 0 };
    }

    #[used]
    fn !=(self, rhs: Self) bool {
        return !self.==(rhs);
    }

    #[used]
    fn slice(self, start: usize, end: usize) Slice {
        if (start > end or end > self.len) {
            panic(
                "slice index out of range (range: {}..{}, len: {})", start, end,
                self.len
            );
        }
        let len = end - start;
        if (len == self.len) {
            return self;
        }
        return Slice(
            unsafe { ptr_add!(as(*mut u8, self.ptr), start * self.elem_size) },
            self.elem_size, len
        );
    }

    #[used]
    fn slice_from(self, start: usize) Slice {
        return self.slice(start, self.len);
    }
}
