// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

using pkg::traits::ToString;

pub struct String {
    ptr: *mut u8;
    mut len_: usize;
    mut cap: usize;

    pub fn new() Self { return Self{}; }

    /// Returns a dynamic string allocated on the heap with size `cap`.
    ///
    /// NOTE: `with_capacity` allocates memory the size of `cap` + 1, where 1 is
    /// an extra space for the NULL character.
    pub fn with_capacity(cap: usize) Self {
        let mut b = as(*mut u8, mem::alloc(cap + 1) catch unreachable!());
        unsafe {
            b[cap] = 0;
        }
        return Self{
            ptr: b,
            cap: cap
        };
    }

    pub unsafe fn from_raw(ptr: *mut u8, len: usize) Self {
        if (len == 0) {
            return Self::new();
        }
        return Self{
            ptr: ptr,
            len_: len,
            cap: len
        };
    }

    pub unsafe fn from_cstr(ptr: *mut u8) Self {
        let len = unsafe { stdc::strlen(ptr) };
        return Self{
            ptr: ptr,
            len_: len,
            cap: len
        };
    }

    /// Returns a string with the bytes stored in `bytes`. If the length of
    /// `bytes` is 0, an empty string is returned instead.
    pub fn from_bytes(bytes: [u8]) Self {
        if (bytes.len == 0) {
            return Self::new();
        }
        let mut res = Self::with_capacity(bytes.len);
        _ = mem::copy(res.ptr, bytes.ptr, bytes.len) catch unreachable!();
        res.len_ = bytes.len;
        return res;
    }

    pub fn from_str(s: str) Self {
        if (s.len == 0) {
            return Self::new();
        }
        let mut res = Self::with_capacity(s.len);
        _ = mem::copy(res.ptr, s.ptr, s.len) catch unreachable!();
        res.len_ = s.len;
        return res;
    }

    pub fn push(&mut self, val: u8) {
        if (self.len_ >= self.cap) {
            self.reserve(self.len_ + 1);
        }
        unsafe {
            _ = mem::copy(
                self.ptr + self.len_, &val, sizeof!(u8)
            ) catch unreachable!();
        }
        self.len_++;
    }

    pub fn push_str(&mut self, s: str) {
        if (self.len_ >= self.cap) {
            self.reserve(s.len);
        }
        unsafe {
            _ = mem::copy(
                self.ptr + self.len_, s.ptr, s.len
            ) catch unreachable!();
        }
        self.len_ += s.len;
    }

    pub fn push_string(&mut self, s: String) {
        if (self.len_ >= self.cap) {
            self.reserve(s.len_);
        }
        unsafe {
            _ = mem::copy(
                self.ptr + self.len_, s.ptr, s.len_
            ) catch unreachable!();
        }
        self.len_ += s.len_;
    }

    /// Returns the last byte of the string, and removes it. If the string is
    /// empty, this will panic.
    pub fn pop(&mut self) u8 {
        if (self.len_ == 0) {
            panic("String::pop: string is empty");
        }
        let new_len = self.len_ - 1;
        let last_elem = unsafe { self.ptr + new_len * sizeof!(u8) };
        self.len_ = new_len;
        return last_elem;
    }

    /// Ensures that this String's capacity is at least `required` bytes larger
    /// than its size.
    pub fn reserve(&mut self, required: usize) {
        if (required <= self.cap) {
            return;
        }
        let mut cap = if (self.cap > 0) self.cap else 2;
        while (required > cap) {
            cap *= 2;
        }
        let mut new_data = as(*mut u8, mem::alloc(cap * sizeof!(u8)) catch unreachable!());
        if (self.ptr != none) {
            _ = mem::copy(new_data, self.ptr, self.len_ * sizeof!(u8)) catch unreachable!();
        }
        unsafe {
            mem::dealloc(self.ptr);
        }
        self.ptr = new_data;
        self.cap = cap;
    }

    fn ==(&self, rhs: &Self) bool {
        if (self.len_ != rhs.len_) {
            return false;
        }
        if (self.len_ > 0) {
            let last_idx = self.len_ - 1;
            if (unsafe { self.ptr[last_idx] != rhs.ptr[last_idx] }) {
                return false;
            }
        }
        return mem::cmp(self.ptr, rhs.ptr, rhs.len_) == 0;
    }

    fn !=(&self, rhs: &Self) bool { return !self.==(rhs); }

    pub fn is_empty(&self) bool { return self.len_ == 0; }

    pub fn len(&self) usize { return self.len_; }

    /// Returns the number of runes contained in `self`.
    pub fn runes_count(&self) usize { return cstr_runes_count(self.ptr, self.len_); }

    pub fn as_ptr(&self) *const u8 { return self.ptr; }

    pub unsafe fn as_mut_ptr(&self) *mut u8 { return self.ptr; }

    pub fn as_bytes(&self) [u8] {
        return unsafe { _slice::from_array(self.ptr, sizeof!(u8), self.len_) };
    }

    pub fn as_str(&self) str {
        return unsafe { str::from_cstr_with_len(self.ptr, self.len_) };
    }

    pub fn clone(&self) Self {
        let mut res = Self::with_capacity(self.len_);
        _ = mem::copy(res.ptr, self.ptr, self.len_) catch unreachable!();
        return res;
    }

    ~self {
        unsafe { mem::dealloc(self.ptr); }
    }
}

extend String for ToString {
    fn to_string(&self) Self { return self.clone(); }
}
