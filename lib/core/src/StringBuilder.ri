// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

use pkg::traits::ToString;

pub class StringBuilder : ToString {
    pub ptr: *mut u8;
    mut len_: usize;
    mut cap: usize;

    pub fn new() Self {
        return Self::with_capacity(0);
    }

    /// Returns a string builder with capacity `cap`.
    pub fn with_capacity(cap: usize) Self {
        unsafe {
            let mut p = as(*mut u8, mem::alloc(cap + 1) catch unreachable!());
            p[cap] = 0;
            return Self(p, cap: cap);
        }
    }

    #[unsafe]
    pub fn from_raw(ptr: *mut u8) Self {
        return unsafe { Self::from_raw_with_len(ptr, stdc::strlen(ptr)) };
    }

    #[unsafe]
    pub fn from_raw_with_len(ptr: *mut u8, len: usize) Self {
        if (len == 0) {
            return Self::new();
        }
        return Self(unsafe { ptr }, len, len);
    }

    /// Returns a string with the bytes stored in `bytes`. If the length of
    /// `bytes` is 0, an empty string is returned instead.
    pub fn from_bytes(bytes: [u8]) Self {
        if (bytes.len == 0) {
            return Self::new();
        }
        unsafe {
            let mut res = Self::with_capacity(bytes.len);
            mem::copy(res.ptr, bytes.ptr, bytes.len);
            res.len_ = bytes.len;
            return res;
        }
    }

    pub fn from_string(s: string) Self {
        if (s.len == 0) {
            return Self::new();
        }
        unsafe {
            let mut res = Self::with_capacity(s.len);
            mem::copy(res.ptr, s.ptr, s.len);
            res.len_ = s.len;
            return res;
        }
    }

    pub fn write_byte(mut self, val: u8) void {
        if (self.len_ >= self.cap) {
            self.reserve(self.len_ + 1);
        }
        unsafe {
            mem::copy(self.ptr + self.len_, addr_of!(val), size_of!(u8));
        }
        self.len_++;
    }

    #[unsafe]
    pub fn write_raw(mut self, s: *u8) void {
        unsafe {
            self.write_raw_with_len(s, stdc::strlen(s));
        }
    }

    #[unsafe]
    pub fn write_raw_with_len(mut self, s: *u8, len: usize) void {
        if (len == 0) {
            return;
        } else if (self.len_ >= self.cap) {
            self.reserve(len);
        }
        unsafe {
            mem::copy(self.ptr + self.len_, s, len);
        }
        self.len_ += len;
    }

    pub fn write_string(mut self, s: string) void {
        unsafe {
            self.write_raw_with_len(s.ptr, s.len);
        }
    }

    /// Ensures that this string's capacity is at least `required` bytes larger
    /// than its size.
    pub fn reserve(mut self, required: usize) void {
        if (required <= self.cap) {
            return;
        }
        let mut cap = if (self.cap > 0) self.cap else 2;
        while (required > cap) {
            cap *= 2;
        }
        unsafe {
            let mut new_data = as(
                *mut u8, mem::alloc(cap * size_of!(u8)) catch unreachable!()
            );
            if (self.ptr != none) {
                mem::copy(new_data, self.ptr, self.len_ * size_of!(u8));
            }
            mem::dealloc(self.ptr);
            self.ptr = new_data;
        }
        self.cap = cap;
    }

    /// Returns the number of runes contained in `self`.
    pub fn runes_count(self) usize {
        return cstr_runes_count(unsafe { self.ptr }, self.len_);
    }

    pub fn len(self) usize {
        return self.len_;
    }

    pub fn is_empty(self) bool {
        return self.len_ == 0;
    }

    pub fn to_string(self) string {
        return string(self.ptr, self.len_);
    }

    ~Self(mut self) {
        unsafe {
            mem::dealloc(self.ptr);
        }
    }
}
