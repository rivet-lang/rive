// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

[boxed]
struct Vector {
    mut ptr: mut_anyptr;
    elem_size: usize;
    mut len: usize;
    mut cap: usize;
    is_ref: bool;

    [unsafe; inline]
    func new(elem_size: usize, cap: usize) Self {
        return Self(unsafe { internal_zeroed(cap * elem_size) }, elem_size, 0, cap);
    }

    [unsafe; inline]
    func new_with_len(elem_size: usize, len: usize, cap: usize) Self {
        return Self(unsafe { internal_zeroed(cap * elem_size) }, elem_size, len, cap);
    }

    [unsafe]
    func from_array(arr: mut_anyptr, elem_size: usize, len: usize) Self {
        vec := Self(unsafe { internal_zeroed(len * elem_size) }, elem_size, len, len);
        unsafe {
            mem_copy(vec.ptr, arr, elem_size * len);
        }
        return vec;
    }

    [unsafe; inline]
    func from_array_no_alloc(arr: mut_anyptr, elem_size: usize, len: usize) Self {
        return Self(unsafe { arr }, elem_size, len, len, is_ref: true);
    }

    [unsafe; inline]
    func raw_get(self, idx: usize) mut_anyptr {
        return unsafe { @ptr_add(@cast([*]mut uint8, self.ptr), idx * self.elem_size) };
    }

    func get(self, idx: usize) mut_anyptr {
        if idx >= self.len {
            process_panic("vector index out of range (index: {}, len: {})", idx, self.len);
        }
        return unsafe { @ptr_add(@cast([*]mut uint8, self.ptr), idx * self.elem_size) };
    }

    func set(self, idx: usize, val: anyptr) {
        if idx >= self.len {
            process_panic("vector index out of range (index: {}, len: {})", idx, self.len);
        }
        unsafe {
            mem_copy(
                @ptr_add(@cast([*]mut uint8, self.ptr), self.elem_size * idx), val, self.elem_size
            );
        }
    }

    func push(mut self, val: anyptr) {
        if self.len >= self.cap {
            self.reserve(self.len + 1);
        }
        unsafe {
            mem_copy(@ptr_add(self.ptr, self.elem_size * self.len), val, self.elem_size);
        }
        self.len += 1;
    }

    /// Returns the last element of the vector, and removes it. If the
    /// vector is empty, this will panic.
    func pop(mut self) anyptr {
        if self.len == 0 {
            process_panic("Vec.pop: vector is empty");
        }
        new_len := self.len - 1;
        self.len = new_len;
        return unsafe { @ptr_add(self.ptr, new_len * self.elem_size) };
    }

    [inline]
    func is_empty(self) bool {
        return self.len == 0;
    }

    func ==(self, rhs: Self) bool {
        if self.len != rhs.len {
            return false;
        }
        return unsafe { mem_cmp(self.ptr, rhs.ptr, self.len) == 0 };
    }

    [inline]
    func !=(self, rhs: Self) bool {
        return !(self == rhs);
    }

    func reserve(mut self, required: usize) {
        if required <= self.cap {
            return;
        }
        mut cap := if self.cap > 0 { self.cap } else { 2 };
        while required > cap {
            cap *= 2;
        }
        new_size := cap * self.elem_size;
        unsafe {
            new_ptr := internal_alloc(new_size);
            mem_copy(new_ptr, self.ptr, self.len * self.elem_size);
            self.ptr = new_ptr;
        }
        self.cap = cap;
    }

    func slice(self, start: usize, end: usize) Self {
        if start > end or end > self.len {
            process_panic(
                "slice index out of range (range: {}..{}, len: {})", start, end, self.len
            );
        }
        len := end - start;
        if len == self.len {
            return self;
        }
        return Self(
            unsafe { @ptr_add(@cast([*]mut uint8, self.ptr), start * self.elem_size) },
            self.elem_size, len, len, true
        );
    }

    [inline]
    func slice_from(self, start: usize) Self {
        return self.slice(start, self.len);
    }

    /// Returns an independent copy of `self`.
    public func clone(self) Self {
        mut size := self.cap * self.elem_size;
        if size == 0 {
            size = 1;
        }
        vec := Self(internal_zeroed(size), self.elem_size, self.len, self.cap);
        unsafe {
            mem_copy(vec.ptr, self.ptr, size);
        }
        return vec;
    }

    ~Self(self) {
        unsafe {
            if !self.is_ref {
                mem_dealloc(self.ptr);
            }
        }
    }
}
