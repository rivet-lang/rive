// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

#![c_compile("thirdparty/libbacktrace/backtrace.c")]

using pkg::demangle;

pub mod backtrace {
    struct backtrace_state;

    type BacktraceErrorCB = fn(*mut void, *const u8, i32);
    type BacktraceFullCB = fn(*mut void, i32, *const u8, i32, *const u8) i32;

    extern (C) {
        fn backtrace_create_state(
            filename: *const u8, threaded: i32, error_cb: BacktraceErrorCB,
            data: *const void
        ) *mut backtrace_state;

        fn backtrace_full(
            state: *const backtrace_state, skip: i32, cb: BacktraceFullCB,
            error_cb: BacktraceErrorCB, data: *const void
        ) i32;
    }

    static bt_state: *mut backtrace_state = unsafe {
        backtrace_create_state(ARGS[0].ptr, 1, bt_error_handler, 0)
    };

    struct BacktraceData {
        mut frame_nr: usize;
        mut has_error: bool;
    }

    fn bt_print_callback(
        data: *mut void, pc: i32, filename_ptr: *mut u8, lineno: i32, func_ptr: *const u8
    ) i32 {
        unsafe {
            if (func_ptr != none and stdc::memcmp(func_ptr, c"_R4core10rivet_mainF", 20) == 0) {
                return 1; // stop backtracing
            }

            let filename = if (filename_ptr == none) {
                "<unknown-filename>".to_string()
            } else {
                String::from_cstr(filename_ptr)
            };

            let func_name = if (func_ptr == none) {
                "<unknown-function-name>".to_string()
            } else {
                demangle::demangle_symbol(func_ptr)
            };

            let mut bdata = as(*mut BacktraceData, data);
            let kw = if (bdata.frame_nr == 0) "at" else "by";

            let lineno_str = lineno.to_string();

            let mut res = String::with_capacity(
                kw.len + func_name.len() + filename.len() + lineno_str.len() + 9
            );
            res.push_str("   ");
            res.push_str(kw);
            res.push_str(" ");
            res.push_string(func_name);
            res.push_str(" in ");
            res.push_string(filename);
            res.push_str(":");
            res.push_string(lineno_str);
            eprintln(res.as_str());
            bdata.frame_nr++;
        }
        return 0;
    }

    fn bt_error_handler(data: *mut void, msg_ptr: *const u8, errnum: i32) {
        let mut bdata = as(*mut BacktraceData, data);
        if (!bdata.has_error) {
            eprint("   libbacktrace error: ");
            eprint(unsafe { str::from_cstr(msg_ptr) });
            if (errnum > 0) {
                eprint(" (");
                eprint(unsafe { str::from_cstr(stdc::strerror(errnum)) });
                eprint(")");
            }
            eprintln();
            bdata.has_error = true;
        }
    }

    pub fn print(frames_to_skip: i32 = 0) {
        unsafe {
            _ = backtrace_full(
                bt_state, frames_to_skip, bt_print_callback, bt_error_handler,
                &BacktraceData{}
            );
        }
    }
}
