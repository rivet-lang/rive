// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// #![c_compile("../thirdparty/libbacktrace/backtrace.c")]

use pkg { stdc, demangle };
use pkg::console { eprint, eprintln };

struct backtrace_state;

type BacktraceErrorCB = fn(*mut void, *mut u8, i32) void;
type BacktraceFullCB = fn(*mut void, i32, *mut u8, i32, *mut u8) i32;

extern (C) {
    fn backtrace_create_state(
        filename: *u8, threaded: i32, error_cb: BacktraceErrorCB,
        data: *mut void
    ) *mut backtrace_state;

    fn backtrace_full(
        state: *backtrace_state, skip: i32, cb: BacktraceFullCB,
        error_cb: BacktraceErrorCB, data: *mut void
    ) i32;
}

let bt_state: *mut backtrace_state = unsafe {
    backtrace_create_state(ARGS[0].ptr, 1, bt_error_handler, 0)
};

struct BacktraceData {
    mut frame_nr: usize;
    mut has_error: bool;
}

fn bt_print_callback(
    data: *mut void, pc: i32, filename_ptr: *mut u8, lineno: i32, func_ptr: *mut u8
) i32 {
    unsafe {
        if (
            func_ptr != none
            and stdc::memcmp(func_ptr, c"_R4core10rivet_mainF", 20) == 0
        ) {
            return 1; // stop backtracing
        }

        let file_name = if (filename_ptr == none) {
            "???"
        } else {
            string::from_raw(filename_ptr)
        };

        let func_name = if (func_ptr == none) {
            "??"
        } else {
            demangle::demangle_symbol(string::from_raw(func_ptr))
        };

        let bdata = as(*mut BacktraceData, data);
        eprintln(
            "   {} {} in {}:{}", if (bdata.frame_nr == 0) "at" else "by",
            func_name, file_name, lineno
        );
        bdata.frame_nr++;
    }
    return 0;
}

fn bt_error_handler(data: *mut void, msg_ptr: *mut u8, errnum: i32) void {
    unsafe {
        let bdata = as(*mut BacktraceData, data);
        if (!bdata.has_error) {
            eprint("   libbacktrace error: ");
            eprint(string::from_raw(msg_ptr));
            if (errnum > 0) {
                eprint(" (");
                eprint(string::from_raw(stdc::strerror(errnum)));
                eprint(")");
            }
            eprintln();
            bdata.has_error = true;
        }
    }
}

pub fn print(frames_to_skip: i32 = 0) void {
    unsafe {
        let mut bt_data = BacktraceData();
        _ = backtrace_full(
            bt_state, frames_to_skip, bt_print_callback, bt_error_handler,
            addr_of_mut!(bt_data)
        );
    }
}
