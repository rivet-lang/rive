// Copyright (C) 2023-present Jose Mendoza - All rights reserved. Use of this
// source code is governed by an MIT license that can be found in the LICENSE
// file.

import ../token;

pub enum Builtin {
    Invalid,
    Const {
        name: string;
        type: Type;
    },
    Proc {
        name: string;
        args: []BuiltinArg;
        type: Type;
        is_unsafe: bool;
        checks: []BuiltinProcCheck;

        proc args_len(self) -> uint {
            mut l: uint := 0;
            for arg in self.args {
                if arg.is_optional {
                    break;
                }
                l += 1;
            }
            return l;
        }
    };

    pub proc type(self) -> Type {
        return match self {
            .Const(b_const) -> b_const.type,
            .Proc(b_proc) -> b_proc.type,
            else -> .Void
        };
    }
}

struct BuiltinArg {
    pub name: string;
    pub is_mut: bool;
    pub is_any: bool; // any type
    pub type: Type;
    pub is_optional: bool;
}

enum BuiltinProcType {
    Pointer,
    Enum,
    Integer
}

enum BuiltinProcCheck {
    ReturnTypeEqualToArgumentType(uint),
    ArgumentTypeEqualToArgumentType {
        arg1_idx: uint;
        arg2_idx: uint;
    },
    ArgumentTypeShouldBe {
        arg_idx: uint;
        type: BuiltinProcType;
    }
}

extend Env {
    proc setup_builtins(mut self) {
        self.builtins = +[
            // variables
            .Const("_FILE_", self.string_t),
            .Const("_LINE_", self.uint_t),
            .Const("_COLUMN_", self.uint_t),
            .Const("_FUNCTION_", self.string_t),
            .Const("_RIVET_VERSION_", self.string_t),
            .Const("_RIVET_COMMIT_", self.string_t),

            // procedures
            .Proc("size_of", +[BuiltinArg("value", is_any: true)], self.uint_t),
            .Proc("align_of", +[BuiltinArg("value", is_any: true)], self.uint_t),

            .Proc("ptr_add", +[
                BuiltinArg("pointer", is_any: true),
                BuiltinArg("value", is_any: true)
            ], is_unsafe: true, checks: +[
                .ArgumentTypeShouldBe(0, .Pointer),
                .ArgumentTypeShouldBe(1, .Integer),
                .ReturnTypeEqualToArgumentType(0)
            ]),
            .Proc("ptr_sub", +[
                BuiltinArg("pointer", is_any: true),
                BuiltinArg("value", is_any: true)
            ], self.uint_t, is_unsafe: true, checks: +[
                .ArgumentTypeShouldBe(0, .Pointer),
                .ArgumentTypeShouldBe(1, .Integer),
                .ReturnTypeEqualToArgumentType(0)
            ]),
            .Proc("ptr_diff", +[
                BuiltinArg("pointer", is_any: true),
                BuiltinArg("pointer2", is_any: true)
            ], self.uint_t, is_unsafe: true, checks: +[
                .ArgumentTypeShouldBe(0, .Pointer),
                .ArgumentTypeEqualToArgumentType(1, 0)
            ]),

            .Proc("as", +[
                BuiltinArg("type", is_any: true),
                BuiltinArg("value", is_any: true)
            ], checks: +[
                .ReturnTypeEqualToArgumentType(0)
            ]),

            .Proc("unreachable", +[], .Never(token.no_pos)),
            .Proc("breakpoint", +[]),
            .Proc("assert", +[
                BuiltinArg("cond", type: self.bool_t),
                BuiltinArg("msg", type: self.string_t, is_optional: true)
            ]),

            .Proc("set_enum_ref_value", +[
                BuiltinArg("enum_value", is_any: true, is_mut: true),
                BuiltinArg("new_value", is_any: true)
            ], is_unsafe: true, checks: +[
                .ArgumentTypeShouldBe(0, .Enum),
                .ArgumentTypeEqualToArgumentType(1, 0)
            ]),

            // TODO: rename to `ignore_warn`: `@ignore_warn("not_mutated", expr)`.
            .Proc("ignore_not_mutated_warn", +[
                BuiltinArg("expr", is_any: true, is_mut: true)
            ])
        ];
    }

    pub proc find_builtin(self, name: string) -> ?Builtin {
        for builtin in self.builtins {
            is_equal := match builtin {
                .Const(b_var) -> b_var.name == name,
                .Proc(b_proc) -> b_proc.name == name,
                else -> false
            };
            if is_equal {
                return builtin;
            }
        }
        return none;
    }

    pub proc exist_builtin(self, name: string) -> bool {
        return self.find_builtin(name) != none;
    }
}
