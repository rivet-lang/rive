// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

// Based on Zig's `std/c/tokenizer.zig`

import std/traits;

import ../token;

[boxed]
struct IdMap {
    key: string;
    value: CToken.Id;
}

[boxed]
struct IdArrayMap {
    ids: []IdMap;

    public func get(self, kw: string) ?CToken.Id {
        for id in self.ids {
            if id.key == kw {
                return id.value;
            }
        }
        return none;
    }
}

// TODO extensions
public var Keywords: IdArrayMap = IdArrayMap([
    IdMap("auto", .Keyword_auto()),
    IdMap("break", .Keyword_break()),
    IdMap("case", .Keyword_case()),
    IdMap("char", .Keyword_char()),
    IdMap("const", .Keyword_const()),
    IdMap("continue", .Keyword_continue()),
    IdMap("default", .Keyword_default()),
    IdMap("do", .Keyword_do()),
    IdMap("double", .Keyword_double()),
    IdMap("else", .Keyword_else()),
    IdMap("enum", .Keyword_enum()),
    IdMap("extern", .Keyword_extern()),
    IdMap("float", .Keyword_float()),
    IdMap("for", .Keyword_for()),
    IdMap("goto", .Keyword_goto()),
    IdMap("if", .Keyword_if()),
    IdMap("int", .Keyword_int()),
    IdMap("long", .Keyword_long()),
    IdMap("register", .Keyword_register()),
    IdMap("return", .Keyword_return()),
    IdMap("short", .Keyword_short()),
    IdMap("signed", .Keyword_signed()),
    IdMap("sizeof", .Keyword_sizeof()),
    IdMap("static", .Keyword_static()),
    IdMap("struct", .Keyword_struct()),
    IdMap("switch", .Keyword_switch()),
    IdMap("typedef", .Keyword_typedef()),
    IdMap("union", .Keyword_union()),
    IdMap("unsigned", .Keyword_unsigned()),
    IdMap("void", .Keyword_void()),
    IdMap("volatile", .Keyword_volatile()),
    IdMap("while", .Keyword_while()),

    // ISO C99
    IdMap("_Bool", .Keyword_bool()),
    IdMap("_Complex", .Keyword_complex()),
    IdMap("_Imaginary", .Keyword_imaginary()),
    IdMap("inline", .Keyword_inline()),
    IdMap("restrict", .Keyword_restrict()),

    // ISO C11
    IdMap("_Alignas", .Keyword_alignas()),
    IdMap("_Alignof", .Keyword_alignof()),
    IdMap("_Atomic", .Keyword_atomic()),
    IdMap("_Generic", .Keyword_generic()),
    IdMap("_Noreturn", .Keyword_noreturn()),
    IdMap("_Static_assert", .Keyword_static_assert()),
    IdMap("_Thread_local", .Keyword_thread_local()),

    // Preprocessor directives
    IdMap("include", .Keyword_include()),
    IdMap("define", .Keyword_define()),
    IdMap("ifdef", .Keyword_ifdef()),
    IdMap("ifndef", .Keyword_ifndef()),
    IdMap("pragma", .Keyword_pragma())
]);

public enum NumSuffix {
    None,
    F,
    L,
    U,
    LU,
    LL,
    LLU
}

public enum StrKind {
    None,
    Wide,
    UTF_8,
    UTF_16,
    UTF_32
}

public struct CToken : traits.Stringable {
    public mut id: Id;
    public mut start: usize;
    public mut end: usize;

    public mut pos: token.Pos;

    public enum Id {
        Invalid,
        Eof,
        Nl,
        Identifier,

        // special case for #include <...>
        MacroString,
        StringLiteral: StrKind,
        CharLiteral: StrKind,
        IntegerLiteral: NumSuffix,
        FloatLiteral: NumSuffix,
        Bang,
        BangEqual,
        Pipe,
        PipePipe,
        PipeEqual,
        Equal,
        EqualEqual,
        LParen,
        RParen,
        LBrace,
        RBrace,
        LBracket,
        RBracket,
        Period,
        Ellipsis,
        Caret,
        CaretEqual,
        Plus,
        PlusPlus,
        PlusEqual,
        Minus,
        MinusMinus,
        MinusEqual,
        Asterisk,
        AsteriskEqual,
        Percent,
        PercentEqual,
        Arrow,
        Colon,
        Semicolon,
        Slash,
        SlashEqual,
        Comma,
        Ampersand,
        AmpersandAmpersand,
        AmpersandEqual,
        QuestionMark,
        AngleBracketLeft,
        AngleBracketLeftEqual,
        AngleBracketAngleBracketLeft,
        AngleBracketAngleBracketLeftEqual,
        AngleBracketRight,
        AngleBracketRightEqual,
        AngleBracketAngleBracketRight,
        AngleBracketAngleBracketRightEqual,
        Tilde,
        LineComment,
        MultiLineComment,
        Hash,
        HashHash,

        Keyword_auto,
        Keyword_break,
        Keyword_case,
        Keyword_char,
        Keyword_const,
        Keyword_continue,
        Keyword_default,
        Keyword_do,
        Keyword_double,
        Keyword_else,
        Keyword_enum,
        Keyword_extern,
        Keyword_float,
        Keyword_for,
        Keyword_goto,
        Keyword_if,
        Keyword_int,
        Keyword_long,
        Keyword_register,
        Keyword_return,
        Keyword_short,
        Keyword_signed,
        Keyword_sizeof,
        Keyword_static,
        Keyword_struct,
        Keyword_switch,
        Keyword_typedef,
        Keyword_union,
        Keyword_unsigned,
        Keyword_void,
        Keyword_volatile,
        Keyword_while,

        // ISO C99
        Keyword_bool,
        Keyword_complex,
        Keyword_imaginary,
        Keyword_inline,
        Keyword_restrict,

        // ISO C11
        Keyword_alignas,
        Keyword_alignof,
        Keyword_atomic,
        Keyword_generic,
        Keyword_noreturn,
        Keyword_static_assert,
        Keyword_thread_local,

        // Preprocessor directives
        Keyword_include,
        Keyword_define,
        Keyword_ifdef,
        Keyword_ifndef,
        Keyword_pragma;

        [inline]
        public func symbol(self) string {
            return switch self is {
                .Invalid => "Invalid",
                .Eof => "Eof",
                .Nl => "NewLine",
                .Identifier => "Identifier",
                .MacroString => "MacroString",
                .StringLiteral => "StringLiteral",
                .CharLiteral => "CharLiteral",
                .IntegerLiteral => "IntegerLiteral",
                .FloatLiteral => "FloatLiteral",
                .LineComment => "LineComment",
                .MultiLineComment => "MultiLineComment",

                .Bang => "!",
                .BangEqual => "!=",
                .Pipe => "|",
                .PipePipe => "||",
                .PipeEqual => "|=",
                .Equal => "=",
                .EqualEqual => "==",
                .LParen => "(",
                .RParen => ")",
                .LBrace => "{",
                .RBrace => "}",
                .LBracket => "[",
                .RBracket => "]",
                .Period => ".",
                .Ellipsis => "...",
                .Caret => "^",
                .CaretEqual => "^=",
                .Plus => "+",
                .PlusPlus => "++",
                .PlusEqual => "+=",
                .Minus => "-",
                .MinusMinus => "--",
                .MinusEqual => "-=",
                .Asterisk => "*",
                .AsteriskEqual => "*=",
                .Percent => "%",
                .PercentEqual => "%=",
                .Arrow => "->",
                .Colon => ":",
                .Semicolon => ";",
                .Slash => "/",
                .SlashEqual => "/=",
                .Comma => ",",
                .Ampersand => "&",
                .AmpersandAmpersand => "&&",
                .AmpersandEqual => "&=",
                .QuestionMark => "?",
                .AngleBracketLeft => "<",
                .AngleBracketLeftEqual => "<=",
                .AngleBracketAngleBracketLeft => "<<",
                .AngleBracketAngleBracketLeftEqual => "<<=",
                .AngleBracketRight => ">",
                .AngleBracketRightEqual => ">=",
                .AngleBracketAngleBracketRight => ">>",
                .AngleBracketAngleBracketRightEqual => ">>=",
                .Tilde => "~",
                .Hash => "#",
                .HashHash => "##",
                .Keyword_auto => "auto",
                .Keyword_break => "break",
                .Keyword_case => "case",
                .Keyword_char => "char",
                .Keyword_const => "const",
                .Keyword_continue => "continue",
                .Keyword_default => "default",
                .Keyword_do => "do",
                .Keyword_double => "double",
                .Keyword_else => "else",
                .Keyword_enum => "enum",
                .Keyword_extern => "extern",
                .Keyword_float => "float",
                .Keyword_for => "for",
                .Keyword_goto => "goto",
                .Keyword_if => "if",
                .Keyword_int => "int",
                .Keyword_long => "long",
                .Keyword_register => "register",
                .Keyword_return => "return",
                .Keyword_short => "short",
                .Keyword_signed => "signed",
                .Keyword_sizeof => "sizeof",
                .Keyword_static => "static",
                .Keyword_struct => "struct",
                .Keyword_switch => "switch",
                .Keyword_typedef => "typedef",
                .Keyword_union => "union",
                .Keyword_unsigned => "unsigned",
                .Keyword_void => "void",
                .Keyword_volatile => "volatile",
                .Keyword_while => "while",
                .Keyword_bool => "_Bool",
                .Keyword_complex => "_Complex",
                .Keyword_imaginary => "_Imaginary",
                .Keyword_inline => "inline",
                .Keyword_restrict => "restrict",
                .Keyword_alignas => "_Alignas",
                .Keyword_alignof => "_Alignof",
                .Keyword_atomic => "_Atomic",
                .Keyword_generic => "_Generic",
                .Keyword_noreturn => "_Noreturn",
                .Keyword_static_assert => "_Static_assert",
                .Keyword_thread_local => "_Thread_local",
                .Keyword_include => "include",
                .Keyword_define => "define",
                .Keyword_ifdef => "ifdef",
                .Keyword_ifndef => "ifndef",
                .Keyword_pragma => "pragma"
            };
        }

        // TODO: do this in the preprocessor
        public func get_keyword(kw: string, pp_directive: bool) ?Self {
            if id := Keywords.get(kw) {
                switch id is {
                    .Keyword_include,
                    .Keyword_define,
                    .Keyword_ifdef,
                    .Keyword_ifndef,
                    .Keyword_pragma
                    if !pp_directive => return none,
                    else => return id
                }
            }
            return none;
        }
    }

    public func to_string(&self) string {
        return "{} (start: {}, end: {})".fmt(self.id.symbol(), self.start, self.end);
    }
}

public struct CTokenizer {
    public buffer: string;
    mut index: usize;
    mut prev_tok_id: CToken.Id = .Invalid();
    mut pp_directive: bool;

    enum CTokenizerState {
        Start,
        Cr,
        BackSlash,
        BackSlashCr,
        SmallU,
        U8,
        U,
        L,
        StringLiteral,
        CharLiteralStart,
        CharLiteral,
        EscapeSequence,
        CrEscape,
        OctalEscape,
        HexEscape,
        UnicodeEscape,
        Identifier,
        Equal,
        Bang,
        Pipe,
        Percent,
        Asterisk,
        Plus,

        // special case for #include <...>
        MacroString,
        AngleBracketLeft,
        AngleBracketAngleBracketLeft,
        AngleBracketRight,
        AngleBracketAngleBracketRight,
        Caret,
        Period,
        Period2,
        Minus,
        Slash,
        Ampersand,
        Hash,
        LineComment,
        MultiLineComment,
        MultiLineCommentAsterisk,
        Zero,
        IntegerLiteralOct,
        IntegerLiteralBinary,
        IntegerLiteralBinaryFirst,
        IntegerLiteralHex,
        IntegerLiteralHexFirst,
        IntegerLiteral,
        IntegerSuffix,
        IntegerSuffixU,
        IntegerSuffixL,
        IntegerSuffixLL,
        IntegerSuffixUL,
        FloatFraction,
        FloatFractionHex,
        FloatExponent,
        FloatExponentDigits,
        FloatSuffix
    }

    public func next(mut self) CToken {
        result := CToken(id: .Eof(), start: self.index);
        mut state := CTokenizerState.Start;
        mut string_ := false;
        mut counter: uint32 := 0;
        while self.index < self.buffer.len : self.index += 1 {
            c := self.buffer[self.index];
            switch state {
                .Start => switch c {
                    b'\n' => {
                        self.pp_directive = false;
                        result.id = .Nl();
                        self.index += 1;
                        break;
                    },
                    b'\r' => {
                        state = .Cr;
                    },
                    b'"' => {
                        result.id = .StringLiteral(.None);
                        state = .StringLiteral;
                    },
                    b'\'' => {
                        result.id = .CharLiteral(.None);
                        state = .CharLiteralStart;
                    },
                    b'u' => state = .SmallU,
                    b'U' => state = .U,
                    b'L' => state = .L,
                    b'a'...b'z', b'A'...'Z', b'_', b'$' => state = .Identifier,
                    b'=' => state = .Equal,
                    b'!' => state = .Bang,
                    b'|' => state = .Pipe,
                    b'(' => {
                        result.id = .LParen();
                        self.index += 1;
                        break;
                    },
                    b')' => {
                        result.id = .RParen();
                        self.index += 1;
                        break;
                    },
                    b'[' => {
                        result.id = .LBracket();
                        self.index += 1;
                        break;
                    },
                    b']' => {
                        result.id = .RBracket();
                        self.index += 1;
                        break;
                    },
                    b'{' => {
                        result.id = .LBrace();
                        self.index += 1;
                        break;
                    },
                    b'}' => {
                        result.id = .RBrace();
                        self.index += 1;
                        break;
                    },
                    b':' => {
                        result.id = .Colon();
                        self.index += 1;
                        break;
                    },
                    b';' => {
                        result.id = .Semicolon();
                        self.index += 1;
                        break;
                    },
                    b',' => {
                        result.id = .Comma();
                        self.index += 1;
                        break;
                    },
                    b'?' => {
                        result.id = .QuestionMark();
                        self.index += 1;
                        break;
                    },
                    b'%' => state = .Percent,
                    b'*' => state = .Asterisk,
                    b'+' => state = .Plus,
                    b'<' => state = if self.prev_tok_id is .Keyword_include {
                        .MacroString
                    } else {
                        .AngleBracketLeft
                    },
                    b'>' => state = .AngleBracketRight,
                    b'^' => state = .Caret,
                    b'~' => {
                        result.id = .Tilde();
                        self.index += 1;
                        break;
                    },
                    b'.' => state = .Period,
                    b'-' => state = .Minus,
                    b'/' => state = .Slash,
                    b'&' => state = .Ampersand,
                    b'#' => state = .Hash,
                    b'0' => state = .Zero,
                    b'1'...b'9' => state = .IntegerLiteral,
                    b'\\' => state = .BackSlash,
                    b'\t', 0x0b, 0x0c, b' ' => result.start = self.index + 1,
                    else => {
                        // TODO: handle invalid bytes better
                        result.id = .Invalid();
                        self.index += 1;
                        break;
                    }
                },
                .Cr => switch c {
                    b'\n' => {
                        self.pp_directive = false;
                        result.id = .Nl();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Invalid();
                        break;
                    }
                },
                .BackSlash => switch c {
                    b'\n' => {
                        result.start = self.index + 1;
                        state = .Start;
                    },
                    b'\r' => state = .BackSlashCr,
                    b'\t', 0x0b, 0x0c, b' ' => {
                        // TODO: warning
                    },
                    else => {
                        result.id = .Invalid();
                        break;
                    }
                },
                .BackSlashCr => switch c {
                    b'\n' => {
                        result.start = self.index + 1;
                        state = .Start;
                    },
                    else => {
                        result.id = .Invalid();
                        break;
                    }
                },
                .SmallU => switch c {
                    b'8' => state = .U8,
                    b'\'' => {
                        result.id = .CharLiteral(.UTF_16);
                        state = .CharLiteralStart;
                    },
                    b'\"' => {
                        result.id = .StringLiteral(.UTF_16);
                    },
                    else => {
                        self.index -= 1;
                        state = .Identifier;
                    }
                },
                .U8 => switch c {
                    b'\"' => {
                        result.id = .StringLiteral(.UTF_8);
                        state = .StringLiteral;
                    },
                    else => {
                        self.index -= 1;
                        state = .Identifier;
                    }
                },
                .U => switch c {
                    b'\'' => {
                        result.id = .CharLiteral(.UTF_32);
                        state = .CharLiteralStart;
                    },
                    b'\"' => {
                        result.id = .StringLiteral(.UTF_32);
                        state = .StringLiteral;
                    },
                    else => {
                        self.index -= 1;
                        state = .Identifier;
                    }
                },
                .L => switch c {
                    b'\'' => {
                        result.id = .CharLiteral(.Wide);
                        state = .CharLiteralStart;
                    },
                    b'\"' => {
                        result.id = .StringLiteral(.Wide);
                        state = .StringLiteral;
                    },
                    else => {
                        self.index -= 1;
                        state = .Identifier;
                    }
                },
                .StringLiteral => switch c {
                    b'\\' => {
                        string_ = true;
                        state = .EscapeSequence;
                    },
                    b'"' => {
                        self.index += 1;
                        break;
                    },
                    b'\n', b'\r' => {
                        result.id = .Invalid();
                        break;
                    },
                    else => { }
                },
                .CharLiteralStart => switch c {
                    b'\\' => {
                        string_ = false;
                        state = .EscapeSequence;
                    },
                    b'\'', b'\n' => {
                        result.id = .Invalid();
                        break;
                    },
                    else => state = .CharLiteral
                },
                .CharLiteral => switch c {
                    b'\\' => {
                        string_ = false;
                        state = .EscapeSequence;
                    },
                    b'\'' => {
                        self.index += 1;
                        break;
                    },
                    b'\n' => {
                        result.id = .Invalid();
                        break;
                    },
                    else => { }
                },
                .EscapeSequence => switch c {
                    b'\'', b'"', b'?', b'\\', b'a', b'b', b'f', b'n', b'r', b't',
                    b'v', b'\n' => state = if string_ {
                        .StringLiteral
                    } else {
                        .CharLiteral
                    },
                    b'\r' => state = .CrEscape,
                    b'0'...b'7' => {
                        counter = 1;
                        state = .OctalEscape;
                    },
                    b'x' => state = .HexEscape,
                    b'u' => {
                        counter = 4;
                        state = .OctalEscape;
                    },
                    b'U' => {
                        counter = 8;
                        state = .OctalEscape;
                    },
                    else => {
                        result.id = .Invalid();
                        break;
                    }
                },
                .CrEscape => switch c {
                    b'\n' => state = if string_ { .StringLiteral } else { .CharLiteral },
                    else => {
                        result.id = .Invalid();
                        break;
                    }
                },
                .OctalEscape => switch c {
                    b'0'...b'7' => {
                        counter += 1;
                        if counter == 3 {
                            state = if string_ { .StringLiteral } else { .CharLiteral };
                        }
                    },
                    else => {}
                },
                .HexEscape => switch c {
                    b'0'...b'9', b'a'...b'f', b'A'...b'F' => { },
                    else => {
                        self.index -= 1;
                        state = if string_ { .StringLiteral } else { .CharLiteral };
                    }
                },
                .UnicodeEscape => switch c {
                    b'0'...b'9', b'a'...b'f', b'A'...b'F' => {
                        counter -= 1;
                        if counter == 0 {
                            state = if string_ { .StringLiteral } else { .CharLiteral };
                        }
                    },
                    else => {
                        if counter != 0 {
                            result.id = .Invalid();
                            break;
                        }
                        self.index -= 1;
                        state = if string_ { .StringLiteral } else { .CharLiteral };
                    }
                },
                .Identifier => switch c {
                    b'a'...b'z', b'A'...b'Z', b'_', b'0'...b'9', b'$' => { },
                    else => {
                        result.id = CToken.Id.get_keyword(
                            self.buffer[result.start..self.index],
                            self.prev_tok_id is .Hash and !self.pp_directive
                        ) ?? .Identifier();
                        if self.prev_tok_id is .Hash {
                            self.pp_directive = true;
                        }
                        break;
                    }
                },
                .Equal => switch c {
                    b'=' => {
                        result.id = .EqualEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Equal();
                        break;
                    }
                },
                .Bang => switch c {
                    b'=' => {
                        result.id = .BangEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Bang();
                        break;
                    }
                },
                .Pipe => switch c {
                    b'=' => {
                        result.id = .PipeEqual();
                        self.index += 1;
                        break;
                    },
                    b'|' => {
                        result.id = .PipePipe();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Pipe();
                        break;
                    }
                },
                .Percent => switch c {
                    b'=' => {
                        result.id = .PercentEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Percent();
                        break;
                    }
                },
                .Asterisk => switch c {
                    b'=' => {
                        result.id = .AsteriskEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Asterisk();
                        break;
                    }
                },
                .Plus => switch c {
                    b'=' => {
                        result.id = .PlusEqual();
                        self.index += 1;
                        break;
                    },
                    b'+' => {
                        result.id = .PlusPlus();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Plus();
                        break;
                    }
                },
                .MacroString => switch c {
                    b'>' => {
                        result.id = .MacroString();
                        self.index += 1;
                        break;
                    },
                    else => { }
                },
                .AngleBracketLeft => switch c {
                    b'<' => state = .AngleBracketAngleBracketLeft,
                    b'=' => {
                        result.id = .AngleBracketLeftEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .AngleBracketLeft();
                        break;
                    }
                },
                .AngleBracketAngleBracketLeft => switch c {
                    b'=' => {
                        result.id = .AngleBracketAngleBracketLeftEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .AngleBracketAngleBracketLeft();
                        break;
                    }
                },
                .AngleBracketRight => switch c {
                    b'>' => state = .AngleBracketAngleBracketRight,
                    b'=' => {
                        result.id = .AngleBracketRightEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .AngleBracketRight();
                        break;
                    }
                },
                .AngleBracketAngleBracketRight => switch c {
                    b'=' => {
                        result.id = .AngleBracketAngleBracketRightEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .AngleBracketAngleBracketRight();
                        break;
                    }
                },
                .Caret => switch c {
                    b'=' => {
                        result.id = .CaretEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Caret();
                        break;
                    }
                },
                .Period => switch c {
                    b'.' => state = .Period2,
                    b'0'...b'9' => state = .FloatFraction,
                    else => {
                        result.id = .Period();
                        break;
                    }
                },
                .Period2 => switch c {
                    b'.' => {
                        result.id = .Ellipsis();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Period();
                        self.index -= 1;
                        break;
                    }
                },
                .Minus => switch c {
                    b'>' => {
                        result.id = .Arrow();
                        self.index += 1;
                        break;
                    },
                    b'=' => {
                        result.id = .MinusEqual();
                        self.index += 1;
                        break;
                    },
                    b'-' => {
                        result.id = .MinusMinus();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Minus();
                        break;
                    }
                },
                .Slash => switch c {
                    b'/' => state = .LineComment,
                    b'*' => state = .MultiLineComment,
                    b'=' => {
                        result.id = .SlashEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Slash();
                        break;
                    }
                },
                .Ampersand => switch c {
                    b'&' => {
                        result.id = .AmpersandAmpersand();
                        self.index += 1;
                        break;
                    },
                    b'=' => {
                        result.id = .AmpersandEqual();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Ampersand();
                        break;
                    }
                },
                .Hash => switch c {
                    b'#' => {
                        result.id = .HashHash();
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .Hash();
                        break;
                    }
                },
                .LineComment => switch c {
                    b'\n' => {
                        result.id = .LineComment();
                        break;
                    },
                    else => {}
                },
                .MultiLineComment => switch c {
                    b'*' => state = .MultiLineCommentAsterisk,
                    else => { }
                },
                .MultiLineCommentAsterisk => switch c {
                    b'/' => {
                        result.id = .MultiLineComment();
                        self.index += 1;
                        break;
                    },
                    else => state = .MultiLineComment
                },
                .Zero => switch c {
                    b'0'...b'9' => state = .IntegerLiteralOct,
                    b'b', b'B' => state = .IntegerLiteralBinaryFirst,
                    b'x', b'X' => state = .IntegerLiteralHexFirst,
                    b'.' => state = .FloatFraction,
                    else => {
                        state = .IntegerSuffix;
                        self.index -= 1;
                    }
                },
                .IntegerLiteralOct => switch c {
                    b'0'...b'7' => {},
                    else => {
                        state = .IntegerSuffix;
                        self.index -= 1;
                    }
                },
                .IntegerLiteralBinaryFirst => switch c {
                    b'0'...b'7' => state = .IntegerLiteralBinary,
                    else => { result.id = .Invalid(); break; }
                },
                .IntegerLiteralBinary => switch c {
                    b'0', b'1' => {},
                    else => {
                        state = .IntegerSuffix;
                        self.index -= 1;
                    }
                },
                .IntegerLiteralHexFirst => switch c {
                    b'0'...b'9', b'a'...b'f', b'A'...b'F' => state = .IntegerLiteralHex,
                    b'.' => state = .FloatFractionHex,
                    b'p', b'P' => state = .FloatExponent,
                    else => {
                        result.id = .Invalid();
                        break;
                    }
                },
                .IntegerLiteralHex => switch c {
                    b'0'...b'9', b'a'...b'f', b'A'...b'F' => {},
                    b'.' => state = .FloatFractionHex,
                    b'p', b'P' => state = .FloatExponent,
                    else => {
                        state = .IntegerSuffix;
                        self.index -= 1;
                    }
                },
                .IntegerLiteral => switch c {
                    b'0'...b'9' => {},
                    b'.' => state = .FloatFraction,
                    b'e', b'E' => state = .FloatExponent,
                    else => {
                        state = .IntegerSuffix;
                        self.index -= 1;
                    }
                },
                .IntegerSuffix => switch c {
                    b'u', b'U' => state = .IntegerSuffixU,
                    b'l', b'L' => state = .IntegerSuffixL,
                    else => {
                        result.id = .IntegerLiteral(.None);
                        break;
                    }
                },
                .IntegerSuffixU => switch c {
                    b'l', b'L' => state = .IntegerSuffixUL,
                    else => {
                        result.id = .IntegerLiteral(.U);
                        break;
                    }
                },
                .IntegerSuffixL => switch c {
                    b'l', b'L' => state = .IntegerSuffixLL,
                    b'u', b'U' => {
                        result.id = .IntegerLiteral(.LU);
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .IntegerLiteral(.L);
                        break;
                    }
                },
                .IntegerSuffixLL => switch c {
                    b'u', b'U' => {
                        result.id = .IntegerLiteral(.LLU);
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .IntegerLiteral(.LL);
                        break;
                    }
                },
                .IntegerSuffixUL => switch c {
                    b'l', b'L' => {
                        result.id = .IntegerLiteral(.LLU);
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .IntegerLiteral(.LU);
                        break;
                    }
                },
                .FloatFraction => switch c {
                    b'0'...b'9' => {},
                    b'e', b'E' => state = .FloatExponent,
                    else => {
                        self.index -= 1;
                        state = .FloatSuffix;
                    }
                },
                .FloatFractionHex => switch c {
                    b'0'...b'9', b'a'...b'f', b'A'...b'F' => {},
                    b'p', b'P' => state = .FloatExponent,
                    else => {
                        result.id = .Invalid();
                        break;
                    }
                },
                .FloatExponent => switch c {
                    b'+', b'-' => state = .FloatExponentDigits,
                    else => {
                        self.index -= 1;
                        state = .FloatExponentDigits;
                    }
                },
                .FloatExponentDigits => switch c {
                    b'0'...b'9' => counter += 1,
                    else => {
                        if counter == 0 {
                            result.id = .Invalid();
                            break;
                        }
                        self.index -= 1;
                        state = .FloatSuffix;
                    }
                },
                .FloatSuffix => switch c {
                    b'l', b'L' => {
                        result.id = .FloatLiteral(.L);
                        self.index += 1;
                        break;
                    },
                    b'f', b'F' => {
                        result.id = .FloatLiteral(.F);
                        self.index += 1;
                        break;
                    },
                    else => {
                        result.id = .FloatLiteral(.None);
                        break;
                    }
                }
            }
        } else if self.index == self.buffer.len {
            switch state {
                .Start => { },
                .SmallU, .U8, .U, .L, .Identifier => result.id = CToken.Id.get_keyword(
                    self.buffer[result.start..self.index],
                    self.prev_tok_id is .Hash and !self.pp_directive) ?? .Identifier(),
                .Cr, .BackSlash, .BackSlashCr, .Period2, .StringLiteral, .CharLiteralStart,
                .CharLiteral, .EscapeSequence, .CrEscape, .OctalEscape, .HexEscape, .UnicodeEscape,
                .MultiLineComment, .MultiLineCommentAsterisk, .FloatExponent, .MacroString,
                .IntegerLiteralBinaryFirst, .IntegerLiteralHexFirst => result.id = .Invalid(),
                .FloatExponentDigits => result.id = if counter == 0 {
                    .Invalid()
                } else {
                    .FloatLiteral(.None)
                },
                .FloatFraction, .FloatFractionHex => result.id = .FloatLiteral(.None),
                .IntegerLiteralOct, .IntegerLiteralBinary, .IntegerLiteralHex, .IntegerLiteral,
                .IntegerSuffix, .Zero => result.id = .IntegerLiteral(.None),
                .IntegerSuffixU => result.id = .IntegerLiteral(.U),
                .IntegerSuffixL => result.id = .IntegerLiteral(.L),
                .IntegerSuffixLL => result.id = .IntegerLiteral(.LL),
                .IntegerSuffixUL => result.id = .IntegerLiteral(.LU),
                .FloatSuffix => result.id = .FloatLiteral(.None),
                .Equal => result.id = .Equal(),
                .Bang => result.id = .Bang(),
                .Minus => result.id = .Minus(),
                .Slash => result.id = .Slash(),
                .Ampersand => result.id = .Ampersand(),
                .Hash => result.id = .Hash(),
                .Period => result.id = .Period(),
                .Pipe => result.id = .Pipe(),
                .AngleBracketAngleBracketRight => result.id = .AngleBracketAngleBracketRight(),
                .AngleBracketRight => result.id = .AngleBracketRight(),
                .AngleBracketAngleBracketLeft => result.id = .AngleBracketAngleBracketLeft(),
                .AngleBracketLeft => result.id = .AngleBracketLeft(),
                .Plus => result.id = .Plus(),
                .Percent => result.id = .Percent(),
                .Caret => result.id = .Caret(),
                .Asterisk => result.id = .Asterisk(),
                .LineComment => result.id = .LineComment()
            }
        }
        self.prev_tok_id = result.id;
        result.end = self.index;
        return result;
    }
}
