// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/strings;

import ../token;

public enum Decl {
    Empty: token.Pos,
    Comment: Comment,
    Import {
        attributes: Attributes;
        is_public: bool;
        path: string;
        path_pos: token.Pos;
        mut alias_name: string;
        mut has_custom_alias: bool;
        glob: bool;
        import_list: []ImportListInfo;
        mut info: ImportedMod;
        pos: token.Pos;
    },
    Extern {
        docs: []Comment;
        attributes: Attributes;
        abi: ABI;
        decls: []Decl;
        pos: token.Pos;
    },
    Alias {
        docs: []Comment;
        attributes: Attributes;
        is_public: bool;
        name: string;
        parent: Expr;
        is_typealias: bool;
        mut parent_type: Type;
        pos: token.Pos;
        mut sym: Sym;
    },
    Trait {
        docs: []Comment;
        attributes: Attributes;
        is_public: bool;
        name: string;
        bases: []mut Type;
        decls: []Decl;
        pos: token.Pos;
        mut sym: Sym;
    },
    Enum {
        docs: []Comment;
        attributes: Attributes;
        is_public: bool;
        name: string;
        mut underlying_type: Type;
        bases: []mut Type;
        variants: []EnumVariantDecl;
        is_boxed: bool;
        decls: []Decl;
        pos: token.Pos;
        mut sym: Sym;
    },
    Struct {
        docs: []Comment;
        attributes: Attributes;
        is_public: bool;
        name: string;
        bases: []mut Type;
        decls: []Decl;
        is_opaque: bool;
        pos: token.Pos;
        mut sym: Sym;
    },
    Field {
        docs: []Comment;
        attributes: Attributes;
        is_public: bool;
        is_mut: bool;
        name: string;
        mut type: Type;
        mut def_expr: Expr;
        has_def_expr: bool;
        pos: token.Pos;
    },
    Extend {
        attributes: Attributes;
        mut type: Type;
        bases: []mut Type;
        decls: []Decl;
        pos: token.Pos;
    },
    Const {
        docs: []Comment;
        attributes: Attributes;
        is_public: bool;
        name: string;
        has_type: bool;
        mut type: Type;
        mut expr: Expr;
        pos: token.Pos;
        mut sym: Sym;
    },
    Var {
        docs: []Comment;
        attributes: Attributes;
        is_public: bool;
        is_extern: bool;
        abi: ABI;
        lefts: []ObjectData;
        mut right: Expr;
        pos: token.Pos;
        mut sym: Sym;
        mut scope: Scope;
    },
    Func {
        docs: []Comment;
        attributes: Attributes;
        is_public: bool;
        is_extern: bool;
        is_unsafe: bool;
        is_method: bool;
        is_special_method: bool;
        is_main: bool;
        is_variadic: bool;
        is_operator: bool;
        abi: ABI;
        name: string;
        args: []Arg;
        has_named_args: bool;
        mut ret_type: Type;
        stmts: []mut Stmt;
        mut scope: Scope;
        has_body: bool;
        self_is_mut: bool;
        self_is_ptr: bool;
        mut self_type: Type;
        pos: token.Pos;
        self_pos: token.Pos;
        mut sym: Sym;
        mut defer_stmts: []Stmt.Defer;

        public func stringify(self) -> string {
            mut sb := strings.Builder.new(500);
            if self.is_public {
                sb.write_string("public ");
            }
            sb.write_fmt("func {}(", self.name);
            if self.is_method {
                if self.self_is_ptr {
                    sb.write_string("&");
                }
                if self.self_is_mut {
                    sb.write_string("mut ");
                }
                sb.write_string("self");
                if self.args.len > 0 {
                    sb.write_string(", ");
                }
            }
            for i, arg in self.args {
                if arg.is_mut {
                    sb.write_string("mut ");
                }
                sb.write_fmt("{}: {}", arg.name, arg.type);
                if arg.has_def_expr {
                    sb.write_fmt(" := {}", arg.def_expr);
                }
                if i < self.args.len - 1 {
                    sb.write_string(", ");
                }
            }
            sb.write_byte(b')');
            if self.ret_type !is .Void {
                sb.write_fmt(" -> {}", self.ret_type);
            }
            return sb.to_string();
        }
    },
    Test {
        docs: []Comment;
        attributes: Attributes;
        name: string;
        stmts: []mut Stmt;
        scope: Scope;
        pos: token.Pos;
        mut defer_stmts: []Stmt.Defer;
    };

    public func decls(self) -> ?[]Self {
        return match self is {
            .Extern as extern_decl -> extern_decl.decls,
            .Trait as trait_decl -> trait_decl.decls,
            .Enum as enum_decl -> enum_decl.decls,
            .Struct as struct_decl -> struct_decl.decls,
            .Extend as extend_decl -> extend_decl.decls,
            else -> none
        };
    }
}

#[boxed]
public struct EnumVariantDecl {
    public name: string;
    public mut type: Type;
    public has_type: bool;
    public has_value: bool;
    public value: Expr;
    public decls: []Decl;
    public pos: token.Pos;
}

public struct ImportListInfo {
    public name: string;
    public alias_name: string;
    public mut has_custom_alias: bool;
    public pos: token.Pos;
}

public struct ImportedMod {
    public name: string;
    public full_name: string;
    public alias_name: string;
    public found: bool;
    public files: []string;
    public mut mod: Module;
}

public func filter_field_decl(decls: []Decl) -> []Decl {
    mut fields := @vec(Decl);
    for decl in decls {
        if decl is .Field {
            fields.push(decl);
        }
    }
    return fields;
}