// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/traits;
import std/strings;

import ../token;

public enum Expr : traits.Stringable {
    Empty: token.Pos,
    Paren {
        mut expr: Expr = .Empty(token.noPos);
        pos: token.Pos;
        mut type: Type = .Void();
    },
    Type: Type,
    Assign {
        mut left: Expr = .Empty(token.noPos);
        op: token.Kind;
        mut right: Expr = .Empty(token.noPos);
        pos: token.Pos;
    },
    Ident {
        name: string;
        scope: Scope;
        is_comptime: bool;
        mut is_obj: bool;
        mut is_sym: bool;
        mut found: bool;
        mut sym: Sym = InvalidSym();
        mut builtin: Builtin = .Invalid();
        pos: token.Pos;
        mut type: Type = .Void();
    },
    SelfTy {
        scope: Scope;
        pos: token.Pos;
        mut found: bool;
        mut sym: TypeSym;
    },
    SelfLiteral {
        mut scope: Scope;
        pos: token.Pos;
        mut found: bool;
        mut sym: TypeSym;
        mut obj: Var;
        mut type: Type = .Void();
    },
    NoneLiteral {
        pos: token.Pos;
    },
    BoolLiteral {
        value: bool;
        pos: token.Pos;
    },
    CharLiteral {
        value: string;
        is_byte: bool;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    IntegerLiteral {
        value: string;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    FloatLiteral {
        value: string;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    StringLiteral {
        value: string;
        is_raw: bool;
        is_bytestr: bool;
        is_cstr: bool;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    EnumLiteral {
        value: string;
        mut is_instance: bool;
        from_is_cmp: bool;
        pos: token.Pos;
        mut type: Type = .Void();
        mut sym: TypeSym;
        mut variant: EnumVariant;
    },
    TupleLiteral {
        values: []mut Expr;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    VectorLiteral {
        values: []mut Expr;
        is_arr: bool;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    Selector {
        mut left: Expr = .Empty(token.noPos);
        mut left_type: Type = .Void();
        mut left_sym: Sym = InvalidSym();
        field_name: string;
        field_pos: token.Pos;
        mut field_is_mut: bool;
        mut field_type: Type = .Void();
        mut is_path: bool;
        mut found: bool;
        mut sym: Sym = InvalidSym();
        pos: token.Pos;
        mut type: Type = .Void();
    },
    Indirect {
    	mut left: Expr = .Empty(token.noPos);
    	mut pos: token.Pos;
    	mut left_type: Type = .Void();
    	mut type: Type = .Void();
    	mut is_mut: bool;
    },
    OptionCheck {
    	mut left: Expr = .Empty(token.noPos);
    	mut pos: token.Pos;
    	mut left_type: Type = .Void();
    	mut type: Type = .Void();
    },
    Branch {
        op: token.Kind;
        pos: token.Pos;
    },
    Range {
        mut start: Expr = .Empty(token.noPos);
        mut end: Expr = .Empty(token.noPos);
        has_start: bool;
        has_end: bool;
        is_inclusive: bool;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    Index {
        mut left: Expr = .Empty(token.noPos);
        mut left_type: Type = .Void();
        mut index: Expr = .Empty(token.noPos);
        pos: token.Pos;
        mut type: Type = .Void();
        mut is_ref: bool;
        mut is_ref_mut: bool;
    },
    Call {
        mut left: Expr = .Empty(token.noPos);
        mut args: []CallArg;
        mut spread_expr: Expr = .Empty(token.noPos);
        has_spread_expr: bool;
        mut err_handler: CallErrorHandler;
        pos: token.Pos;
        mut type: Type = .Void();
        mut func_: Func;

        mut is_closure: bool;
        mut is_constructor: bool;

        mut is_enum_variant: bool;
        mut enum_variant_sym: TypeSym;

        func has_named_args(self) bool {
            for arg in self.args {
                if arg.is_named {
                    return true;
                }
            }
            return false;
        }

        func get_named_arg(self, name: string) ?CallArg {
            for arg in self.args {
                if arg.is_named and arg.name == name {
                    return arg;
                }
            }
            return none;
        }

        /// Returns the number of pure arguments, that is, not named, that
        /// this call has.
        func pure_args_count(self) usize {
            mut l: usize := 0;
            for arg in self.args {
                if !arg.is_named {
                    l += 1;
                }
            }
            if self.has_spread_expr {
                l += 1;
            }
            return l;
        }

        @[inline]
        func has_err_handler(self) bool {
            return self.err_handler.has_expr or self.err_handler.is_propagate;
        }
    },
    BuiltinCall {
        name: string;
        args: []CallArg;
        vec_is_mut: bool;
        pos: token.Pos;
        mut builtin: Builtin = .Invalid();
        mut type: Type = .Void();
    },
    Unary {
        mut right: Expr = .Empty(token.noPos);
        op: token.Kind;
        is_ref_mut: bool;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    Binary {
        mut left: Expr = .Empty(token.noPos);
        mut right: Expr = .Empty(token.noPos);
        op: token.Kind;
        has_var_obj: bool;
        mut var_obj: ObjectData;
        mut scope: Scope;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    Return {
        mut expr: Expr = .Empty(token.noPos);
        has_expr: bool;
        pos: token.Pos;
    },
    Block {
        is_unsafe: bool;
        stmts: []mut Stmt;
        mut expr: Expr = .Empty(token.noPos);
        is_expr: bool;
        scope: Scope;
        pos: token.Pos;
        mut type: Type = .Void();
    },
    If {
        branches: []IfBranch;
        has_else: bool;
        pos: token.Pos;
        mut expected_type: Type = .Void();
        mut type: Type = .Void();
    },
    Switch {
        mut expr: Expr = .Empty(token.noPos);
        branches: []SwitchBranch;
        is_typeswitch: bool;
        has_else: bool;
        mut scope: Scope;
        pos: token.Pos;
        mut expected_type: Type = .Void();
        mut type: Type = .Void();
        mut is_exhaustive: bool;
    },
    // Examples:
    // - if x := optional_or_result_fn() { ... }
    // - while byte := reader.read() { ... }
    Guard {
        vars: []ObjectData;
        mut expr: Expr = .Empty(token.noPos);
        has_cond: bool;
        mut cond: Expr = .Empty(token.noPos);
        mut scope: Scope;
        pos: token.Pos;
    };

    public func clean_paren(self) Self {
        mut res := self;
        while res is .Paren as paren {
            res = paren.expr;
        }
        return res;
    }

    @[inline]
    public func position(self) token.Pos {
        return switch self is {
            .Empty as empty_pos => empty_pos,
            .Paren as paren => paren.pos,
            .Type as type => type.position(),
            .Assign as assign => assign.pos,
            .Ident as ident => ident.pos,
            .SelfTy as self_ty => self_ty.pos,
            .SelfLiteral as self_lit => self_lit.pos,
            .NoneLiteral as none_lit => none_lit.pos,
            .BoolLiteral as bool_lit => bool_lit.pos,
            .CharLiteral as char_lit => char_lit.pos,
            .IntegerLiteral as int_lit => int_lit.pos,
            .FloatLiteral as float_lit => float_lit.pos,
            .StringLiteral as string_lit => string_lit.pos,
            .EnumLiteral as enum_lit => enum_lit.pos,
            .TupleLiteral as tuple_lit => tuple_lit.pos,
            .VectorLiteral as vec_lit => vec_lit.pos,
            .Index as index => index.pos,
            .Selector as selector => selector.pos,
            .Indirect as indirect => indirect.pos,
            .OptionCheck as option_check => option_check.pos,
            .Branch as branch => branch.pos,
            .Range as range => range.pos,
            .Call as call => call.pos,
            .BuiltinCall as builtin_call => builtin_call.pos,
            .Unary as unary => unary.pos,
            .Binary as binary => binary.pos,
            .Return as return_expr => return_expr.pos,
            .Block as block => block.pos,
            .If as if_expr => if_expr.pos,
            .Switch as switch_expr => switch_expr.pos,
            .Guard as guard => guard.pos
        };
    }

    @[inline]
    public func to_string(self) string {
        return switch self is {
            .Empty => "<empty-expression>",
            .Paren as paren => "({})".fmt(paren.expr),
            .Type as type => type.to_string(),
            .Assign as assign => "{} {} {}".fmt(assign.left, assign.op, assign.right),
            .Ident as ident => if ident.is_comptime {
                "@".concat(ident.name)
            } else {
                ident.name
            },
            .SelfTy => "Self",
            .SelfLiteral => "self",
            .NoneLiteral => "none",
            .BoolLiteral as bool_lit => bool_lit.value.to_string(),
            .CharLiteral as char_lit => if char_lit.is_byte {
                "b'{}'".fmt(char_lit.value)
            } else {
                "'{}'".fmt(char_lit.value)
            },
            .IntegerLiteral as int_lit => int_lit.value,
            .FloatLiteral as float_lit => float_lit.value,
            .StringLiteral as string_lit => if string_lit.is_bytestr {
                "b\"{}\"".fmt(string_lit.value)
            } else if string_lit.is_raw {
                "r\"{}\"".fmt(string_lit.value)
            } else if string_lit.is_cstr {
                "c\"{}\"".fmt(string_lit.value)
            } else {
                "\"{}\"".fmt(string_lit.value)
            },
            .EnumLiteral as enum_lit => ".".concat(enum_lit.value),
            .TupleLiteral as tuple_lit => {
                mut sb := strings.Builder.from_string("(");
                for i, value in tuple_lit.values {
                    sb.write_string(value.to_string());
                    if i < tuple_lit.values.len - 1 {
                        sb.write_string(", ");
                    }
                }
                sb.write_byte(b')');
                sb.to_string()
            },
            .VectorLiteral as vector_lit => {
                mut sb := strings.Builder.from_string("[");
                for i, value in vector_lit.values {
                    sb.write_string(value.to_string());
                    if i < vector_lit.values.len - 1 {
                        sb.write_string(", ");
                    }
                }
                sb.write_byte(b']');
                if vector_lit.is_arr {
                    sb.write_byte(b'!');
                }
                sb.to_string()
            },
            .Selector as selector => "{}.{}".fmt(selector.left, selector.field_name),
            .Indirect as indirect => "{}.*".fmt(indirect.left),
            .OptionCheck as option_check => "{}?".fmt(option_check.left),
            .Branch as branch_expr => branch_expr.op.to_string(),
            .Range as range => {
                mut sb := strings.Builder.new();
                if range.has_start {
                    sb.write_string(range.start.to_string());
                }
                sb.write_string(if range.is_inclusive {
                    "..."
                } else {
                    ".."
                });
                if range.has_end {
                    sb.write_string(range.end.to_string());
                }
                sb.to_string()
            },
            .Index as index => "{}[{}]".fmt(index.left, index.index),
            .Call as call => {
                mut sb := strings.Builder.new();
                sb.write_string(call.left.to_string());
                sb.write_byte(b'(');
                for i, arg in call.args {
                    if arg.is_named {
                        sb.write_string(arg.name);
                        sb.write_string(": ");
                    }
                    sb.write_string(arg.expr.to_string());
                    if i < call.args.len - 1 {
                        sb.write_string(", ");
                    }
                }
                if call.has_spread_expr {
                    if call.args.len > 0 {
                        sb.write_string(", ");
                    }
                    sb.write_string("...");
                    sb.write_string(call.spread_expr.to_string());
                }
                sb.write_byte(b')');
                if call.err_handler.has_expr {
                    sb.write_string("catch ");
                    if call.err_handler.has_varname {
                        sb.write_fmt("|{}| ", call.err_handler.varname);
                    }
                    sb.write_string(call.err_handler.expr.to_string());
                } else if call.err_handler.is_propagate {
                    sb.write_byte(b'!');
                }
                sb.to_string()
            },
            .BuiltinCall as builtin_call => {
                mut sb := strings.Builder.from_string("@");
                sb.write_string(builtin_call.name);
                sb.write_byte(b'(');
                for i, arg in builtin_call.args {
                    sb.write_string(arg.expr.to_string());
                    if i < builtin_call.args.len - 1 {
                        sb.write_string(", ");
                    }
                }
                sb.write_byte(b')');
                sb.to_string()
            },
            .Unary as unary => "{}{}".fmt(unary.op, unary.right),
            .Binary as binary => "{} {} {}".fmt(binary.left, binary.op, binary.right),
            .Return as return_expr => if return_expr.has_expr {
                "return {}".fmt(return_expr.expr)
            } else {
                "return"
            },
            .Block as block => {
                mut sb := strings.Builder.new();
                if block.is_unsafe {
                    sb.write_string("unsafe ");
                }
                sb.write_string("{ ");
                sb.write_fmt(" {} statements", block.stmts.len);
                if block.is_expr {
                    sb.write_string("; ");
                    sb.write_string(block.expr.to_string());
                }
                sb.write_string(" }");
                sb.to_string()
            },
            .If as if_expr => {
                mut sb := strings.Builder.new();
                for branch in if_expr.branches {
                    if branch.is_else {
                        sb.write_string("else ");
                    } else if branch.is_else_if {
                        sb.write_string("else if ");
                        sb.write_string(branch.cond.to_string());
                    } else {
                        sb.write_string("if ");
                        sb.write_string(branch.cond.to_string());
                    }
                    sb.write_fmt("{{ {} }}", branch.expr);
                }
                sb.to_string()
            },
            .Switch as switch_expr => {
                mut sb := strings.Builder.new();
                sb.write_fmt("switch {} ", switch_expr.expr);
                if switch_expr.is_typeswitch {
                    sb.write_string("is ");
                }
                sb.write_string("{ ");
                for i, branch in switch_expr.branches {
                    if branch.is_else {
                        sb.write_string("else ");
                    } else {
                        for ip, case in branch.cases {
                            sb.write_string(case.to_string());
                            if ip < branch.cases.len - 1 {
                                sb.write_string(", ");
                            }
                        }
                    }
                    if branch.has_var {
                        if branch.var_is_mut {
                            sb.write_string("mut ");
                        }
                        sb.write_string(branch.var_name);
                    }
                    if branch.has_cond {
                        sb.write_fmt(" if {} ", branch.cond);
                    }
                    sb.write_fmt("=> {}", branch.expr.to_string());
                    if i < switch_expr.branches.len - 1 {
                        sb.write_string(", ");
                    }
                }
                sb.write_string("} ");
                sb.to_string()
            },
            .Guard as guard => {
                mut sb := strings.Builder.new();
                if guard.vars.len > 0 {
                    sb.write_string("(");
                }
                for i, var_g in guard.vars {
                    if var_g.is_mut {
                        sb.write_string("mut ");
                    }
                    sb.write_string(var_g.name);
                    if i < guard.vars.len - 1 {
                        sb.write_string(", ");
                    }
                }
                if guard.vars.len > 0 {
                    sb.write_string(")");
                }
                sb.write_fmt(" := {}", guard.expr);
                if guard.has_cond {
                    sb.write_fmt("; {}", guard.cond);
                }
                sb.to_string()
            }
        };
    }
}

@[boxed]
public struct CallArg {
    public name: string;
    public mut expr: Expr = .Empty(token.noPos);
    public is_named: bool;
    public pos: token.Pos;
    public mut type: Type = .Void();
}

@[boxed]
public struct CallErrorHandler {
    public varname: string;
    public varname_pos: token.Pos;
    public has_varname: bool;
    public is_propagate: bool;
    public mut expr: Expr = .Empty(token.noPos);
    public has_expr: bool;
    public mut scope: Scope;
    public pos: token.Pos;
}

@[boxed]
public struct IfBranch {
    public mut cond: Expr = .Empty(token.noPos);
    public mut expr: Expr = .Empty(token.noPos);
    public is_else: bool;
    public is_else_if: bool;
    public pos: token.Pos;
    public mut type: Type = .Void();
}

@[boxed]
public struct SwitchBranch {
    public cases: []mut Expr;
    public has_var: bool;
    public var_is_mut: bool;
    public var_name: string;
    public var_pos: token.Pos;
    public has_cond: bool;
    public mut var_type: Type = .Void();
    public mut cond: Expr = .Empty(token.noPos);
    public mut expr: Expr = .Empty(token.noPos);
    public is_else: bool;
    public pos: token.Pos;
    public mut type: Type = .Void();
}
