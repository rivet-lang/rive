// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/traits;
import std/strings;

import ../token;

var mut SYM_IDS: usize = 0;

func new_sym_id() usize {
    res := SYM_IDS;
    SYM_IDS += 1;
    return res;
}

[boxed]
public struct DuplicateSymbolError : Error {
    msg: string;

    public func to_string(self) string {
        return self.msg;
    }
}

public enum ABI as uint8 : traits.Stringable {
    Rivet,
    C;

    [inline]
    public func from_string(abi: string) ?ABI {
        return switch abi {
            "C" => .C,
            "Rivet" => .Rivet,
            else => none
        };
    }

    [inline]
    public func to_string(&self) string {
        return switch self.* {
            .C => "C",
            .Rivet => "Rivet"
        };
    }
}

public trait Sym {
    id: usize = new_sym_id();
    abi: ABI;
    mut is_public: bool;
    mut parent: ?Sym;
    name: string;
    mut scope: Scope;
    mut mangled_name: string;
    mut qualified_name: string;
    is_universe: bool;
    is_root: bool;

    func mod(self) ?Module {
        mut p := self;
        while {
            if p is Module as mod {
                return mod;
            } else if p_ := p.parent {
                p = p_;
            } else {
                break;
            }
        }
        return none;
    }

    func has_access_to(self, other: Sym) bool {
        self_mod := self.mod() ?? return false;
        other_mod := other.mod() ?? return false;
        return (
            other_mod.is_universe or self_mod.id == other.id
            or self_mod.id == other_mod.id
            or self_mod.id == other_mod.parent?.id
            or self_mod.parent?.id == other.parent?.id
        );
    }

    func type_of(self) string {
        return switch self is {
            SymRef as sym_ref => if sym_ref.ref_resolved {
                sym_ref.ref.type_of()
            } else {
                "alias"
            },
            Module => "module",
            Const => "constant",
            Var as obj => switch obj.level {
                .Receiver, .Argument => "argument",
                else => "variable"
            },
            TypeSym as type_sym => if type_sym.info.is_compound() {
                type_sym.info.to_string()
            } else {
                "type"
            },
            Func as func_info => if func_info.is_method {
                "method"
            } else {
                "function"
            },
            else => "unknown symbol kind"
        };
    }

    func qualname(self) string {
        return if parent := self.parent {
            if parent.is_universe {
                self.name
            } else {
                parent.qualname().concat(".", self.name)
            }
        } else {
            self.name
        };
    }

    func ==(self, other: Self) bool {
        return self.id == other.id;
    }

    func !=(self, other: Self) bool {
        return !(self.id == other.id);
    }
}

[boxed]
public struct SymRef : Sym {
    public mut ref: Sym;
    public mut ref_expr: Expr;
    public mut ref_resolved: bool;
}

[boxed]
public struct Module : Sym {
    public func add_or_get_array(mut self, elem_typ: Type, size: usize, is_mut: bool) TypeSym {
        unique_name := if is_mut {
            "[{}]mut {}".fmt(size, elem_typ.to_qualstring())
        } else {
            "[{}]{}".fmt(size, elem_typ.to_qualstring())
        };
        if type_sym := self.scope.find(unique_name) {
            return @cast(TypeSym, type_sym);
        }
        type_sym := TypeSym(
            is_public: true,
            name: unique_name,
            info: .Array(elem_typ, size, is_mut)
        );
        self.scope.add(type_sym) catch {};
        return type_sym;
    }

    public func add_or_get_tuple(mut self, types: []Type) TypeSym {
        unique_name := {
            mut sb := strings.Builder.from_string("(");
            for i, type in types {
                sb.write_string(type.to_qualstring());
                if i < types.len - 1 {
                    sb.write_string(", ");
                }
            }
            sb.write_byte(b')');
            sb.to_string()
        };
        if type_sym := self.scope.find(unique_name) {
            return @cast(TypeSym, type_sym);
        }
        type_sym := TypeSym(is_public: true, name: unique_name, info: .Tuple(types));
        self.scope.add(type_sym) catch {};
        return type_sym;
    }

    [inline]
    public func is_core(self) bool {
        return self.name == "core";
    }
}

[boxed]
public struct Const : Sym {
    public mut expr: Expr;
    public mut evaled_expr: Expr;
    public mut has_evaled_size: bool;
    public mut evaled_size: isize;
    public mut type: Type;
    public pos: token.Pos;
}

public enum VarLevel as uint8 {
    Module, // module-level
    Receiver, // receiver: `self`
    Argument, // argument-level
    Local // inside function
}

[boxed]
public struct Var : Sym {
    public is_extern: bool;
    public is_mut: bool;
    public is_used: bool;
    public is_changed: bool;
    public is_hidden_ref: bool;
    public ir_name: string; // used for duplicate objects in IR
    public level: VarLevel;
    public type: Type;
    public pos: token.Pos;
}

[boxed]
public struct Field {
    public is_public: bool;
    public name: string;
    public is_mut: bool;
    public has_def_expr: bool;
    public def_expr: Expr;
    public type: Type;
}

[boxed]
public struct TypeSym : Sym {
    public mut fields: []Field;
    public mut full_fields_: []Field;
    public mut info: TypeInfo;
    public mut size: isize = -1;
    public mut align: isize = -1;

    public func lookup_field(self, name: string) ?Field {
        for f in self.fields {
            if f.name == name {
                return f;
            }
        }
        if self.info is .Struct as struct_info {
            for b in struct_info.bases {
                if f := b.lookup_field(name) {
                    return f;
                }
            }
        }
        return none;
    }

    [inline]
    public func has_field(self, name: string) bool {
        return self.lookup_field(name) !is none;
    }

    public func lookup_in_base(self, name: string) ?Sym {
        if self.info is .Struct as struct_info {
            for b in struct_info.bases {
                if s := b.lookup(name) {
                    return s;
                }
            }
        }
        return none;
    }

    [inline]
    public func lookup(self, name: string) ?Sym {
        return if s := self.scope.lookup(name) {
            s
        } else if s := self.lookup_in_base(name) {
            s
        } else {
            none
        };
    }

    public func full_fields(mut self) []Field {
        if !self.full_fields_.is_empty() {
            return self.full_fields_;
        }
        mut fields := @vec(Field);
        if self.info is .Struct as struct_info {
            for mut b in struct_info.bases {
                for bf in b.full_fields() {
                    fields.push(bf);
                }
            }
        }
        for f in self.fields {
            fields.push(f);
        }
        self.full_fields_ = fields;
        return fields;
    }

    public func update(mut self, other: TypeSym) ! {
        if self.info is .Placeholder {
            // update placeholder
            self.is_public = other.is_public;
            self.info = other.info;
            self.fields = other.fields;
            for s in other.scope.syms {
                self.scope.add(s)!;
            }
        }
    }

    [inline]
    public func is_boxed(self) bool {
        return if self.info is .Enum as enum_info {
            enum_info.is_boxed
        } else if self.info is .Struct as struct_info {
            struct_info.is_boxed
        } else {
            self.info is .Trait or self.info is .String or self.info is .Vector
        };
    }

    [inline]
    public func is_primitive(self) bool {
        return if self.info is .Enum as enum_info {
            !enum_info.is_boxed
        } else {
            self.info.is_primitive()
        };
    }

    [inline]
    public func ==(self, rhs: Self) bool {
        return self.id == rhs.id;
    }
}

[boxed]
public struct Arg {
    public name: string;
    public is_mut: bool;
    public is_self: bool;
    public has_def_expr: bool;
    public def_expr: Expr;
    public pos: token.Pos;
    public mut type: Type;
}

[boxed]
public struct Func : Sym {
    public is_extern: bool;
    public is_unsafe: bool;
    public is_main: bool;
    public is_method: bool;
    public is_variadic: bool;
    public mut self_type: Type;
    public self_is_mut: bool;
    public self_is_ref: bool;
    public args: []Arg;
    public has_named_args: bool;
    public has_body: bool;
    public ret_type: Type;

    public func get_arg(self, idx: usize) Arg {
        arg := self.args[idx];
        return if arg.is_self {
            self.args[idx + 1]
        } else {
            arg
        };
    }

    public func args_len(self) usize {
        mut len: usize := 0;
        for arg in self.args {
            if !(arg.is_self or arg.type is .Variadic) {
                len += 1;
            }
        }
        return len;
    }

    [inline]
    public func kind(self) string {
        return if self.is_method { "method" } else { "function" };
    }
}

public func universe() Module {
    return Module(is_public: false, name: "universe", scope: Scope(syms: [
        TypeSym(name: "none", info: .None()),
        TypeSym(name: "bool", info: .Bool()),
        TypeSym(name: "rune", info: .Rune()),
        TypeSym(name: "int8", info: .Int(8)),
        TypeSym(name: "int16", info: .Int(16)),
        TypeSym(name: "int32", info: .Int(32)),
        TypeSym(name: "int64", info: .Int(64)),
        TypeSym(name: "isize", info: .Isize()),
        TypeSym(name: "uint8", info: .Uint(8)),
        TypeSym(name: "uint16", info: .Uint(16)),
        TypeSym(name: "uint32", info: .Uint(32)),
        TypeSym(name: "uint64", info: .Uint(64)),
        TypeSym(name: "usize", info: .Usize()),
        TypeSym(name: "comptime_int", info: .ComptimeInt()),
        TypeSym(name: "comptime_float", info: .ComptimeFloat()),
        TypeSym(name: "float32", info: .Float(32)),
        TypeSym(name: "float64", info: .Float(64)),
        TypeSym(name: "string", info: .Struct(is_boxed: true))
    ]));
}
