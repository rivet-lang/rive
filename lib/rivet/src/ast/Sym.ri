// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import "std/traits";

import "../token";

var mut SYM_IDS: usize = 0;

func new_sym_id() usize {
    res := SYM_IDS;
    SYM_IDS += 1;
    return res;
}

#[boxed]
public struct DuplicateSymbolError : Error {
    msg: string;

    public func to_string(self) string {
        return self.msg;
    }
}

public enum ABI as uint8 : traits.Stringable {
    Rivet,
    C;

    #[inline]
    public func from_string(abi: string) ?ABI {
        return switch abi {
            "C" => .C,
            "Rivet" => .Rivet,
            else => nil
        };
    }

    #[inline]
    public func to_string(&self) string {
        return switch self.* {
            .C => "C",
            .Rivet => "Rivet"
        };
    }
}

public class Sym {
    public id: usize = new_sym_id();
    public abi: ABI;
    public mut is_public: bool;
    public parent: ?Sym;
    public name: string;
    public mut scope: Scope;
    public mut mangled_name: string;
    public mut qualified_name: string;
    public is_universe: bool;
    public is_root: bool;

    #[inline]
    public func qualname(self) string {
        return if self.parent is nil or self.parent.?.is_universe {
            self.name
        } else {
            self.parent.?.qualname().concat(".", self.name)
        };
    }

    #[inline]
    public func ==(self, other: Self) bool {
        return self.id == other.id;
    }
}

public class Mod : Sym { }

public class Const : Sym {
    public expr: Expr;
    public evaled_expr: ?Expr;
    public typ: Type;
}

public enum VarLevel as uint8 {
    Mod, // module-level
    Rec, // receiver: `self`
    Arg, // argument-level
    Local // inside function
}

public class Var : Sym {
    public is_extern: bool;
    public ir_name: string; // used for duplicate objects in IR
    public is_mut: bool;
    public is_used: bool;
    public is_changed: bool;
    public is_hidden_ref: bool;
    public level: VarLevel;
    public typ: Type;
}

public class Field {
    public is_public: bool;
    public name: string;
    public is_mut: bool;
    public def_expr: ?Expr;
    public typ: Type;
}

public enum TypeKind : traits.Stringable {
    Placeholder,
    Never,
    Nil,
    Bool,
    Rune,
    Int8,
    Int16,
    Int32,
    Int64,
    Uint8,
    Uint16,
    Uint32,
    Uint64,
    Isize,
    Usize,
    ComptimeInt,
    ComptimeFloat,
    Float32,
    Float64,
    String,
    Alias,
    Array,
    Vector,
    Tuple,
    Enum,
    Trait,
    Class,
    Struct;

    #[inline]
    public func is_primitive(self) bool {
        return self in [
            .Nil, .Bool, .Rune, .Int8, .Int16, .Int32, .Int64, .Isize, .Uint8,
            .Uint16, .Uint32, .Uint64, .Usize, .ComptimeInt, .ComptimeFloat, .Float32,
            .Float64, .Never
        ];
    }

    #[inline]
    public func to_string(&self) string {
        return switch self.* {
            .Nil => "nil",
            .Bool => "bool",
            .Rune => "rune",
            .Int8 => "int8",
            .Int16 => "int16",
            .Int32 => "int32",
            .Int64 => "int64",
            .Isize => "isize",
            .Uint8 => "uint8",
            .Uint16 => "uint16",
            .Uint32 => "uint32",
            .Uint64 => "uint64",
            .Usize => "usize",
            .ComptimeInt => "comptime_int",
            .ComptimeFloat => "comptime_float",
            .Float32 => "float32",
            .Float64 => "float64",
            .String => "string",
            .Alias => "alias",
            .Array => "array",
            .Vector => "vector",
            .Tuple => "tuple",
            .Trait => "trait",
            .Class => "class",
            .Struct => "struct",
            .Enum => "enum",
            .Never => "never",
            else => "placeholder"
        };
    }
}

public class TypeInfo { }

public class AliasInfo : TypeInfo {
    public parent: Type;
}

public class ArrayInfo : TypeInfo {
    public elem_typ: Type;
    public size: isize;
    public has_contains_method: bool;
}

public class VectorInfo : TypeInfo {
    public elem_typ: Type;
    public has_contains_method: bool;
}

public class TupleInfo : TypeInfo {
    public types: []Type;
}

public class EnumVariant {
    public name: string;
    public value: isize;
    public has_typ: bool;
    public typ: Type;
}

public class EnumInfo : TypeInfo {
    public underlying_typ: Type;
    public mut variants: []EnumVariant;
    public is_advanced_enum: bool;

    #[inline]
    public func add_value(mut self, name: string, variant: isize) {
        self.variants.push(EnumVariant(name, variant));
    }

    public func get_value(self, name: string) ?EnumVariant {
        for v in self.variants {
            if v.name == name {
                return v;
            }
        }
        return nil;
    }

    public func get_variant_by_type(self, typ: Type) ?EnumVariant {
        for v in self.variants {
            if v.has_typ and v.typ == typ {
                return v;
            }
        }
        return nil;
    }

    public func has_value(self, name: string) bool {
        return if _ := self.get_value(name) {
            true
        } else {
            false
        };
    }
}

public class TraitInfo : TypeInfo {
    public bases: []mut TypeSym;
    public mut implements: []TypeSym;
    public mut has_objects: bool;

    public func index_of(self, type_sym: TypeSym) ?usize {
        for i, ts in self.implements {
            if ts.id == type_sym.id {
                return i;
            }
        }
        return nil;
    }

    public func implement(mut self, type_sym: TypeSym) {
        self.implements.push(type_sym);
        for mut b in self.bases {
            @cast(TraitInfo, b.info).implement(type_sym);
        }
    }

    public func mark_has_objects(mut self) {
        self.has_objects = true;
        for mut b in self.bases {
            @cast(TraitInfo, b.info).has_objects = true;
        }
    }
}

public class ClassInfo : TypeInfo {
    public mut base_sym: TypeSym;
    public is_base: bool;
    public use_base: bool;
    public traits: []TypeSym;
    public is_child: bool;
    public childrens: []TypeSym;
}

public class StructInfo : TypeInfo {
    public is_boxed: bool;
    public is_opaque: bool;
    public bases: []mut TypeSym;
    public traits: []TypeSym;
}

public class TypeSym : Sym {
    public mut fields: []Field;
    public mut full_fields_: []Field;
    public mut kind: TypeKind;
    public mut info: TypeInfo;
    public mut size: isize = -1;
    public mut align: isize = -1;

    public func lookup_field(self, name: string) ?Field {
        for f in self.fields {
            if f.name == name {
                return f;
            }
        }
        if self.info is ClassInfo as class_info {
            if f := class_info.base_sym.lookup_field(name) {
                return f;
            }
        } else if self.info is StructInfo as struct_info {
            for b in struct_info.bases {
                if f := b.lookup_field(name) {
                    return f;
                }
            }
        }
        return nil;
    }

    #[inline]
    public func has_field(self, name: string) bool {
        return if _ := self.lookup_field(name) { true } else { false };
    }

    public func lookup_in_base(self, name: string) ?Sym {
        if self.info is ClassInfo as class_info {
            if s := class_info.base_sym.lookup(name) {
                return s;
            }
        } else if self.info is StructInfo or self.info is TraitInfo {
            bases := if self.info is StructInfo {
                @cast(StructInfo, self.info).bases
            } else {
                @cast(TraitInfo, self.info).bases
            };
            for b in bases {
                if s := b.lookup(name) {
                    return s;
                }
            }
        }
        return nil;
    }

    public func lookup(self, name: string) ?Sym {
        if s := base.scope.lookup(name) {
            return s;
        } else if s := self.lookup_in_base(name) {
            return s;
        }
        return nil;
    }

    public func full_fields(mut self) []Field {
        if !self.full_fields_.is_empty() {
            return self.full_fields_;
        }
        mut fields := @vec(Field);
        if self.info is ClassInfo as class_info {
            for bf in class_info.base_sym.full_fields() {
                fields.push(bf);
            }
        } else if self.info is StructInfo as struct_info {
            for mut b in struct_info.bases {
                for bf in b.full_fields() {
                    fields.push(bf);
                }
            }
        }
        for f in self.fields {
            fields.push(f);
        }
        self.full_fields_ = fields;
        return fields;
    }

    public func update(mut self, other: TypeSym) ! {
        if self.kind == .Placeholder {
            // update placeholder
            self.is_public = other.is_public;
            self.kind = other.kind;
            self.fields = other.fields;
            for s in other.scope.syms {
                self.scope.add(s).!;
            }
            self.info = other.info;
        }
    }

    public func is_subtype_of(self, other: TypeSym) bool {
        if self == other {
            return true;
        }
        if self.info is ClassInfo as class_info {
            if class_info.base_sym == other {
                return true;
            }
            return class_info.base_sym.is_subtype_of(other);
        } else if self.info is StructInfo as struct_info {
            for b in struct_info.bases {
                if b.is_subtype_of(other) {
                    return true;
                }
            }
        }
        return false;
    }

    #[inline]
    public func is_boxed(self) bool {
        return if self.info is EnumInfo as enum_info {
            enum_info.is_advanced_enum
        } else if self.info is StructInfo as struct_info {
            struct_info.is_boxed
        } else {
            self.kind == .Trait or self.kind == .Class or self.kind == .String
            or self.kind == .Vector
        };
    }

    // TODO(StunxFS): fix inheritance of overloaded operators
    #[inline; override]
    public func ==(self, rhs: Self) bool {
        return self.id == rhs.id;
    }
}

public class Arg {
    public name: string;
    public is_mut: bool;
    public is_self: bool;
    public def_expr: ?Expr;
    public pos: token.Pos;
    public mut typ: Type;
}

public class Func : Sym {
    public is_extern: bool;
    public is_unsafe: bool;
    public is_main: bool;
    public is_method: bool;
    public is_variadic: bool;
    public self_typ: Type;
    public self_is_mut: bool;
    public self_is_ref: bool;
    public args: []Arg;
    public has_named_args: bool;
    public has_body: bool;
    public ret_typ: Type;

    public func get_arg(self, idx: usize) Arg {
        arg := self.args[idx];
        return if arg.is_self {
            self.args[idx + 1]
        } else {
            arg
        };
    }

    public func args_len(self) usize {
        mut len: usize := 0;
        for arg in self.args {
            if !(arg.is_self or arg.typ is .Variadic) {
                len += 1;
            }
        }
        return len;
    }

    #[inline]
    public func kind(self) string {
        return if self.is_method { "method" } else { "function" };
    }
}

public class Scope {
    public start: usize;
    public mut end: usize;
    public mut parent: ?Scope;
    public mut detached_from_parent: bool;
    public mut syms: []Sym;

    public func add(mut self, sym: Sym) ! {
        if sym.name == "_" and sym is Var {
            return; // ignore blank var
        } else if self.exists(sym.name) {
            return DuplicateSymbolError("duplicate symbol `{}`".fmt(sym.name));
        }
        self.syms.push(sym);
    }

    #[inline]
    public func exists(self, name: string) bool {
        return if _ := self.lookup(name) { true } else { false };
    }

    public func lookup(self, name: string) ?Sym {
        mut sc_: ?Scope := self;
        while sc := sc_ {
            for sym in self.syms {
                if sym.name == name {
                    return sym;
                }
            }
            if sc.dont_lookup_parent() {
                break;
            }
            sc_ = sc.parent;
        }
        return nil;
    }

    #[inline]
    func dont_lookup_parent(self) bool {
        return if self.detached_from_parent or self.parent is nil {
            true
        } else if parent := self.parent {
            parent is Mod
        } else {
            false
        };
    }
}

public func universe() Mod {
    return Mod(
        is_public: false,
        name: "universe",
        scope: Scope(
            syms: [
                TypeSym(is_public: true, name: "never", kind: .Never),
                TypeSym(is_public: true, name: "nil", kind: .Nil),
                TypeSym(is_public: true, name: "bool", kind: .Bool),
                TypeSym(is_public: true, name: "rune", kind: .Rune),
                TypeSym(is_public: true, name: "int8", kind: .Int8),
                TypeSym(is_public: true, name: "int16", kind: .Int16),
                TypeSym(is_public: true, name: "int32", kind: .Int32),
                TypeSym(is_public: true, name: "int64", kind: .Int64),
                TypeSym(is_public: true, name: "isize", kind: .Isize),
                TypeSym(is_public: true, name: "uint8", kind: .Uint8),
                TypeSym(is_public: true, name: "uint16", kind: .Uint16),
                TypeSym(is_public: true, name: "uint32", kind: .Uint32),
                TypeSym(is_public: true, name: "uint64", kind: .Uint64),
                TypeSym(is_public: true, name: "usize", kind: .Usize),
                TypeSym(is_public: true, name: "comptime_int", kind: .ComptimeInt),
                TypeSym(is_public: true, name: "comptime_float", kind: .ComptimeFloat),
                TypeSym(is_public: true, name: "float32", kind: .Float32),
                TypeSym(is_public: true, name: "float64", kind: .Float64),
                TypeSym(is_public: true, name: "string", kind: .String)
            ]
        )
    );
}
