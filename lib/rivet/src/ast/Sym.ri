// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/traits;
import std/strings;

import ../token;

static mut symIds: usize := 0;

func new_sym_id() -> usize {
    res := symIds;
    symIds += 1;
    return res;
}

#[boxed]
public struct DuplicateSymbolError < Throwable {
    msg: string;

    public func to_string(self) -> string {
        return self.msg;
    }
}

public enum ABI as uint8 < traits.Stringable {
    Rivet,
    C;

    #[inline]
    public func from_string(abi: string) -> ?ABI {
        return match abi {
            "C" => .C,
            "Rivet" => .Rivet,
            else => none
        };
    }

    #[inline]
    public func to_string(&self) -> string {
        return match self.* {
            .C => "C",
            .Rivet => "Rivet"
        };
    }
}

#[default_value(InvalidSym())]
public trait Sym {
    id: usize = new_sym_id();
    abi: ABI;
    mut is_public: bool;
    mut parent: ?Sym;
    name: string;
    mut scope: Scope;
    mut mangled_name: string;
    mut qualified_name: string;
    is_universe: bool;
    is_root: bool;
    mut is_generated: bool;

    func module(self) -> ?Module {
        mut p := self;
        while {
            if p is Module as mod {
                return mod;
            } else if p_ := p.parent {
                p = p_;
            } else {
                break;
            }
        }
        return none;
    }

    func has_access_to(self, other: Sym) -> bool {
        self_mod := self.module() ?? return false;
        other_mod := other.module() ?? return false;
        return (
            other_mod.is_universe or self_mod.id == other.id
            or self_mod.id == other_mod.id
            or self_mod.id == other_mod.parent?.id
            or self_mod.parent?.id == other.parent?.id
        );
    }

    func type_of(self) -> string {
        return match self is {
            SymRef as sym_ref => if sym_ref.ref_resolved {
                sym_ref.ref.type_of()
            } else {
                "alias"
            },
            Module => "module",
            Const => "constant",
            Var as obj => match obj.level {
                .Receiver, .Argument => "argument",
                else => "variable"
            },
            TypeSym as type_sym => if type_sym.info.is_compound() {
                type_sym.info.to_string()
            } else {
                "type"
            },
            Func as func_info => func_info.kind(),
            else => "unknown symbol kind"
        };
    }

    func qualname(self) -> string {
        return if parent := self.parent {
            if parent.is_universe {
                self.name
            } else {
                parent.qualname().concat(".", self.name)
            }
        } else {
            self.name
        };
    }

    func ==(self, other: Self) -> bool {
        return self.id == other.id;
    }

    func !=(self, other: Self) -> bool {
        return self.id != other.id;
    }
}

#[boxed]
public struct InvalidSym < Sym {}

#[boxed]
public struct SymRef < Sym {
    public mut ref: Sym;
    public mut ref_expr: Expr;
    public mut ref_resolved: bool;
}

#[boxed]
public struct Module < Sym {
    public func add_or_get_array(mut self, elem_typ: Type, size: usize, is_mut: bool) -> TypeSym {
        unique_name := if is_mut {
            "[{}]mut {}"
        } else {
            "[{}]{}"
        }.fmt(size, elem_typ.to_qualstring());
        if type_sym := self.scope.find(unique_name) {
            return @as(TypeSym, type_sym);
        }
        type_sym := TypeSym(
            is_public: true,
            name: unique_name,
            info: .Array(elem_typ, size, is_mut),
            fields: [
                Field(
                    name: "len", is_public: true,
                    type: .Basic(self.scope.find_type_symbol_by_index_or_panic(11))
                )
            ]
        );
        self.scope.add(type_sym) catch {};
        return type_sym;
    }

    public func add_or_get_vec(mut self, elem_type: Type, is_mut: bool) -> TypeSym {
        unique_name := if is_mut { "[]mut " } else { "[]" }.concat(elem_type.to_qualstring());
        if type_sym := self.scope.find(unique_name) {
            return @as(TypeSym, type_sym);
        }
        type_sym := TypeSym(
            is_public: true,
            name: unique_name,
            info: .Vector(elem_type, is_mut),
            fields: [
                Field(
                    name: "len", is_public: true,
                    type: .Basic(self.scope.find_type_symbol_by_index_or_panic(11))
                ),
                Field(
                    name: "cap", is_public: true,
                    type: .Basic(self.scope.find_type_symbol_by_index_or_panic(11))
                )
            ]
        );
        type_sym.scope.add(Func(
            name: "push",
            is_public: true,
            is_method: true,
            self_type: .Basic(type_sym),
            self_is_mut: true,
            args: [Arg("value", type: elem_type, pos: token.noPos)],
            ret_type: .Void(),
            has_body: true
        )) catch {};
        type_sym.scope.add(Func(
            name: "pop",
            is_public: true,
            is_method: true,
            self_type: .Basic(type_sym),
            self_is_mut: true,
            ret_type: elem_type,
            has_body: true
        )) catch {};
        type_sym.scope.add(Func(
            name: "clone",
            is_public: true,
            is_method: true,
            self_type: .Basic(type_sym),
            ret_type: .Basic(type_sym),
            has_body: true
        )) catch {};
        if vector_sym := self.scope.find("core")?.scope.find("Vector") {
            type_sym.scope.add(vector_sym.scope.find("is_empty")?) catch {};
            type_sym.scope.add(vector_sym.scope.find("delete")?) catch {};
            type_sym.scope.add(vector_sym.scope.find("trim")?) catch {};
            type_sym.scope.add(vector_sym.scope.find("clear")?) catch {};
        }
        self.scope.add(type_sym) catch {};
        return type_sym;
    }

    public func add_or_get_tuple(mut self, types: []Type) -> TypeSym {
        unique_name := {
            mut sb := strings.Builder.from_string("(");
            for i, type in types {
                sb.write_string(type.to_qualstring());
                if i < types.len - 1 {
                    sb.write_string(", ");
                }
            }
            sb.write_byte(b')');
            sb.to_string()
        };
        if type_sym := self.scope.find(unique_name) {
            return @as(TypeSym, type_sym);
        }
        mut fields := @vec(Field);
        for i, type in types {
            fields.push(Field(name: i.to_string(), is_public: true, type: type));
        }
        type_sym := TypeSym(
            is_public: true, name: unique_name, info: .Tuple(types), fields: fields
        );
        self.scope.add(type_sym) catch {};
        return type_sym;
    }

    public func add_or_get_func(mut self, func_sym: Func) -> TypeSym {
        unique_name := {
            mut sb := strings.Builder.from_string("func(");
            if func_sym.is_method {
                if func_sym.self_is_mut {
                    sb.write_string("mut ");
                } else if func_sym.self_is_ptr {
                    sb.write_string("&");
                }
                sb.write_string("self");
            }
            for i, arg in func_sym.args {
                sb.write_string(arg.type.to_qualstring());
                if i < func_sym.args.len - 1 {
                    sb.write_string(", ");
                }
            }
            sb.write_byte(b')');
            if func_sym.ret_type !is .Void {
                sb.write_fmt(" {}", func_sym.ret_type.to_qualstring());
            }
            sb.to_string()
        };
        if type_sym := self.scope.find(unique_name) {
            return @as(TypeSym, type_sym);
        }
        type_sym := TypeSym(is_public: true, name: unique_name, info: .Func(func_sym));
        self.scope.add(type_sym) catch {};
        return type_sym;
    }

    #[inline]
    public func is_core(self) -> bool {
        return self.name == "core";
    }
}

#[boxed]
public struct Const < Sym {
    public mut expr: Expr;
    public mut evaled_expr: Expr;
    public mut has_evaled_size: bool;
    public mut evaled_size: isize;
    public mut type: Type;
    public pos: token.Pos;
}

public enum VarLevel as uint8 {
    Module, // module-level, `static`
    Receiver, // receiver: `self`
    Argument, // argument-level
    Local // inside function
}

#[boxed]
public struct Var < Sym {
    public is_extern: bool;
    public is_mut: bool;
    public mut is_used: bool;
    public mut is_changed: bool;
    public mut is_hidden_ref: bool;
    public mut mir_name: string; // used for duplicate objects in MIR
    public level: VarLevel;
    public mut type: Type;
    public pos: token.Pos;
}

#[boxed]
public struct Arg {
    public name: string;
    public is_mut: bool;
    public is_self: bool;
    public has_def_expr: bool;
    public mut def_expr: Expr;
    public pos: token.Pos;
    public mut type: Type;
}

#[boxed]
public struct Func < Sym {
    public is_extern: bool;
    public is_unsafe: bool;
    public is_main: bool;
    public is_method: bool;
    public is_special_method: bool;
    public is_variadic: bool;
    public mut self_type: Type;
    public self_is_mut: bool;
    public self_is_ptr: bool;
    public self_pos: token.Pos;
    public args: []Arg;
    public has_named_args: bool;
    public has_body: bool;
    public ret_type: Type;
    public pos: token.Pos;

    public func get_arg(self, idx: usize) -> Arg {
        arg := self.args[idx];
        return if arg.is_self {
            self.args[idx + 1]
        } else {
            arg
        };
    }

    public func args_len(self) -> usize {
        mut len: usize := 0;
        for arg in self.args {
            if !(arg.is_self or arg.type is .Variadic) {
                len += 1;
            }
        }
        return len;
    }

    #[inline]
    public func kind(self) -> string {
        return if self.is_method {
            if self.is_special_method {
                "special method"
            } else {
                "method"
            }
        } else {
            "function"
        };
    }

	#[inline]
    public func type(self, mut universe: Module) -> Type {
        return .Func(
            is_method: self.is_method,
            self_is_mut: self.self_is_mut,
            self_is_ptr: self.self_is_ptr,
            args: self.args,
            ret_type: self.ret_type,
            sym: universe.add_or_get_func(self),
            has_sym: true,
            pos: token.noPos
        );
    }
}
