// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/traits;
import std/strings;

import ../token;

var mut SYM_IDS: usize = 0;

func new_sym_id() usize {
    res := SYM_IDS;
    SYM_IDS += 1;
    return res;
}

[boxed]
public struct DuplicateSymbolError : Error {
    msg: string;

    public func to_string(self) string {
        return self.msg;
    }
}

public enum ABI as uint8 : traits.Stringable {
    Rivet,
    C;

    [inline]
    public func from_string(abi: string) ?ABI {
        return switch abi {
            "C" => .C,
            "Rivet" => .Rivet,
            else => none
        };
    }

    [inline]
    public func to_string(&self) string {
        return switch self.* {
            .C => "C",
            .Rivet => "Rivet"
        };
    }
}

public trait Sym {
    id: usize = new_sym_id();
    abi: ABI;
    mut is_public: bool;
    mut parent: ?Sym;
    name: string;
    mut scope: Scope;
    mut mangled_name: string;
    mut qualified_name: string;
    is_universe: bool;
    is_root: bool;

    func mod(self) ?Module {
        mut p := self;
        while {
            if p is Module as mod {
                return mod;
            } else if p_ := p.parent {
                p = p_;
            } else {
                break;
            }
        }
        return none;
    }

    func has_access_to(self, other: Sym) bool {
        self_mod := self.mod() ?? return false;
        other_mod := other.mod() ?? return false;
        return (
            other_mod.is_universe or self_mod.id == other.id
            or self_mod.id == other_mod.id
            or self_mod.id == other_mod.parent?.id
            or self_mod.parent?.id == other.parent?.id
        );
    }

    func type_of(self) string {
        return switch self is {
            SymRef as sym_ref => if sym_ref.ref_resolved {
                sym_ref.ref.type_of()
            } else {
                "alias"
            },
            Module => "module",
            Const => "constant",
            Var as obj => switch obj.level {
                .Receiver, .Argument => "argument",
                else => "variable"
            },
            TypeSym as type_sym => if type_sym.info.is_compound() {
                type_sym.info.to_string()
            } else {
                "type"
            },
            Func as func_info => func_info.kind(),
            else => "unknown symbol kind"
        };
    }

    func qualname(self) string {
        return if parent := self.parent {
            if parent.is_universe {
                self.name
            } else {
                parent.qualname().concat(".", self.name)
            }
        } else {
            self.name
        };
    }

    func ==(self, other: Self) bool {
        return self.id == other.id;
    }

    func !=(self, other: Self) bool {
        return self.id != other.id;
    }
}

[boxed]
public struct SymRef : Sym {
    public mut ref: Sym;
    public mut ref_expr: Expr;
    public mut ref_resolved: bool;
}

[boxed]
public struct Module : Sym {
    public func add_or_get_array(mut self, elem_typ: Type, size: usize, is_mut: bool) TypeSym {
        unique_name := if is_mut {
            "[{}]mut {}"
        } else {
            "[{}]{}"
        }.fmt(size, elem_typ.to_qualstring());
        if type_sym := self.scope.find(unique_name) {
            return @cast(TypeSym, type_sym);
        }
        type_sym := TypeSym(
            is_public: true,
            name: unique_name,
            info: .Array(elem_typ, size, is_mut),
            fields: [
                Field(
                    name: "len", is_public: true,
                    type: .Basic(self.scope.find_type_symbol_by_index_or_panic(12))
                )
            ]
        );
        self.scope.add(type_sym) catch {};
        return type_sym;
    }

    public func add_or_get_vec(mut self, elem_type: Type, is_mut: bool) TypeSym {
        unique_name := if is_mut { "[]mut " } else { "[]" }.concat(elem_type.to_qualstring());
        if type_sym := self.scope.find(unique_name) {
            return @cast(TypeSym, type_sym);
        }
        type_sym := TypeSym(
            is_public: true,
            name: unique_name,
            info: .Vector(elem_type, is_mut),
            fields: [
                Field(
                    name: "len", is_public: true,
                    type: .Basic(self.scope.find_type_symbol_by_index_or_panic(12))
                ),
                Field(
                    name: "cap", is_public: true,
                    type: .Basic(self.scope.find_type_symbol_by_index_or_panic(12))
                )
            ]
        );
        type_sym.scope.add(Func(
            name: "push",
            is_public: true,
            is_method: true,
            self_type: .Basic(type_sym),
            self_is_mut: true,
            args: [Arg("value", type: elem_type, pos: token.NO_POS)],
            ret_type: .Void(),
            has_body: true
        )) catch {};
        type_sym.scope.add(Func(
            name: "pop",
            is_public: true,
            is_method: true,
            self_type: .Basic(type_sym),
            self_is_mut: true,
            ret_type: elem_type,
            has_body: true
        )) catch {};
        type_sym.scope.add(Func(
            name: "clone",
            is_public: true,
            is_method: true,
            self_type: .Basic(type_sym),
            ret_type: .Basic(type_sym),
            has_body: true
        )) catch {};
        if vector_sym := self.scope.find("core")?.scope.find("Vector") {
            if is_empty_m := vector_sym.scope.find("is_empty") {
                type_sym.scope.add(is_empty_m) catch {};
            }
            if delete_m := vector_sym.scope.find("delete") {
                type_sym.scope.add(delete_m) catch {};
            }
            if trim_m := vector_sym.scope.find("trim") {
                type_sym.scope.add(trim_m) catch {};
            }
            if clear_m := vector_sym.scope.find("clear") {
                type_sym.scope.add(clear_m) catch {};
            }
        }
        self.scope.add(type_sym) catch {};
        return type_sym;
    }

    public func add_or_get_tuple(mut self, types: []Type) TypeSym {
        unique_name := {
            mut sb := strings.Builder.from_string("(");
            for i, type in types {
                sb.write_string(type.to_qualstring());
                if i < types.len - 1 {
                    sb.write_string(", ");
                }
            }
            sb.write_byte(b')');
            sb.to_string()
        };
        if type_sym := self.scope.find(unique_name) {
            return @cast(TypeSym, type_sym);
        }
        mut fields := @vec(Field);
        for i, type in types {
            fields.push(Field(name: i.to_string(), is_public: true, type: type));
        }
        type_sym := TypeSym(
            is_public: true, name: unique_name, info: .Tuple(types), fields: fields
        );
        self.scope.add(type_sym) catch {};
        return type_sym;
    }

    [inline]
    public func is_core(self) bool {
        return self.name == "core";
    }
}

[boxed]
public struct Const : Sym {
    public mut expr: Expr;
    public mut evaled_expr: Expr;
    public mut has_evaled_size: bool;
    public mut evaled_size: isize;
    public mut type: Type;
    public pos: token.Pos;
}

public enum VarLevel as uint8 {
    Module, // module-level
    Receiver, // receiver: `self`
    Argument, // argument-level
    Local // inside function
}

[boxed]
public struct Var : Sym {
    public is_extern: bool;
    public is_mut: bool;
    public mut is_used: bool;
    public mut is_changed: bool;
    public mut is_hidden_ref: bool;
    public mut ir_name: string; // used for duplicate objects in IR
    public level: VarLevel;
    public mut type: Type;
    public pos: token.Pos;
}

[boxed]
public struct Field {
    public is_public: bool;
    public name: string;
    public is_mut: bool;
    public has_def_expr: bool;
    public def_expr: Expr;
    public type: Type;
}

[boxed]
public struct TypeSym : Sym {
    public mut fields: []Field;
    public mut full_fields_: []Field;
    public mut info: TypeInfo;
    public mut size: isize = -1;
    public mut align: isize = -1;

    public func lookup_field(self, name: string) ?Field {
        for f in self.fields {
            if f.name == name {
                return f;
            }
        }
        if self.info is .Struct as struct_info {
            for b in struct_info.bases {
                if f := b.lookup_field(name) {
                    return f;
                }
            }
        }
        return none;
    }

    [inline]
    public func has_field(self, name: string) bool {
        return self.lookup_field(name) !is none;
    }

    public func lookup_in_base(self, name: string) ?Sym {
        if self.info is .Struct as struct_info {
            for b in struct_info.bases {
                if s := b.lookup(name) {
                    return s;
                }
            }
        }
        return none;
    }

    [inline]
    public func lookup(self, name: string) ?Sym {
        return if s := self.scope.lookup(name) {
            s
        } else if s := self.lookup_in_base(name) {
            s
        } else {
            none
        };
    }

    public func full_fields(mut self) []Field {
        if !self.full_fields_.is_empty() {
            return self.full_fields_;
        }
        mut fields := @vec(Field);
        if self.info is .Struct as struct_info {
            for mut b in struct_info.bases {
                for bf in b.full_fields() {
                    fields.push(bf);
                }
            }
        }
        for f in self.fields {
            fields.push(f);
        }
        self.full_fields_ = fields;
        return fields;
    }

    [inline]
    public func implement_trait(self, trait_sym: TypeSym) bool {
        return if trait_sym.info is .Trait as trait_info {
            self in trait_info.implements
        } else {
            false
        };
    }

    public func update(mut self, other: TypeSym) ! {
        if self.info is .Placeholder {
            // update placeholder
            self.is_public = other.is_public;
            self.info = other.info;
            self.fields = other.fields;
            for s in other.scope.syms {
                self.scope.add(s)!;
            }
        }
    }

    [inline]
    public func is_boxed(self) bool {
        return if self.info is .Enum as enum_info {
            enum_info.is_boxed
        } else if self.info is .Struct as struct_info {
            struct_info.is_boxed
        } else {
            self.info is .Trait or self.info is .String or self.info is .Vector
        };
    }

    [inline]
    public func is_primitive(self) bool {
        return self.info.is_primitive();
    }

    [inline]
    public func ==(self, rhs: Self) bool {
        return self.id == rhs.id;
    }

    [inline]
    public func !=(self, rhs: Self) bool {
        return self.id != rhs.id;
    }
}

[boxed]
public struct Arg {
    public name: string;
    public is_mut: bool;
    public is_self: bool;
    public has_def_expr: bool;
    public def_expr: Expr;
    public pos: token.Pos;
    public mut type: Type;
}

[boxed]
public struct Func : Sym {
    public is_extern: bool;
    public is_unsafe: bool;
    public is_main: bool;
    public is_method: bool;
    public is_variadic: bool;
    public mut self_type: Type;
    public self_is_mut: bool;
    public self_is_ref: bool;
    public args: []Arg;
    public has_named_args: bool;
    public has_body: bool;
    public ret_type: Type;

    public func get_arg(self, idx: usize) Arg {
        arg := self.args[idx];
        return if arg.is_self {
            self.args[idx + 1]
        } else {
            arg
        };
    }

    public func args_len(self) usize {
        mut len: usize := 0;
        for arg in self.args {
            if !(arg.is_self or arg.type is .Variadic) {
                len += 1;
            }
        }
        return len;
    }

    [inline]
    public func kind(self) string {
        return if self.is_method { "method" } else { "function" };
    }

	[inline]
    public func type(self) Type {
        return .Func(
            is_method: self.is_method,
            self_is_mut: self.self_is_mut,
            self_is_ref: self.self_is_ref,
            args: self.args,
            ret_type: self.ret_type,
            pos: token.NO_POS
        );
    }
}
