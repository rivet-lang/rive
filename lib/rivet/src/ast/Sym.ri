// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import "std/traits";

import "../token";

var mut SYM_IDS: usize = 0;

func new_sym_id() usize {
    res := SYM_IDS;
    SYM_IDS += 1;
    return res;
}

[boxed]
public struct DuplicateSymbolError : Error {
    msg: string;

    public func to_string(self) string {
        return self.msg;
    }
}

public enum ABI as uint8 : traits.Stringable {
    Rivet,
    C;

    [inline]
    public func from_string(abi: string) ?ABI {
        return switch abi {
            "C" => .C,
            "Rivet" => .Rivet,
            else => none
        };
    }

    [inline]
    public func to_string(&self) string {
        return switch self.* {
            .C => "C",
            .Rivet => "Rivet"
        };
    }
}

public trait Sym {
    id: usize = new_sym_id();
    abi: ABI;
    mut is_public: bool;
    parent: ?Sym;
    name: string;
    mut scope: Scope;
    mut mangled_name: string;
    mut qualified_name: string;
    is_universe: bool;
    is_root: bool;

    [inline]
    func qualname(self) string {
        return if parent := self.parent {
            if parent.is_universe {
                self.name
            } else {
                parent.qualname().concat(".", self.name)
            }
        } else {
            self.name
        };
    }

    [inline]
    func ==(self, other: Self) bool {
        return self.id == other.id;
    }
}

[boxed]
public struct Mod : Sym { }

[boxed]
public struct Const : Sym {
    public expr: Expr;
    public evaled_expr: ?Expr;
    public typ: Type;
}

public enum VarLevel as uint8 {
    Mod, // module-level
    Rec, // receiver: `self`
    Arg, // argument-level
    Local // inside function
}

[boxed]
public struct Var : Sym {
    public is_extern: bool;
    public ir_name: string; // used for duplicate objects in IR
    public is_mut: bool;
    public is_used: bool;
    public is_changed: bool;
    public is_hidden_ref: bool;
    public level: VarLevel;
    public typ: Type;
}

[boxed]
public struct Field {
    public is_public: bool;
    public name: string;
    public is_mut: bool;
    public def_expr: ?Expr;
    public typ: Type;
}

public enum TypeKind : traits.Stringable {
    Placeholder,
    Never,
    None,
    Bool,
    Rune,
    Int8,
    Int16,
    Int32,
    Int64,
    Uint8,
    Uint16,
    Uint32,
    Uint64,
    Isize,
    Usize,
    ComptimeInt,
    ComptimeFloat,
    Float32,
    Float64,
    String,
    Alias,
    Array,
    Vector,
    Tuple,
    Enum,
    Trait,
    Struct;

    [inline]
    public func is_primitive(self) bool {
        return self in [
            .None, .Bool, .Rune, .Int8, .Int16, .Int32, .Int64, .Isize, .Uint8,
            .Uint16, .Uint32, .Uint64, .Usize, .ComptimeInt, .ComptimeFloat, .Float32,
            .Float64, .Never
        ];
    }

    [inline]
    public func to_string(&self) string {
        return switch self.* {
            .None => "none",
            .Bool => "bool",
            .Rune => "rune",
            .Int8 => "int8",
            .Int16 => "int16",
            .Int32 => "int32",
            .Int64 => "int64",
            .Isize => "isize",
            .Uint8 => "uint8",
            .Uint16 => "uint16",
            .Uint32 => "uint32",
            .Uint64 => "uint64",
            .Usize => "usize",
            .ComptimeInt => "comptime_int",
            .ComptimeFloat => "comptime_float",
            .Float32 => "float32",
            .Float64 => "float64",
            .String => "string",
            .Alias => "alias",
            .Array => "array",
            .Vector => "vector",
            .Tuple => "tuple",
            .Trait => "trait",
            .Struct => "struct",
            .Enum => "enum",
            .Never => "never",
            else => "placeholder"
        };
    }
}

public enum TypeInfo {
    Alias: AliasInfo,
    Array: ArrayInfo,
    Vector: VectorInfo,
    Tuple: TupleInfo,
    Enum: EnumInfo,
    Trait: TraitInfo,
    Struct: StructInfo
}

[boxed]
public struct AliasInfo {
    public parent: Type;
}

[boxed]
public struct ArrayInfo {
    public elem_typ: Type;
    public size: isize;
    public has_contains_method: bool;
}

[boxed]
public struct VectorInfo {
    public elem_typ: Type;
    public has_contains_method: bool;
}

[boxed]
public struct TupleInfo {
    public types: []Type;
}

[boxed]
public struct EnumVariant {
    public name: string;
    public value: isize;
    public has_typ: bool;
    public typ: Type;
}

[boxed]
public struct EnumInfo {
    public underlying_typ: Type;
    public mut variants: []EnumVariant;
    public is_boxed_enum: bool;

    [inline]
    public func add_value(mut self, name: string, variant: isize) {
        self.variants.push(EnumVariant(name, variant));
    }

    public func get_value(self, name: string) ?EnumVariant {
        for v in self.variants {
            if v.name == name {
                return v;
            }
        }
        return none;
    }

    public func get_variant_by_type(self, typ: Type) ?EnumVariant {
        for v in self.variants {
            if v.has_typ and v.typ == typ {
                return v;
            }
        }
        return none;
    }

    public func has_value(self, name: string) bool {
        return self.get_value(name) !is none;
    }
}

[boxed]
public struct TraitInfo {
    public bases: []mut TraitInfo;
    public mut implements: []TypeSym;
    public mut has_objects: bool;

    public func index_of(self, type_sym: TypeSym) ?usize {
        for i, ts in self.implements {
            if ts.id == type_sym.id {
                return i;
            }
        }
        return none;
    }

    public func implement(mut self, type_sym: TypeSym) {
        self.implements.push(type_sym);
        for mut b in self.bases {
            b.implement(type_sym);
        }
    }

    public func mark_has_objects(mut self) {
        self.has_objects = true;
    }
}

[boxed]
public struct StructInfo {
    public is_boxed: bool;
    public is_opaque: bool;
    public bases: []mut TypeSym;
    public traits: []TypeSym;
}

[boxed]
public struct TypeSym : Sym {
    public mut fields: []Field;
    public mut full_fields_: []Field;
    public mut kind: TypeKind;
    public mut info: TypeInfo;
    public mut size: isize = -1;
    public mut align: isize = -1;

    public func lookup_field(self, name: string) ?Field {
        for f in self.fields {
            if f.name == name {
                return f;
            }
        }
        if self.info is .Struct as struct_info {
            for b in struct_info.bases {
                if f := b.lookup_field(name) {
                    return f;
                }
            }
        }
        return none;
    }

    [inline]
    public func has_field(self, name: string) bool {
        return self.lookup_field(name) !is none;
    }

    public func lookup_in_base(self, name: string) ?Sym {
        if self.info is .Struct as struct_info {
            for b in struct_info.bases {
                if s := b.lookup(name) {
                    return s;
                }
            }
        }
        return none;
    }

    [inline]
    public func lookup(self, name: string) ?Sym {
        return if s := self.scope.lookup(name) {
            s
        } else if s := self.lookup_in_base(name) {
            s
        } else {
            none
        };
    }

    public func full_fields(mut self) []Field {
        if !self.full_fields_.is_empty() {
            return self.full_fields_;
        }
        mut fields := @vec(Field);
        if self.info is .Struct as struct_info {
            for mut b in struct_info.bases {
                for bf in b.full_fields() {
                    fields.push(bf);
                }
            }
        }
        for f in self.fields {
            fields.push(f);
        }
        self.full_fields_ = fields;
        return fields;
    }

    public func update(mut self, other: TypeSym) ! {
        if self.kind == .Placeholder {
            // update placeholder
            self.is_public = other.is_public;
            self.kind = other.kind;
            self.fields = other.fields;
            for s in other.scope.syms {
                self.scope.add(s).!;
            }
            self.info = other.info;
        }
    }

    [inline]
    public func is_boxed(self) bool {
        return if self.info is .Enum as enum_info {
            enum_info.is_boxed_enum
        } else if self.info is .Struct as struct_info {
            struct_info.is_boxed
        } else {
            self.kind == .Trait or self.kind == .String or self.kind == .Vector
        };
    }

    [inline]
    public func is_primitive(self) bool {
        return if self.info is .Enum as enum_info {
            !enum_info.is_boxed_enum
        } else {
            self.kind.is_primitive()
        };
    }

    [inline]
    public func ==(self, rhs: Self) bool {
        return self.id == rhs.id;
    }
}

[boxed]
public struct Arg {
    public name: string;
    public is_mut: bool;
    public is_self: bool;
    public def_expr: ?Expr;
    public pos: token.Pos;
    public mut typ: Type;
}

[boxed]
public struct Func : Sym {
    public is_extern: bool;
    public is_unsafe: bool;
    public is_main: bool;
    public is_method: bool;
    public is_variadic: bool;
    public self_typ: Type;
    public self_is_mut: bool;
    public self_is_ref: bool;
    public args: []Arg;
    public has_named_args: bool;
    public has_body: bool;
    public ret_typ: Type;

    public func get_arg(self, idx: usize) Arg {
        arg := self.args[idx];
        return if arg.is_self {
            self.args[idx + 1]
        } else {
            arg
        };
    }

    public func args_len(self) usize {
        mut len: usize := 0;
        for arg in self.args {
            if !(arg.is_self or arg.typ is .Variadic) {
                len += 1;
            }
        }
        return len;
    }

    [inline]
    public func kind(self) string {
        return if self.is_method { "method" } else { "function" };
    }
}

[boxed]
public struct Scope {
    public start: usize;
    public mut end: usize;
    public mut parent: ?Scope;
    public mut detached_from_parent: bool;
    public mut childrens: []Scope;
    public mut syms: []Sym;

    public func add(mut self, sym: Sym) ! {
        if sym.name == "_" and sym is Var {
            return; // ignore blank var
        } else if self.exists(sym.name) {
            return DuplicateSymbolError("duplicate symbol `{}`".fmt(sym.name));
        }
        self.syms.push(sym);
    }

    [inline]
    public func exists(self, name: string) bool {
        return self.lookup(name) !is none;
    }

    public func lookup(self, name: string) ?Sym {
        mut sc_: ?Scope := self;
        while sc := sc_ {
            for sym in self.syms {
                if sym.name == name {
                    return sym;
                }
            }
            if sc.dont_lookup_parent() {
                break;
            }
            sc_ = sc.parent;
        }
        return none;
    }

    [inline]
    func dont_lookup_parent(self) bool {
        return self.detached_from_parent or self.parent is none;
    }
}

[inline]
public func universe() Mod {
    return Mod(is_public: false, name: "universe", scope: Scope(syms: [
        TypeSym(is_public: true, name: "never", kind: .Never),
        TypeSym(is_public: true, name: "none", kind: .None),
        TypeSym(is_public: true, name: "bool", kind: .Bool),
        TypeSym(is_public: true, name: "rune", kind: .Rune),
        TypeSym(is_public: true, name: "int8", kind: .Int8),
        TypeSym(is_public: true, name: "int16", kind: .Int16),
        TypeSym(is_public: true, name: "int32", kind: .Int32),
        TypeSym(is_public: true, name: "int64", kind: .Int64),
        TypeSym(is_public: true, name: "isize", kind: .Isize),
        TypeSym(is_public: true, name: "uint8", kind: .Uint8),
        TypeSym(is_public: true, name: "uint16", kind: .Uint16),
        TypeSym(is_public: true, name: "uint32", kind: .Uint32),
        TypeSym(is_public: true, name: "uint64", kind: .Uint64),
        TypeSym(is_public: true, name: "usize", kind: .Usize),
        TypeSym(is_public: true, name: "comptime_int", kind: .ComptimeInt),
        TypeSym(is_public: true, name: "comptime_float", kind: .ComptimeFloat),
        TypeSym(is_public: true, name: "float32", kind: .Float32),
        TypeSym(is_public: true, name: "float64", kind: .Float64),
        TypeSym(is_public: true, name: "string", kind: .String, info: .Struct(
            StructInfo(is_boxed: true)
        ))
    ]));
}
