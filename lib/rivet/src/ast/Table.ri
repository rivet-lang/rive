// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/sys;
import std/fs/path;

import ../token;
import ../prefs;
import ../report;
import ../utils;

[boxed]
public struct Table {
    /// `.universe` is the mega-module where all the modules being
    /// compiled reside.
    public mut universe: Module;
    public mut prefs: prefs.Prefs;

    public pointer_size: usize;

    public mut core_mod: Module;
    public mut vector_sym: TypeSym; // from `core` module
    public mut error_sym: TypeSym; // from `core` module
    public mut error_sym_is_set: bool;

    public mut builtins: []Builtin;

    // Primitive types.
    public mut none_t: Type;
    public mut bool_t: Type;
    public mut rune_t: Type;
    public mut int8_t: Type;
    public mut int16_t: Type;
    public mut int32_t: Type;
    public mut int64_t: Type;
    public mut isize_t: Type;
    public mut uint8_t: Type;
    public mut uint16_t: Type;
    public mut uint32_t: Type;
    public mut uint64_t: Type;
    public mut usize_t: Type;
    public mut comptime_int_t: Type;
    public mut comptime_float_t: Type;
    public mut float32_t: Type;
    public mut float64_t: Type;
    public mut string_t: Type;
    public mut error_t: Type;

    public mut source_files: []SourceFile;

    [inline]
    public func new(prefs_: prefs.Prefs) Table {
        universe_ := universe();
        mut table := Table(
            universe: universe_,
            prefs: prefs_,
            none_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(0)),
            bool_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(1)),
            rune_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(2)),
            int8_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(3)),
            int16_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(4)),
            int32_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(5)),
            int64_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(6)),
            isize_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(7)),
            uint8_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(8)),
            uint16_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(9)),
            uint32_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(10)),
            uint64_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(11)),
            usize_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(12)),
            comptime_int_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(13)),
            comptime_float_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(14)),
            float32_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(15)),
            float64_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(16)),
            string_t: .Basic(universe_.scope.find_type_symbol_by_index_or_panic(17)),
            pointer_size: if prefs_.target_is_64bit {
                8
            } else {
                4
            }
        );
        table.setup_builtins();
        return table;
    }

    func setup_builtins(mut self) {
        self.builtins = [
            // variables
            .Const("_FILE_", self.string_t),
            .Const("_LINE_", self.usize_t),
            .Const("_COLUMN_", self.usize_t),
            .Const("_FUNCTION_", self.string_t),
            .Const("_RIVET_VERSION_", self.string_t),
            .Const("_RIVET_COMMIT_", self.string_t),

            // functions
            .Func("size_of", [BuiltinArg("value", is_any: true)], self.usize_t),
            .Func("align_of", [BuiltinArg("value", is_any: true)], self.usize_t),
            .Func("ptr_add", [
                BuiltinArg("pointer", type: .Anyptr()),
                BuiltinArg("value", type: self.usize_t)
            ], .Anyptr()),
            .Func("ptr_diff", [
                BuiltinArg("pointer", type: .Anyptr()),
                BuiltinArg("pointer2", type: .Anyptr())
            ], .Anyptr()),
            .Func("cast", [
                BuiltinArg("type", is_any: true),
                BuiltinArg("value", is_any: true)
            ], return_is_any: true),
            .Func("type_name", [], self.string_t),
            .Func("unreachable", []),
            .Func("breakpoint", []),
            .Func("assert", [
                BuiltinArg("cond", type: self.bool_t),
                BuiltinArg("msg", type: self.string_t, is_optional: true)
            ]),
            .Func("vec", [
                BuiltinArg("type", is_any: true),
                BuiltinArg("cap", type: self.usize_t, is_optional: true)
            ], return_is_any: true),
            .Func("set_enum_ref_value", [
                BuiltinArg("enum_value", is_any: true, is_mut: true),
                BuiltinArg("new_value", is_any: true)
            ], return_is_any: true, is_unsafe: true),
            // TODO: rename to `ignore_warn`: `@ignore_warn(not_mutated, expr)`.
            .Func("ignore_not_mutated_warn", [
                BuiltinArg("expr", is_any: true, is_mut: true)
            ])
        ];
    }

    public func find_builtin(self, name: string) ?Builtin {
        for builtin in self.builtins {
            is_same := switch builtin is {
                .Const as b_var => b_var.name == name,
                .Func as b_func => b_func.name == name,
                else => false
            };
            if is_same {
                return builtin;
            }
        }
        return none;
    }

    public func exist_builtin(self, name: string) bool {
        return self.find_builtin(name) !is none;
    }

    [inline]
    public func is_number(self, type: Type) bool {
        return self.is_int(type) or self.is_float(type);
    }

    [inline]
    public func is_int(self, type: Type) bool {
        return self.is_signed_int(type) or self.is_unsigned_int(type);
    }

    [inline]
    public func is_signed_int(self, type: Type) bool {
        return type in [
            self.int8_t, self.int16_t, self.int32_t, self.int64_t, self.isize_t,
            self.comptime_int_t
        ];
    }

    [inline]
    public func is_unsigned_int(self, type: Type) bool {
        return type in [
            self.uint8_t, self.uint16_t, self.uint32_t, self.uint64_t, self.usize_t
        ];
    }

    [inline]
    public func is_float(self, type: Type) bool {
        return type in [self.float32_t, self.float64_t, self.comptime_float_t];
    }

    [inline]
    public func is_comptime_number(self, type: Type) bool {
        return type == self.comptime_int_t or type == self.comptime_float_t;
    }

    public func comptime_number_to_type(self, type: Type) Type {
        return if type == self.comptime_int_t {
            self.int64_t
        } else if type == self.comptime_float_t {
            self.float64_t
        } else {
            type
        };
    }

    public func num_bits(self, type: Type) usize {
        return if self.is_int(type) {
            self.int_bits(type)
        } else {
            self.float_bits(type)
        };
    }

    public func int_bits(self, type: Type) usize {
        type_sym := type.symbol()?;
        return if type_sym.info is .Int as int_info {
            int_info.size
        } else if type_sym.info is .ComptimeInt or type_sym.info is .Isize
            or type_sym.info is .Usize {
            isize.bits()
        } else {
            666
        };
    }

    public func float_bits(self, type: Type) usize {
        type_sym := type.symbol()?;
        return if type_sym.info is .Float as float_info {
            float_info.size
        } else if type_sym.info is .ComptimeFloat {
            64
        } else {
            666
        };
    }

    public func filter_files(self, inputs: []string) []string {
        mut new_inputs := @vec(string, inputs.len);
        for input in inputs {
            basename_input := path.basename(input);
            if basename_input == "project.ri" {
                continue; // Skip `project.ri` file, loaded after
            } else if basename_input.count(".") == 1 {
                new_inputs.push(input);
                continue;
            }
            exts := basename_input[..basename_input.len - 3].split(".")[1..];
            mut already_exts := @vec(string, exts.len);
            mut should_compile := false;
            for ext in exts {
                if ext in already_exts {
                    utils.error("{}: duplicate special extension `{}`", input, ext);
                    continue;
                }
                already_exts.push(ext);
                if ext.starts_with("d_") or ext.starts_with("notd_") {
                    should_compile = should_compile and if ext.starts_with("d_") {
                        ext[2..] in self.prefs.flags
                    } else {
                        ext[2..] !in self.prefs.flags
                    };
                } else if os := sys.OS.from_string(ext) {
                    should_compile = should_compile and self.prefs.target_os == os;
                } else if arch := sys.Arch.from_string(ext) {
                    should_compile = should_compile and self.prefs.target_arch == arch;
                } else if ext in ["x32", "x64"] {
                    should_compile = should_compile and if ext == "x32" {
                        !self.prefs.target_is_64bit
                    } else {
                        self.prefs.target_is_64bit
                    };
                } else if ext in ["little_endian", "big_endian"] {
                    should_compile = should_compile and if ext == "little_endian" {
                        self.prefs.target_is_little_endian
                    } else {
                        !self.prefs.target_is_little_endian
                    };
                } else if backend := prefs.Backend.from_string(ext) {
                    should_compile = should_compile and backend == self.prefs.target_backend;
                } else {
                    utils.error("{}: unknown special extension `{}`", input, ext);
                    break;
                }
            }
            if should_compile {
                new_inputs.push(input);
            }
        }
        return new_inputs;
    }

    public func evalue_pp_symbol(self, name: string, pos: token.Pos) bool {
        switch name {
            // operating systems
            "_LINUX_", "_WINDOWS_" => {
                return if os := sys.OS.from_string(name) {
                    os == self.prefs.target_os
                } else {
                    false
                };
            },
            // architectures
            "_X86_", "_AMD64_" => {
                return if os := sys.Arch.from_string(name) {
                    os == self.prefs.target_arch
                } else {
                    false
                };
            },
            // bits
            "_x32_", "_x64_" => {
                return if name == "_x32_" {
                    !self.prefs.target_is_64bit
                } else {
                    self.prefs.target_is_64bit
                };
            },
            // endian
            "_LITTLE_ENDIAN_", "_BIG_ENDIAN_" => {
                return if name == "_LITTLE_ENDIAN_" {
                    self.prefs.target_is_little_endian
                } else {
                    !self.prefs.target_is_little_endian
                };
            },
            // optimize modes
            "_DEBUG_", "_RELEASE_" => {
                return if name == "_DEBUG_" {
                    self.prefs.optimize_mode == .Debug
                } else {
                    self.prefs.optimize_mode == .Release
                };
            },
            "_TESTS_" => return self.prefs.is_test,
            else => return if name.starts_with("_") and name.ends_with("_") {
                report.error("unknown builtin flag: `{}`".fmt(name), pos);
                false
            } else {
                name in self.prefs.flags
            }
        }
    }
}

public enum Builtin {
    Const {
        name: string;
        type: Type;
    },
    Func {
        name: string;
        args: []BuiltinArg;
        type: Type;
        return_is_any: bool;
        is_unsafe: bool;
    };

    public func type(self) Type {
        return switch self is {
            .Const as b_const => b_const.type,
            .Func as b_func => b_func.type
        };
    }
}

struct BuiltinArg {
    public name: string;
    public is_mut: bool;
    public is_any: bool; // any type
    public type: Type;
    public is_optional: bool;
}
