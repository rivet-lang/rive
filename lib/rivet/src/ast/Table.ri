// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/sys;
import std/process;
import std/fs.Path;

import ../token;
import ../prefs;
import ../report;
import ../utils;

#[boxed]
pub struct Table {
    /// `.universe` is the mega-module where all the modules being
    /// compiled reside.
    pub mut universe: Module;
    pub mut prefs: prefs.Prefs;
    pub mut source_files: []mut SourceFile;

    pub pointer_size: uint;

    pub mut core_mod: Module;
    pub mut throwable_sym_is_set: bool;

    pub mut builtins: []Builtin;

    pub mut c_defines: CDefines;
    pub mut c_include_paths: []string;
    pub mut c_user_include_paths: []string;

    /// Primitive type, Throwable and DynArray symbols.
    pub mut bool_sym: TypeSym;
    pub mut rune_sym: TypeSym;
    pub mut int8_sym: TypeSym;
    pub mut int16_sym: TypeSym;
    pub mut int32_sym: TypeSym;
    pub mut int64_sym: TypeSym;
    pub mut int_sym: TypeSym;
    pub mut uint8_sym: TypeSym;
    pub mut uint16_sym: TypeSym;
    pub mut uint32_sym: TypeSym;
    pub mut uint64_sym: TypeSym;
    pub mut uint_sym: TypeSym;
    pub mut comptime_int_sym: TypeSym;
    pub mut comptime_float_sym: TypeSym;
    pub mut float32_sym: TypeSym;
    pub mut float64_sym: TypeSym;
    pub mut string_sym: TypeSym;
    pub mut throwable_sym: TypeSym;
    pub mut dyn_array_sym: TypeSym; // from `core` module

    /// Primitive types.
    pub mut bool_t: Type;
    pub mut rune_t: Type;
    pub mut int8_t: Type;
    pub mut int16_t: Type;
    pub mut int32_t: Type;
    pub mut int64_t: Type;
    pub mut int_t: Type;
    pub mut uint8_t: Type;
    pub mut uint16_t: Type;
    pub mut uint32_t: Type;
    pub mut uint64_t: Type;
    pub mut uint_t: Type;
    pub mut comptime_int_t: Type;
    pub mut comptime_float_t: Type;
    pub mut float32_t: Type;
    pub mut float64_t: Type;
    pub mut string_t: Type;
    pub mut throwable_t: Type;

    #[inline]
    pub func new(prefs_: prefs.Prefs) -> Table {
        report.reportTable.prefs = prefs_;
        universe_ := universe();
        mut table := Table(
            universe: universe_,
            prefs: prefs_,
            pointer_size: if prefs_.target_is_64bit {
                8
            } else {
                4
            }
        );
        table.setup_primitives();
        table.setup_builtins();
        return table;
    }

    func setup_primitives(mut self) {
        self.bool_sym = self.universe.scope.find_type_symbol_by_index_or_panic(0);
        self.rune_sym = self.universe.scope.find_type_symbol_by_index_or_panic(1);
        self.int8_sym = self.universe.scope.find_type_symbol_by_index_or_panic(2);
        self.int16_sym = self.universe.scope.find_type_symbol_by_index_or_panic(3);
        self.int32_sym = self.universe.scope.find_type_symbol_by_index_or_panic(4);
        self.int64_sym = self.universe.scope.find_type_symbol_by_index_or_panic(5);
        self.int_sym = self.universe.scope.find_type_symbol_by_index_or_panic(6);
        self.uint8_sym = self.universe.scope.find_type_symbol_by_index_or_panic(7);
        self.uint16_sym = self.universe.scope.find_type_symbol_by_index_or_panic(8);
        self.uint32_sym = self.universe.scope.find_type_symbol_by_index_or_panic(9);
        self.uint64_sym = self.universe.scope.find_type_symbol_by_index_or_panic(10);
        self.uint_sym = self.universe.scope.find_type_symbol_by_index_or_panic(11);
        self.comptime_int_sym = self.universe.scope.find_type_symbol_by_index_or_panic(12);
        self.comptime_float_sym = self.universe.scope.find_type_symbol_by_index_or_panic(13);
        self.float32_sym = self.universe.scope.find_type_symbol_by_index_or_panic(14);
        self.float64_sym = self.universe.scope.find_type_symbol_by_index_or_panic(15);
        self.string_sym = self.universe.scope.find_type_symbol_by_index_or_panic(16);

        self.bool_t = .Basic(self.bool_sym);
        self.rune_t = .Basic(self.rune_sym);
        self.int8_t = .Basic(self.int8_sym);
        self.int16_t = .Basic(self.int16_sym);
        self.int32_t = .Basic(self.int32_sym);
        self.int64_t = .Basic(self.int64_sym);
        self.int_t = .Basic(self.int_sym);
        self.uint8_t = .Basic(self.uint8_sym);
        self.uint16_t = .Basic(self.uint16_sym);
        self.uint32_t = .Basic(self.uint32_sym);
        self.uint64_t = .Basic(self.uint64_sym);
        self.uint_t = .Basic(self.uint_sym);
        self.comptime_int_t = .Basic(self.comptime_int_sym);
        self.comptime_float_t = .Basic(self.comptime_float_sym);
        self.float32_t = .Basic(self.float32_sym);
        self.float64_t = .Basic(self.float64_sym);
        self.string_t = .Basic(self.string_sym);
    }

    func setup_builtins(mut self) {
        self.builtins = +[
            // variables
            .Const("_FILE_", self.string_t),
            .Const("_LINE_", self.uint_t),
            .Const("_COLUMN_", self.uint_t),
            .Const("_FUNCTION_", self.string_t),
            .Const("_RIVET_VERSION_", self.string_t),
            .Const("_RIVET_COMMIT_", self.string_t),

            // functions
            .Func("size_of", +[BuiltinArg("value", is_any: true)], self.uint_t),
            .Func("align_of", +[BuiltinArg("value", is_any: true)], self.uint_t),

            .Func("ptr_add", +[
                BuiltinArg("pointer", is_any: true),
                BuiltinArg("value", is_any: true)
            ], is_unsafe: true, checks: +[
                .ArgumentTypeShouldBe(0, .Pointer),
                .ArgumentTypeShouldBe(1, .Integer),
                .ReturnTypeEqualToArgumentType(0)
            ]),
            .Func("ptr_diff", +[
                BuiltinArg("pointer", is_any: true),
                BuiltinArg("pointer2", is_any: true)
            ], self.uint_t, is_unsafe: true, checks: +[
                .ArgumentTypeShouldBe(0, .Pointer),
                .ArgumentTypeEqualToArgumentType(1, 0)
            ]),

            .Func("as", +[
                BuiltinArg("type", is_any: true),
                BuiltinArg("value", is_any: true)
            ], checks: +[
                .ReturnTypeEqualToArgumentType(0)
            ]),

            .Func("unreachable", +[], .Never(token.noPos)),
            .Func("breakpoint", +[]),
            .Func("assert", +[
                BuiltinArg("cond", type: self.bool_t),
                BuiltinArg("msg", type: self.string_t, is_optional: true)
            ]),

            .Func("set_enum_ref_value", +[
                BuiltinArg("enum_value", is_any: true, is_mut: true),
                BuiltinArg("new_value", is_any: true)
            ], is_unsafe: true, checks: +[
                .ArgumentTypeShouldBe(0, .Enum),
                .ArgumentTypeEqualToArgumentType(1, 0)
            ]),

            // TODO: rename to `ignore_warn`: `@ignore_warn("not_mutated", expr)`.
            .Func("ignore_not_mutated_warn", +[
                BuiltinArg("expr", is_any: true, is_mut: true)
            ])
        ];
    }

    pub func find_builtin(self, name: string) -> ?Builtin {
        for builtin in self.builtins {
            is_equal := match builtin {
                .Const(b_var) -> b_var.name == name,
                .Func(b_func) -> b_func.name == name,
                else -> false
            };
            if is_equal {
                return builtin;
            }
        }
        return none;
    }

    pub func exist_builtin(self, name: string) -> bool {
        return self.find_builtin(name) != none;
    }

    #[inline]
    pub func is_number(self, type: Type) -> bool {
        return self.is_int(type) || self.is_float(type);
    }

    #[inline]
    pub func is_int(self, type: Type) -> bool {
        return self.is_signed_int(type) || self.is_unsigned_int(type);
    }

    #[inline]
    pub func is_signed_int(self, type: Type) -> bool {
        return type in [
            self.int8_t, self.int16_t, self.int32_t, self.int64_t, self.int_t,
            self.comptime_int_t
        ];
    }

    #[inline]
    pub func is_unsigned_int(self, type: Type) -> bool {
        return type in [
            self.uint8_t, self.uint16_t, self.uint32_t, self.uint64_t, self.uint_t
        ];
    }

    #[inline]
    pub func is_float(self, type: Type) -> bool {
        return type in [self.float32_t, self.float64_t, self.comptime_float_t];
    }

    #[inline]
    pub func is_comptime_number(self, type: Type) -> bool {
        return type == self.comptime_int_t || type == self.comptime_float_t;
    }

    pub func comptime_number_to_type(self, type: Type) -> Type {
        return if type == self.comptime_int_t {
            self.int_t
        } else if type == self.comptime_float_t {
            self.float64_t
        } else {
            type
        };
    }

    pub func number_bits(self, type: Type) -> uint {
        return if self.is_int(type) {
            self.int_bits(type)
        } else if self.is_float(type) {
            self.float_bits(type)
        } else {
            0
        };
    }

    pub func int_bits(self, type: Type) -> uint {
        type_sym := type.symbol()?;
        return if type_sym.info is .SizedInt(int_info) {
            int_info.size
        } else if type_sym.info is .SizedUint(uint_info) {
            uint_info.size
        } else if type_sym.info is .Int || type_sym.info is .Uint {
            if self.prefs.target_is_64bit { 64 } else { 32 }
        } else {
            75
        };
    }

    pub func float_bits(self, type: Type) -> uint {
        _ = self;
        type_sym := type.symbol()?;
        return if type_sym.info is .Float(float_info) {
            float_info.size
        } else {
            75
        };
    }

    /// Returns the size and alignment (in bytes) of `typ`, similarly to
    /// C's `sizeof(T)` and `_Alignof(T)`.
    pub func type_size(mut self, type: Type, is_raw: bool := false) -> (uint, uint) {
        return match type {
            .Result, .Option -> self.type_symbol_size(self.throwable_sym, is_raw),
            .Rawptr, .Pointer, .Func -> (self.pointer_size, self.pointer_size),
            else -> if mut type_sym := type.symbol() {
                self.type_symbol_size(type_sym, is_raw)
            } else {
                (0, 0)
            }
        };
    }

    pub func type_symbol_size(mut self, mut type_sym: TypeSym, is_raw: bool := false) -> (uint, uint) {
        return if type_sym.size != 0 {
            (type_sym.size, type_sym.align)
        } else {
            (mut size: uint, mut align: uint) := (0, 0);
            (size, align) = if type_sym.is_boxed() && !is_raw {
                (self.pointer_size, self.pointer_size)
            } else {
                match type_sym.info {
                    .Func -> (self.pointer_size, self.pointer_size),
                    .Alias(alias_info) -> self.type_size(alias_info.parent),
                    .Bool -> (1, 1),
                    .Uint, .Int -> (self.pointer_size, self.pointer_size),
                    .SizedInt(int) -> match int.size {
                        8 -> (1, 1),
                        16 -> (2, 2),
                        32 -> (4, 4),
                        64 -> (8, 8),
                        else -> (0, 0)
                    },
                    .SizedUint(uint) -> match uint.size {
                        8 -> (1, 1),
                        16 -> (2, 2),
                        32 -> (4, 4),
                        64 -> (8, 8),
                        else -> (0, 0)
                    },
                    .Float(float) -> match float.size {
                        32 -> (4, 4),
                        64 -> (8, 8),
                        else -> (0, 0)
                    },
                    .Rune -> (4, 4),
                    .ComptimeFloat, .ComptimeInt -> (8, 8),
                    .Enum(enum_info) -> if enum_info.is_tagged {
                        if enum_info.is_boxed {
                            ((type_sym.fields.len + 2) * self.pointer_size, self.pointer_size)
                        } else {
                            mut total_size := self.pointer_size;
                            mut max_alignment := self.pointer_size;
                            for variant in enum_info.variants {
                                if variant.has_type {
                                    (variant_size, alignment) := self.type_size(variant.type);
                                    if alignment > max_alignment {
                                        max_alignment = alignment;
                                    }
                                    total_size = utils.round_up(total_size, alignment) + variant_size;
                                }
                            }
                            (utils.round_up(total_size, max_alignment), max_alignment)
                        }
                    } else {
                        self.type_size(enum_info.underlying_type)
                    },
                    .DynArray -> self.type_symbol_size(self.dyn_array_sym, is_raw),
                    .Array(array_info) -> {
                        (elem_size, elem_align) := self.type_size(array_info.elem_type);
                        (array_info.size * elem_size, elem_align)
                    },
                    .Struct, .Tuple -> {
                        mut total_size: uint := 0;
                        mut max_alignment: uint := 0;
                        types := if type_sym.info is .Tuple(tuple_lit) {
                            tuple_lit.types
                        } else {
                            mut tmp := []Type();
                            for field in type_sym.full_fields() {
                                tmp.push(field.type);
                            }
                            tmp
                        };
                        for ftype in types {
                            (field_size, alignment) := self.type_size(ftype);
                            if alignment > max_alignment {
                                max_alignment = alignment;
                            }
                            total_size = utils.round_up(total_size, alignment) + field_size;
                        }
                        (utils.round_up(total_size, max_alignment), max_alignment)
                    },
                    .Trait(mut trait_info) -> {
                        (size, align) = ((type_sym.fields.len + 2) * self.pointer_size, self.pointer_size);
                        for mut btype in trait_info.bases {
                            (bsize, _balign) := self.type_symbol_size(btype, is_raw);
                            size += bsize - 2 * self.pointer_size;
                        }
                        (size, align)
                    },
                    else -> process.panic(
                        "Table.type_size: unsupported type `{}`", type_sym.qualname()
                    )
                }
            };
            type_sym.size = size;
            type_sym.align = align;
            (size, align)
        };
    }

    pub func filter_files(self, inputs: []string) -> []string {
        mut new_inputs := []string(cap: inputs.len);
        for input in inputs {
            base_name_input := Path.base_name(input);
            if base_name_input.count(".") == 1 {
                new_inputs.push(input);
                continue;
            }
            exts := base_name_input.substr(end: base_name_input.len - 3).split(".")[1..];
            mut already_exts := []string(cap: exts.len);
            mut should_compile := false;
            for ext in exts {
                if ext in already_exts {
                    utils.error("{}: duplicate special extension `{}`", input, ext);
                }
                already_exts.push(ext);
                if ext.starts_with("d_") || ext.starts_with("notd_") {
                    should_compile = if ext.starts_with("d_") {
                        ext.substr(2) in self.prefs.flags
                    } else {
                        ext.substr(4) !in self.prefs.flags
                    };
                } else if os := sys.OS.from_string(ext) {
                    should_compile = self.prefs.target_os == os;
                } else if arch := sys.Arch.from_string(ext) {
                    should_compile = self.prefs.target_arch == arch;
                } else if ext in ["x32", "x64"] {
                    should_compile = if ext == "x32" {
                        !self.prefs.target_is_64bit
                    } else {
                        self.prefs.target_is_64bit
                    };
                } else if ext in ["little_endian", "big_endian"] {
                    should_compile = if ext == "little_endian" {
                        self.prefs.target_is_little_endian
                    } else {
                        !self.prefs.target_is_little_endian
                    };
                } else if backend := prefs.Backend.from_string(ext) {
                    should_compile = backend == self.prefs.target_backend;
                } else {
                    utils.error("{}: unknown special extension `{}`", input, ext);
                }
                if !should_compile {
                    break;
                }
            }
            if should_compile {
                new_inputs.push(input);
            }
        }
        return new_inputs;
    }

    pub func evalue_pp_symbol(self, name: string, pos: token.Pos) -> bool {
        match name {
            // operating systems
            "_LINUX_", "_WINDOWS_" -> {
                return if os := sys.OS.from_string(name) {
                    os == self.prefs.target_os
                } else {
                    false
                };
            },
            // architectures
            "_X86_", "_AMD64_" -> {
                return if os := sys.Arch.from_string(name) {
                    os == self.prefs.target_arch
                } else {
                    false
                };
            },
            // bits
            "_x32_", "_x64_" -> {
                return if name == "_x32_" {
                    !self.prefs.target_is_64bit
                } else {
                    self.prefs.target_is_64bit
                };
            },
            // endian
            "_LITTLE_ENDIAN_", "_BIG_ENDIAN_" -> {
                return if name == "_LITTLE_ENDIAN_" {
                    self.prefs.target_is_little_endian
                } else {
                    !self.prefs.target_is_little_endian
                };
            },
            // optimize modes
            "_DEBUG_", "_RELEASE_" -> {
                return if name == "_DEBUG_" {
                    self.prefs.optimize_mode == .Debug
                } else {
                    self.prefs.optimize_mode == .Release
                };
            },
            "_TESTS_" -> return self.prefs.is_test,
            else -> return if name.starts_with("_") && name.ends_with("_") {
                report.error("unknown builtin flag: `{}`".fmt(name), pos);
                false
            } else {
                name in self.prefs.flags
            }
        }
    }
}

pub func universe() -> Module {
    return Module(
        name: "universe",
        scope: Scope(syms: +[
            TypeSym(name: "bool", info: .Bool),
            TypeSym(name: "rune", info: .Rune),
            TypeSym(name: "int8", info: .SizedInt(8)),
            TypeSym(name: "int16", info: .SizedInt(16)),
            TypeSym(name: "int32", info: .SizedInt(32)),
            TypeSym(name: "int64", info: .SizedInt(64)),
            TypeSym(name: "int", info: .Int),
            TypeSym(name: "uint8", info: .SizedUint(8)),
            TypeSym(name: "uint16", info: .SizedUint(16)),
            TypeSym(name: "uint32", info: .SizedUint(32)),
            TypeSym(name: "uint64", info: .SizedUint(64)),
            TypeSym(name: "uint", info: .Uint),
            TypeSym(name: "comptime_int", info: .ComptimeInt),
            TypeSym(name: "comptime_float", info: .ComptimeFloat),
            TypeSym(name: "float32", info: .Float(32)),
            TypeSym(name: "float64", info: .Float(64)),
            TypeSym(name: "string", info: .Struct(is_boxed: true))
        ])
    );
}

pub enum Builtin {
    Invalid,
    Const {
        name: string;
        type: Type;
    },
    Func {
        name: string;
        args: []BuiltinArg;
        type: Type;
        is_unsafe: bool;
        checks: []BuiltinFuncCheck;

        func args_len(self) -> uint {
            mut l: uint := 0;
            for arg in self.args {
                if arg.is_optional {
                    break;
                }
                l += 1;
            }
            return l;
        }
    };

    pub func type(self) -> Type {
        return match self {
            .Const(b_const) -> b_const.type,
            .Func(b_func) -> b_func.type,
            else -> .Void
        };
    }
}

struct BuiltinArg {
    pub name: string;
    pub is_mut: bool;
    pub is_any: bool; // any type
    pub type: Type;
    pub is_optional: bool;
}

enum BuiltinFuncType {
    Pointer,
    Enum,
    Integer
}

enum BuiltinFuncCheck {
    ReturnTypeEqualToArgumentType(uint),
    ArgumentTypeEqualToArgumentType {
        arg1_idx: uint;
        arg2_idx: uint;
    },
    ArgumentTypeShouldBe {
        arg_idx: uint;
        type: BuiltinFuncType;
    }
}
