// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/traits;
import std/strings.Builder;

import ../token;

#[boxed; default_value(.Void)]
pub enum Type < traits.Stringable {
    Basic {
        mut sym: ?TypeSym;
        mut is_unresolved: bool;
        mut expr: Expr;
        pos: token.Pos;
    },
    Never(token.Pos),
    Void,
    None,
    Option {
        mut inner: Type;
        pos: token.Pos;
    },
    Result {
        mut inner: Type;
        pos: token.Pos;
    },
    Tuple {
        mut inners: []mut Type;
        mut sym: TypeSym;
        pos: token.Pos;

        func ==(&self, other: &Self) -> bool {
            if self.inners.len != other.inners.len {
                return false;
            }
            for i, inner in self.inners {
                if inner != other.inners[i] {
                    return false;
                }
            }
            return true;
        }
    },
    Variadic {
        mut inner: Type;
        is_mut: bool;
        mut sym: TypeSym;
        pos: token.Pos;
    },
    DynArray {
        mut inner: Type;
        is_mut: bool;
        mut sym: TypeSym;
        pos: token.Pos;
    },
    Array {
        mut inner: Type;
        is_mut: bool;
        mut size: Expr;
        mut size_value: uint;
        mut sym: TypeSym;
        pos: token.Pos;
    },
    Pointer {
        mut inner: Type;
        is_mut: bool;
        is_indexable: bool;
        pos: token.Pos;
    },
    Rawptr {
        pos: token.Pos;
    },
    Func {
        is_method: bool;
        self_is_mut: bool;
        self_is_ptr: bool;
        mut args: []mut Arg;
        mut ret_type: Type;
        pos: token.Pos;
        mut sym: TypeSym;
        mut has_sym: bool;

        #[inline]
        func symbol(&self) -> Func {
            return if self.has_sym && self.sym.info is .Func(func_sym) {
                func_sym
            } else {
                Func(
                    is_method: self.is_method,
                    self_type: .Void,
                    self_is_mut: self.self_is_mut,
                    self_is_ptr: self.self_is_ptr,
                    args: self.args,
                    ret_type: self.ret_type
                )
            };
        }
    };

    #[inline]
    pub func ptr_or_ref_inner(self) -> Self {
        return match self {
            .Pointer(ptr) -> ptr.inner,
            .Rawptr -> self,
            else -> .Void
        };
    }

    pub func unalias(mut self) -> ?Self {
        // NOTE: `.unalias()` returns an option, so we use the same type without
        // unaliasing instead.
        return match self {
            .Rawptr -> self,
            .Result(mut result) -> .Result(result.inner.unalias() ?? result.inner),
            .Option(mut option) -> .Option(option.inner.unalias() ?? option.inner),
            .Tuple(mut tuple_data) -> {
                mut unaliased_types := []mut Type(cap: tuple_data.inners.len);
                for i, mut tuple_type in tuple_data.inners {
                    unaliased_types[i] = tuple_type.unalias() ?? tuple_type;
                }
                .Tuple(unaliased_types, tuple_data.sym)
            },
            .DynArray(mut dyn_array_data) -> .DynArray(
                dyn_array_data.inner.unalias() ?? dyn_array_data.inner, dyn_array_data.is_mut
            ),
            .Array(mut array_data) -> .Array(
                array_data.inner.unalias() ?? array_data.inner, ...self
            ),
            .Pointer(mut pointer_data) -> .Pointer(
                pointer_data.inner.unalias() ?? pointer_data.inner, ...self
            ),
            .Func(mut func_data) -> {
                for mut arg in func_data.args {
                    arg.type = arg.type.unalias() ?? arg.type;
                }
                .Func(
                    ret_type: func_data.ret_type.unalias() ?? func_data.ret_type,
                    ...self
                )
            },
            .Basic(mut basic) if !basic.is_unresolved -> if basic.sym?.info is .Alias(mut alias_info) {
                alias_info.parent.unalias() ?? alias_info.parent
            } else {
                .Basic(basic.sym)
            },
            else -> none // for `.Void`, `.None` or `.Never`
        };
    }

    pub func unalias_in_place(mut self) {
        if unaliased_type := self.unalias() {
            unsafe {
                @set_enum_ref_value(self, unaliased_type);
            }
        }
    }

    #[inline]
    pub func symbol(self) -> ?TypeSym {
        // NOTE: `.Void`, `.None`, `.Never` and `.Rawptr` has no `TypeSym` value.
        return match self {
            .Result(result) -> result.inner.symbol(),
            .Option(option) -> option.inner.symbol(),
            .Tuple(tuple_data) -> tuple_data.sym,
            .Variadic(variadic_data) -> variadic_data.sym,
            .DynArray(dyn_array_data) -> dyn_array_data.sym,
            .Array(array_data) -> array_data.sym,
            .Pointer(pointer_data) -> pointer_data.inner.symbol(),
            .Func(func_data) -> func_data.sym,
            .Basic(basic) if !basic.is_unresolved -> basic.sym,
            else -> none
        };
    }

    #[inline]
    pub func is_primitive(self) -> bool {
        return if type_sym := self.symbol() {
            type_sym.is_primitive()
        } else {
            false
        };
    }

    #[inline]
    pub func is_boxed(self) -> bool {
        return if type_sym := self.symbol() {
            type_sym.is_boxed()
        } else {
            false
        };
    }

    #[inline]
    pub func is_void(self) -> bool {
        return match self {
            .Void, .Never -> true,
            .Result(result) -> result.inner.is_void(),
            else -> false
        };
    }

    #[inline]
    pub func is_pointer(self) -> bool {
        return self is .Pointer || self is .Rawptr;
    }

    #[inline]
    pub func is_mut_pointer(self) -> bool {
        return match self {
            .Pointer(ptr) -> ptr.is_mut,
            .Rawptr -> true,
            else -> false
        };
    }

    #[inline]
    pub func is_any_kind_of_pointer(self) -> bool {
        return match self {
            .Pointer, .Rawptr, .Func -> true,
            else -> if type_sym := self.symbol() {
                type_sym.is_boxed()
            } else {
                false
            }
        };
    }

    #[inline]
    pub func position(self) -> token.Pos {
        return match self {
            .Void, .None -> token.noPos,
            .Never(never_pos) -> never_pos,
            .Option(opt_t) -> opt_t.pos,
            .Result(res_t) -> res_t.pos,
            .Tuple(tuple_t) -> tuple_t.pos,
            .Variadic(variadic_t) -> variadic_t.pos,
            .DynArray(dyn_array_t) -> dyn_array_t.pos,
            .Array(arr_t) -> arr_t.pos,
            .Pointer(ptr_t) -> ptr_t.pos,
            .Rawptr(rawptr_t) -> rawptr_t.pos,
            .Func(func_t) -> func_t.pos,
            .Basic(basic_t) -> if basic_t.is_unresolved {
                basic_t.expr.position()
            } else {
                basic_t.pos
            }
        };
    }

    #[inline]
    pub func ==(self, rhs: Self) -> bool {
        return match self {
            .None if rhs is .None -> true,
            .Void if rhs is .Void -> true,
            .Never if rhs is .Never -> true,
            .Result(result_lhs) if rhs is .Result(result_rhs) ->
                result_lhs.inner == result_rhs.inner,
            .Option(option_lhs) if rhs is .Option(option_rhs) ->
                option_lhs.inner == option_rhs.inner,
            .Tuple(tuple_lhs) if rhs is .Tuple(tuple_rhs) -> tuple_lhs == tuple_rhs,
            .Variadic(variadic_lhs) if rhs is .Variadic(variadic_rhs) ->
                variadic_lhs.inner == variadic_rhs.inner,
            .DynArray(dyn_array_lhs) if rhs is .DynArray(dyn_array_rhs) ->
                dyn_array_lhs.inner == dyn_array_rhs.inner && dyn_array_lhs.is_mut == dyn_array_rhs.is_mut,
            .Array(array_lhs) if rhs is .Array(array_rhs) ->
                array_lhs.inner == array_rhs.inner && array_lhs.size_value == array_rhs.size_value
                && array_lhs.is_mut == array_rhs.is_mut,
            .Pointer(ptr_lhs) if rhs is .Pointer(ptr_rhs) -> if ptr_lhs.is_mut
                && !ptr_rhs.is_mut {
                false
            } else if ptr_lhs.is_indexable && !ptr_rhs.is_indexable {
                false
            } else {
                ptr_lhs.inner == ptr_rhs.inner
            },
            .Rawptr if rhs is .Rawptr -> true,
            .Func(func_lhs) if rhs is .Func(func_rhs) -> match {
                func_lhs.is_method != func_rhs.is_method,
                func_lhs.self_is_mut != func_rhs.self_is_mut,
                func_lhs.self_is_ptr != func_rhs.self_is_ptr,
                func_lhs.args.len != func_rhs.args.len -> false,
                else -> {
                    mut final_res := func_lhs.ret_type == func_rhs.ret_type;
                    for i, arg_lhs in func_lhs.args {
                        arg_rhs := func_rhs.args[i];
                        if arg_lhs.is_mut != arg_rhs.is_mut {
                            final_res = false;
                            break;
                        }
                        if arg_lhs.type != arg_rhs.type {
                            final_res = false;
                            break;
                        }
                    }
                    final_res
                }
            },
            .Basic(basic_lhs) if rhs is .Basic(basic_rhs) ->
                !(basic_lhs.is_unresolved && basic_rhs.is_unresolved)
                && basic_lhs.sym? == basic_rhs.sym?,
            else -> false
        };
    }

    pub func !=(self, rhs: Self) -> bool {
    	return !(self == rhs);
    }

    pub func to_string(self) -> string {
        return self.to_string_(false);
    }

    pub func to_qualstring(self) -> string {
        return self.to_string_(true);
    }

    pub func to_string_(self, qualstr: bool) -> string {
        return match self {
            .None -> "<none>",
        	.Void -> "<void>",
            .Never -> "never",
            .Result(result) -> "!".concat(result.inner.to_string_(qualstr)),
            .Option(option) -> "?".concat(option.inner.to_string_(qualstr)),
            .Tuple(tuple_data) -> {
                mut sb := Builder.new(100);
                sb.write_byte(b'(');
                for i, inner in tuple_data.inners {
                    sb.write_string(inner.to_string_(qualstr));
                    if i < tuple_data.inners.len - 1 {
                        sb.write_string(", ");
                    }
                }
                sb.write_byte(b')');
                sb.to_string()
            },
            .Variadic(variadic_data) -> "...".concat(variadic_data.inner.to_string_(qualstr)),
            .DynArray(dyn_array_data) -> if dyn_array_data.is_mut {
                "[]mut"
            } else {
                "[]"
            }.concat(dyn_array_data.inner.to_string_(qualstr)),
            .Array(array_data) -> "[".concat(
                array_data.size.to_string(), "]", if array_data.is_mut {
                    "mut "
                } else {
                    ""
                }, array_data.inner.to_string_(qualstr)
            ),
            .Pointer(pointer_data) -> {
                if pointer_data.is_mut {
                    if pointer_data.is_indexable {
                        "[&]mut "
                    } else {
                        "&mut "
                    }
                } else {
                    if pointer_data.is_indexable {
                        "[&]"
                    } else {
                        "&"
                    }
                }.concat(pointer_data.inner.to_string_(qualstr))
            },
            .Rawptr -> "rawptr",
            .Func(func_data) -> {
                mut sb := Builder.new(150);
                sb.write_string("func(");
                if func_data.is_method {
                    if func_data.self_is_mut {
                        sb.write_string("mut ");
                    } else if func_data.self_is_ptr {
                        sb.write_string("&");
                    }
                    sb.write_string("self");
                    if func_data.args.len > 0 {
                        sb.write_string(", ");
                    }
                }
                for i, arg in func_data.args {
                    sb.write_string(arg.type.to_string_(qualstr));
                    if i < func_data.args.len - 1 {
                        sb.write_string(", ");
                    }
                }
                sb.write_string(")");
                if func_data.ret_type !is .Void {
                    sb.write_string(" -> ");
                    sb.write_string(func_data.ret_type.to_string_(qualstr));
                }
                sb.to_string()
            },
            .Basic(basic) -> if type_sym := basic.sym {
                if qualstr {
                    type_sym.qualname()
                } else {
                    type_sym.name
                }
            } else {
                basic.expr.to_string()
            }
        };
    }
}
