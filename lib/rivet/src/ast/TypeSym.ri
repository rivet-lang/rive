// Copyright (C) 2023-present Jose Mendoza - All rights reserved. Use of this
// source code is governed by an MIT license that can be found in the LICENSE
// file.

pub struct Field {
    pub is_public: bool;
    pub name: string;
    pub is_mut: bool;
    pub has_def_expr: bool;
    pub def_expr: Expr;
    pub type: Type;
    pub is_required: bool;
}

#[boxed]
pub struct TypeSym < Sym {
    pub mut fields: []Field;
    pub mut full_fields_: []Field;
    pub mut info: TypeInfo := .Invalid;
    pub mut size: uint;
    pub mut align: uint;
    pub mut default_value: ?Expr;

    pub proc lookup_field(self, name: string) -> ?Field {
        for f in self.fields {
            if f.name == name {
                return f;
            }
        }
        if self.info is .Trait(trait_info) {
            for b in trait_info.bases {
                if f := b.lookup_field(name) {
                    return f;
                }
            }
        } else if self.info is .Struct(struct_info) {
            for t in struct_info.traits {
                if f := t.lookup_field(name) {
                    return f;
                }
            }
            for b in struct_info.bases {
                if f := b.lookup_field(name) {
                    return f;
                }
            }
        }
        return none;
    }

    #[inline]
    pub proc has_field(self, name: string) -> bool {
        return self.lookup_field(name) != none;
    }

    #[inline]
    pub proc lookup(self, name: string) -> ?Sym {
        return if s := self.scope.lookup(name) {
            s
        } else {
            none
        };
    }

    pub proc find_in_base(self, name: string) -> ?Sym {
         if self.info is .Trait(trait_info) {
            for b in trait_info.bases {
                if s := b.scope.find(name) {
                    return s;
                }
            }
        } else if self.info is .Struct(struct_info) {
            for t in struct_info.traits {
                if s := t.scope.find(name) {
                    return s;
                }
            }
            for b in struct_info.bases {
                if s := b.scope.find(name) {
                    return s;
                }
            }
        } else if self.info is .Enum(enum_info) {
            for t in enum_info.traits {
                if s := t.scope.find(name) {
                    return s;
                }
            }
        }
        return none;
    }

    #[inline]
    pub proc find_proc(self, name: string) -> ?Proc {
        return if sym := self.scope.find(name); sym is Proc(proc_) {
            if self.info !is .Trait && !proc_.has_body {
                return none;
            }
            proc_
        } else if sym := self.find_in_base(name); sym is Proc(proc_) {
            if self.info !is .Trait && !proc_.has_body {
                return none;
            }
            proc_
        } else {
            none
        };
    }

    #[inline]
    pub proc find_method(self, name: string) -> ?Proc {
        return if proc_ := self.find_proc(name); proc_.is_method {
            proc_
        } else {
            none
        };
    }

    #[inline]
    pub proc has_proc(self, name: string) -> bool {
        return self.find_proc(name) != none;
    }

    #[inline]
    pub proc has_method(self, name: string) -> bool {
        return self.find_method(name) != none;
    }

    pub proc full_fields(mut self) -> []Field {
        if !self.full_fields_.is_empty() {
            return self.full_fields_;
        }
        mut fields := []Field();
        if self.info is .Trait(mut trait_info) {
            for mut b in trait_info.bases {
                for bf in b.full_fields() {
                    fields.push(bf);
                }
            }
        } else if self.info is .Struct(mut struct_info) {
            for mut t in struct_info.traits {
                for tf in t.full_fields() {
                    fields.push(tf);
                }
            }
            for mut b in struct_info.bases {
                for bf in b.full_fields() {
                    fields.push(bf);
                }
            }
        }
        for f in self.fields {
            fields.push(f);
        }
        self.full_fields_ = fields;
        return fields;
    }

    #[inline]
    pub proc implement_trait(self, trait_sym: TypeSym) -> bool {
        return if trait_sym.info is .Trait(trait_info) {
            self in trait_info.implements
        } else {
            false
        };
    }

    pub proc update(mut self, other: TypeSym) -> !bool {
        if self.info is .Placeholder {
            // update placeholder
            if other.info !is .Placeholder {
                self.is_public = other.is_public;
                self.info = other.info;
            }
            self.fields = other.fields;
            for s in other.scope.syms {
                self.scope.add(s)!;
            }
            return true;
        }
        return false;
    }

    #[inline]
    pub proc is_boxed(self) -> bool {
        return match self.info {
            .String, .DynArray, .Trait -> true,
            .Struct(struct_info) -> struct_info.is_boxed,
            .Enum(enum_info) -> enum_info.is_boxed,
            else -> false
        };
    }

    #[inline]
    pub proc is_primitive(self) -> bool {
        return self.info.is_primitive();
    }

    #[inline]
    pub proc ==(self, rhs: Self) -> bool {
        return self.id == rhs.id;
    }

    #[inline]
    pub proc !=(self, rhs: Self) -> bool {
        return self.id != rhs.id;
    }
}
