// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../token;
import ../utils;
import ../report;

const SWITCH_EXHAUSTIVE_CUTOFF_LIMIT = 12;

extend Checker {
    func check_expr(mut self, mut expr: ast.Expr) ast.Type {
        return switch expr is {
            .Empty, .Type => .Void(),
            .Branch as branch => .Never(branch.pos),
            .Paren as paren => self.check_expr(paren.expr),
            .NoneLiteral as none_lit => self.table.none_t,
            .BoolLiteral as bool_lit => self.table.bool_t,
            .CharLiteral as char_lit => {
                char_lit.type = if char_lit.is_byte {
                    self.table.uint8_t
                } else {
                    self.table.rune_t
                };
                char_lit.type
            },
            .IntegerLiteral as int_lit => {
                int_lit.type = self.table.comptime_int_t;
                int_lit.type
            },
            .FloatLiteral as float_lit => {
                float_lit.type = self.table.comptime_float_t;
                float_lit.type
            },
            .StringLiteral as string_lit => {
                string_lit.type = if string_lit.is_bytestr {
                    .Basic(self.table.universe.add_or_get_array(
                        self.table.uint8_t, string_lit.value.len, false
                    ))
                } else if string_lit.is_cstr {
                    .Pointer(self.table.uint8_t, is_indexable: true)
                } else {
                    self.table.string_t
                };
                string_lit.type
            },
            .SelfLiteral as self_lit => {
                self_lit.type = .Basic(self_lit.sym);
                self_lit.type
            },
            .SelfTy as self_ty => .Void(),
            .EnumLiteral as enum_lit => {
                enum_lit.type = .Void();
                sym := self.expected_type.symbol()?;
                if sym.info is .Enum as enum_info {
                    if variant := enum_info.get_variant(enum_lit.value) {
                        enum_lit.variant = variant;
                        enum_lit.type = .Basic(sym, pos: enum_lit.pos);
                        if enum_info.is_boxed and !enum_lit.from_is_cmp and !enum_lit.is_instance {
                            mut err := report.error_builder(
                                "cannot use variant `.{}` as a simple value".fmt(enum_lit.value),
                                enum_lit.pos
                            );
                            err.add_note(
                                "make an instance instead: `.{}()`", enum_lit.value
                            );
                            err.emit();
                        }
                    } else {
                        report.error(
                            "enum `{}` has no variant `{}`".fmt(sym.name, enum_lit.value),
                            enum_lit.pos
                        );
                    }
                } else {
                    report.error("`{}` is not a enum".fmt(self.expected_type), enum_lit.pos);
                }
                enum_lit.type
            },
            .TupleLiteral as mut tuple_lit => self.check_tuple_literal(tuple_lit),
            .VectorLiteral as mut vec_lit => self.check_vector_literal(vec_lit),
            .Ident as ident => {
                ident.type = if ident.name == "_" {
                    .Void()
                } else if ident.is_comptime {
                    ident.builtin.type()
                } else if ident.is_sym or ident.is_obj {
                    switch ident.sym is {
                        ast.Func as func_sym => {
                            if func_sym.abi != .Rivet {
                                mut err := report.error_builder(
                                    "cannot use an extern function as a value", ident.pos
                                );
                                err.add_help("wrap the extern function with a function");
                                err.emit();
                            }
                            func_sym.type()
                        },
                        ast.Const as const_sym => const_sym.type,
                        ast.Var as var_sym => var_sym.type,
                        else => .Void()
                    }
                } else {
                    .Void()
                };
                ident.type
            },
            .Selector as mut selector => self.check_selector(selector),
            .Indirect as indirect => {
              	indirect.left_type = self.check_expr(indirect.left);
                indirect.type = if indirect.left_type.is_ptr_or_ref()
                    or (indirect.left_type is .Pointer as ptr and ptr.is_indexable)
                    or indirect.left_type is .Anyptr  {
                	indirect.is_mut = indirect.left_type.is_mut_ptr_or_ref();
                    indirect.left_type.ptr_or_ref_inner()
                } else {
                    mut err := report.error_builder(
                        "invalid indirect for `{}`".fmt(indirect.left_type), indirect.pos
                    );
                    if indirect.left_type is .Anyptr {
                        err.add_help(
                            "consider casting this to another pointer type, e.g. `*uint8`"
                        );
                    }
                    err.emit();
                    .Void()
                };
                indirect.type
            },
            .OptionCheck as option_check => {
            	option_check.left_type = self.check_expr(option_check.left);
                option_check.type = if option_check.left_type is .Option as opt {
                    opt.inner
                } else {
                    report.error("cannot check a non-option value", option_check.left.position());
                    .Void()
                };
                option_check.type
            },
            .Range as range => {
                range.type = if range.has_start {
                    self.check_expr(range.start)
                } else {
                    self.table.usize_t
                };
                end_type := if range.has_end {
                    self.check_expr(range.end)
                } else {
                    self.table.usize_t
                };
                if !(self.table.is_int(range.type) or self.table.is_int(end_type)) {
                    report.error("non-integer value used as range", range.pos);
                }
                range.type
            },
            .Index as mut index => self.check_index(index),
            .Call as mut call_expr => self.check_call(call_expr),
            .BuiltinCall as mut builtin_call => self.check_builtin_call(builtin_call),
            .Block as block => {
                if block.is_unsafe {
                    if self.inside_unsafe {
                        report.warn("unnecessary `unsafe` block", block.pos);
                    }
                    self.inside_unsafe = true;
                }
                old_expected_type := self.expected_type;
                self.expected_type = .Void();
                for mut stmt in block.stmts {
                    self.check_stmt(stmt);
                }
                self.expected_type = old_expected_type;
                block.type = if block.is_expr {
                    self.check_expr(block.expr)
                } else {
                    .Void()
                };
                if block.is_unsafe {
                    self.inside_unsafe = false;
                }
                block.type
            },
            .Unary as mut unary => self.check_unary(unary),
            .Return as mut return_expr => self.check_return(return_expr),
            .Guard as guard => {
                old_inside_guard_expr := self.inside_guard_expr;
                self.inside_guard_expr = true;
                self.check_var_decl(guard.vars, guard.expr, guard.scope, guard.pos);
                if guard.has_cond and self.check_expr(guard.cond) != self.table.bool_t {
                    report.error(
                        "non-boolean expression used as guard condition",
                        guard.cond.position()
                    );
                }
                self.inside_guard_expr = old_inside_guard_expr;
                .Void()
            },
            .If as mut if_expr => self.check_if(if_expr),
            .Switch as mut switch_expr => self.check_switch(switch_expr),
            else => .Void()
        };
    }

    func check_tuple_literal(mut self, mut tuple_lit: ast.Expr.TupleLiteral) ast.Type {
        old_expected_type := self.expected_type;
        expected_type_sym := self.expected_type.symbol()?;
        mut has_expected_types := false;
        mut expected_types := @vec(ast.Type);
        if expected_type_sym.info is .Tuple as tuple_info {
            has_expected_types = tuple_lit.values.len == tuple_info.types.len;
            expected_types = tuple_info.types;
        }
        mut types := @vec(ast.Type);
        for i, mut value in tuple_lit.values {
            if has_expected_types {
                self.expected_type = expected_types[i];
            }
            tt := self.table.comptime_number_to_type(self.check_expr(value));
            types.push(if has_expected_types {
                self.expected_type = old_expected_type;
                expected_types[i]
            } else {
                tt
            });
        }
        tuple_lit.type = .Basic(
            self.table.universe.add_or_get_tuple(types), pos: tuple_lit.pos
        );
        return tuple_lit.type;
    }

    func check_vector_literal(mut self, mut vec_lit: ast.Expr.VectorLiteral) ast.Type {
        old_expected_type := self.expected_type;
        mut size: usize := 0;
        mut is_mut := false;
        mut has_expected_type := false;
        mut value_type := ast.Type.Void();
        if self.expected_type !is .Func {
            value_sym := self.expected_type.symbol()?;
            if value_sym.info is .Array or value_sym.info is .Vector {
                has_expected_type = true;
                value_type = value_sym.info.elem_type()?;
                self.expected_type = value_type;
                if value_sym.info is .Array as array_info {
                    size = array_info.size;
                }
                is_mut = value_sym.info.is_mut_arr_or_vec();
            }
        }
        value_type = self.table.comptime_number_to_type(value_type);
        for i, mut value in vec_lit.values {
            type := self.check_expr(value);
            if i == 0 and !has_expected_type {
                value_type = type;
                self.expected_type = value_type;
            } else {
                self.check_types(type, value_type) catch |err| {
                    mut err_b := report.error_builder(err.to_string(), value.position());
                    err_b.add_note(if vec_lit.is_arr {
                        "in element {} of array literal"
                    } else {
                        "in element {} of vector literal"
                    }.fmt(i + 1));
                    err_b.emit();
                };
            }
        }
        self.expected_type = old_expected_type;
        vec_lit.type = if vec_lit.is_arr {
            arr_len := if vec_lit.values.len > 0 {
                vec_lit.values.len
            } else {
                if !has_expected_type {
                    report.error("could not infer type and size of array", vec_lit.pos);
                }
                size
            };
            .Basic(
                self.table.universe.add_or_get_array(value_type, size, is_mut),
                pos: vec_lit.pos
            )
        } else {
            .Basic(self.table.universe.add_or_get_vec(value_type, is_mut), pos: vec_lit.pos)
        };
        return vec_lit.type;
    }

    func check_selector(mut self, mut selector: ast.Expr.Selector) ast.Type {
        selector.type = if selector.is_path {
            if selector.left_sym is ast.TypeSym as type_sym {
                .Basic(type_sym, pos: selector.pos)
            } else {
                switch selector.sym is {
                    ast.Func as func_sym => {
                        if func_sym.is_method {
                            report.error(
                                "cannot take value of method `{}`".fmt(
                                    selector.field_name
                                ), selector.field_pos
                            );
                        }
                        func_sym.type()
                    },
                    ast.TypeSym as type_sym_ => .Basic(type_sym_, pos: selector.pos),
                    ast.Const as const_sym => const_sym.type,
                    ast.Var as var_sym => var_sym.type,
                    else => {
                        mut err := report.error_builder(
                            "unexpected bug for selector expression", selector.pos
                        );
                        err.add_note("please report this bug, thanks =D");
                        err.emit();
                        .Void()
                    }
                }
            }
        } else {
            selector.left_type = self.check_expr(selector.left);
            left_sym := selector.left_type.symbol()?;
            if field := left_sym.lookup_field(selector.field_name) {
                selector.found = true;
                selector.field_is_mut = field.is_mut;
                field.type
            } else if sym := left_sym.scope.find(selector.field_name) {
                if sym is ast.Func as func_sym {
                    if func_sym.is_method {
                        mut err := report.error_builder(
                            "cannot take value of method `{}`".fmt(selector.field_name),
                            selector.field_pos
                        );
                        err.add_help("use parentheses to call the method");
                        err.emit();
                        .Void()
                    } else {
                        mut err := report.error_builder(
                            "cannot take value of associated function `{}`".fmt(selector.field_name),
                            selector.field_pos
                        );
                        err.add_help("use `{}.{}` instead", left_sym.name, selector.field_name);
                        err.emit();
                        func_sym.type()
                    }
                } else {
                    report.error(
                        "cannot take value of {} `{}.{}`".fmt(
                            sym.type_of(), left_sym.name, selector.field_name
                        ), selector.pos
                    );
                    .Void()
                }
            } else {
                mut err := report.error_builder(
                    "type `{}` has no field `{}`".fmt(
                        left_sym.name, selector.field_name
                    ), selector.field_pos
                );
                if selector.field_name.is_digit()
                    and (left_sym.info is .Vector or left_sym.info is .Array ) {
                    err.add_note(
                        "instead of using tuple indexing, use array indexing: `{}[{}]`"
                            .fmt(selector.left, selector.field_name)
                    );
                }
                err.emit();
                .Void()
            }
        };
        return selector.type;
    }

    func check_index(mut self, mut index: ast.Expr.Index) ast.Type {
        index.left_type = self.check_expr(index.left);
        left_sym := index.left_type.symbol()?;
        index_t := self.check_expr(index.index);
        if index_t != self.table.comptime_int_t and !self.table.is_unsigned_int(index_t) {
            report.error(
                "expected unsigned integer value, found `{}`".fmt(index_t),
                index.index.position()
            );
        }
        switch left_sym.info is {
            .Array, .Vector => {
                elem_type := left_sym.info.elem_type()?;
                if index.index is .Range as range {
                    is_mut := left_sym.info.is_mut_arr_or_vec();
                    index.type = if left_sym.info is .Vector {
                        index.left_type
                    } else {
                        .Vector(
                            elem_type, is_mut,
                            self.table.universe.add_or_get_vec(elem_type, is_mut)
                        )
                    };
                } else {
                    index.type = elem_type;
                }
            },
            else => {
                if !(index.left_type is .Pointer or index.left_type == self.table.string_t) {
                    mut err := report.error_builder(
                        "type `{}` does not support indexing".fmt(index.left_type),
                        index.pos
                    );
                    err.add_note("only pointers, arrays, slices and string supports indexing");
                    err.emit();
                } else if index.left_type is .Pointer as pointer {
                    if !self.inside_unsafe {
                        report.error(
                            "pointer indexing is only allowed inside `unsafe` blocks",
                            index.pos
                        );
                    } else if index.index is .Range {
                        report.error("cannot slice a pointer", index.index.position());
                    } else if !pointer.is_indexable {
                        report.error("cannot index a non-indexable pointer", index.pos);
                    }
                }
                index.type = if index.left_type == self.table.string_t {
                    if index.index is .Range {
                        self.table.string_t
                    } else {
                        self.table.uint8_t
                    }
                } else {
                    .Void()
                };
            }
        }
        return index.type;
    }

    func check_call(mut self, mut call_expr: ast.Expr.Call) ast.Type {
        call_expr.type = .Void();

        mut left := call_expr.left;
        inside_parens := if left is .Paren as paren
            and paren.expr is .Selector as paren_selector and !paren_selector.is_path {
            left = paren.expr;
            true
        } else {
            false
        };

        switch left is {
            .SelfTy as self_ty => self.check_ctor_call(self_ty.sym, call_expr),
            .Ident as ident if (ident.is_sym or ident.is_obj) => switch ident.sym is {
                ast.TypeSym as mut type_sym if type_sym.info is .Trait
                    or type_sym.info is .Struct or type_sym.info is .String
                    or type_sym.info is .Enum => self.check_ctor_call(type_sym, call_expr),
                ast.Func as func_ => {
                    call_expr.func_ = func_;
                    if func_.is_main {
                        report.error("cannot call to `main` function", ident.pos);
                    } else {
                        self.check_func_call(func_, call_expr);
                    }
                },
                else => if ident.type is .Func as i_func {
                    call_expr.is_closure = true;
                    self.check_func_call(i_func.symbol(), call_expr);
                } else {
                    report.error(
                        "expected function or method to call, found {}".fmt(
                            ident.sym.type_of()
                        ), ident.pos
                    );
                }
            },
            .Selector as selector => if selector.is_path {
                switch selector.sym is {
                    ast.TypeSym as mut s_type_sym if s_type_sym.info is .Trait
                        or s_type_sym.info is .Struct or s_type_sym.info is .String
                        or s_type_sym.info is .Enum => self.check_ctor_call(
                        s_type_sym, call_expr
                    ),
                    ast.Func as s_func_ => {
                        call_expr.func_ = s_func_;
                        self.check_func_call(s_func_, call_expr);
                    },
                    else => if selector.type is .Func as s_func {
                        call_expr.is_closure = true;
                        self.check_func_call(s_func.symbol(), call_expr);
                    } else {
                        report.error(
                            "expected function or method to call, found {}".fmt(
                                selector.sym.type_of()
                            ), selector.pos
                        );
                    }
                }
            } else {
                // call methods
                selector.left_type = self.check_expr(selector.left);
                if selector.left_type is .Option {
                    mut err := report.error_builder(
                        "option value cannot be called directly",
                        selector.left.position()
                    );
                    err.add_help("use the option-check syntax: `foo?.method()`");
                    err.add_help("or use `??`: `(foo ?? 5).method()`");
                    err.emit();
                    return .Void();
                } else if selector.left_type is .Pointer {
                    mut err := report.error_builder(
                        "cannot use a pointer value as receiver", selector.left.position()
                    );
                    err.add_help("consider dereferencing this pointer");
                    err.emit();
                    return .Void();
                }
                left_sym := selector.left_type.symbol()?;
                if method := left_sym.scope.find(selector.field_name) {
                    if method is ast.Func as s_func {
                        if s_func.is_method {
                            self.check_func_call(s_func, call_expr);
                        } else {
                            report.error(
                                "`{}` is not a method".fmt(selector.field_name),
                                selector.field_pos
                            );
                        }
                    } else {
                        report.error(
                            "expected method, found {}".fmt(s_func.kind()),
                            selector.pos
                        );
                    }
                } else if field := left_sym.lookup_field(selector.field_name) {
                    if field.type is .Func as f_func {
                        if inside_parens {
                            call_expr.is_closure = true;
                            selector.field_type = field.type;
                            self.check_func_call(f_func.symbol(), call_expr);
                        } else {
                            mut err := report.error_builder(
                                "type `{}` has no method `{}`".fmt(
                                    left_sym.name, selector.field_name
                                ), selector.field_pos
                            );
                            err.add_help(
                                "to call the function stored in `{}`, "
                                "surround the field access with parentheses"
                                    .fmt(selector.field_name)
                            );
                            err.emit();
                        }
                    } else {
                        report.error(
                            "field `{}` of type `{}` is not function type".fmt(
                                selector.field_name, left_sym.name
                            ), selector.field_pos
                        );
                    }
                } else {
                    report.error(
                        "type `{}` has no method `{}`".fmt(
                            left_sym.name, selector.field_name
                        ), selector.field_pos
                    );
                }
            },
            .EnumLiteral as enum_lit => {
                enum_lit.is_instance = true;
                _ = self.check_expr(left);
                self.check_ctor_call(enum_lit.sym, call_expr);
            },
            else => report.error("invalid expression used in call expression", left.position())
        }

        // result checking
        if call_expr.has_err_handler() {
            if call_expr.type is .Result as result_t {
                if call_expr.err_handler.is_propagate {
                    if !(self.cur_fn.is_main or self.inside_test or self.inside_var_decl
                        or self.cur_fn.ret_type is .Result) {
                        mut err := report.error_builder(
                            "cannot propagate the result value", call_expr.err_handler.pos
                        );
                        err.add_note(
                            "to propagate the result, `{}` must return an result type",
                            self.cur_fn.name
                        );
                        err.emit();
                    }
                } else {
                    self.check_types(
                        self.check_expr(call_expr.err_handler.expr), result_t.inner
                    ) catch |err| {
                        report.error(err.to_string(), call_expr.err_handler.expr.position());
                    };
                }
                call_expr.type = result_t.inner;
            } else {
                report.error(
                    "{} `{}` does not returns a result value".fmt(
                        call_expr.func_.type_of(), call_expr.func_.name
                    ), call_expr.err_handler.pos
                );
            }
        } else if call_expr.type is .Result and !self.inside_guard_expr {
            mut err := report.error_builder(
                "{} `{}` returns a result".fmt(
                    call_expr.func_.type_of(), call_expr.func_.name
                ), call_expr.pos
            );
            err.add_note("should handle this with `catch` or propagate with `!`");
            err.emit();
        }

        return call_expr.type;
    }

    func check_builtin_call(mut self, mut builtin_call: ast.Expr.BuiltinCall) ast.Type {
        builtin_call.type = if builtin_call.builtin is .Func as b_func {
            if b_func.is_unsafe and !self.inside_unsafe {
                report.warn(
                    "builtin function `{}` should be called inside `unsafe` block".fmt(
                        b_func.name
                    ), builtin_call.pos
                );
            }
            b_func_args_len := b_func.args_len();
            if builtin_call.args.len != b_func_args_len {
                expr_msg := "expected {} argument(s), found {}".fmt(
                    b_func_args_len, builtin_call.args.len
                );
                if builtin_call.args.len < b_func_args_len {
                    mut err := report.error_builder(
                        "too few arguments to builtin function `{}`".fmt(builtin_call.name),
                        builtin_call.pos
                    );
                    err.add_note(expr_msg);
                    err.emit();
                } else {
                    mut err := report.error_builder(
                        "too many arguments to builtin function `{}`".fmt(builtin_call.name),
                        builtin_call.pos
                    );
                    err.add_note(expr_msg);
                    err.emit();
                }
            } else {
                for i, mut arg in builtin_call.args {
                    arg_info := b_func.args[i];
                    if arg_info.is_mut {
                        self.check_expr_is_mut(arg);
                    }
                    arg_t := self.check_expr(arg);
                    if !arg_info.is_any {
                        self.check_types(arg_t, arg_info.type) catch |err| {
                            mut err2 := report.error_builder(err.to_string(), arg.position());
                            err2.add_note(
                                "in argument `{}` of builtin function `{}`", arg_info.name,
                                b_func.name
                            );
                            err2.emit();
                        };
                    }
                }
            }
            b_func.type
        } else {
            .Void()
        };
        return builtin_call.type;
    }

    func check_unary(mut self, mut unary: ast.Expr.Unary) ast.Type {
        unary.type = self.check_expr(unary.right);
        switch unary.op {
            .Bang if unary.type != self.table.bool_t => report.error(
                "operator `!` can only be used with boolean values", unary.pos
            ),
            .BitNot if !self.table.is_int(unary.type) => report.error(
                "operator `~` can only be used with numeric values", unary.pos
            ),
            .Minus => if self.table.is_unsigned_int(unary.type) {
                mut err := report.error_builder(
                    "cannot apply unary operator `-` to type `{expr.typ}`".fmt(
                        unary.type
                    ), unary.pos
                );
                err.add_note("unsigned values cannot be negated");
                err.emit();
            } else if !(self.table.is_signed_int(unary.type)
                or self.table.is_float(unary.type)) {
                report.error(
                    "operator `-` can only be used with signed integer or float values",
                    unary.pos
                );
            },
            .Amp => {
                mut expected_pointer := false;
                mut indexable_pointer := false;
                if self.expected_type is .Pointer as ptr {
                    expected_pointer = true;
                    indexable_pointer = ptr.is_indexable;
                } else if self.expected_type is .Option as opt
                    and opt.inner is .Pointer as opt_ptr {
                    expected_pointer = true;
                    indexable_pointer = opt_ptr.is_indexable;
                }
                right := unary.right.clean_paren();
                if right is .Index as index {
                    if index.left_type is .Pointer and !expected_pointer {
                        report.error("cannot reference a pointer indexing", unary.pos);
                    }
                    index.is_ref = true;
                } else if unary.type is .Reference {
                    report.error("cannot take the address of other reference", unary.pos);
                } else if unary.is_ref_mut {
                    self.check_expr_is_mut(right);
                } else {
                    right_sym := unary.type.symbol()?;
                    if right_sym.is_boxed() {
                        report.error("cannot reference a boxed value", unary.pos);
                    }
                }
                unary.type = if expected_pointer {
                    if !self.inside_unsafe {
                        report.error(
                            "cannot take the address of a value outside of an `unsafe` block",
                            unary.pos
                        );
                    }
                    .Pointer(unary.type, unary.is_ref_mut, indexable_pointer)
                } else {
                    .Reference(unary.type, unary.is_ref_mut)
                };
            },
            else => {}
        }
        return unary.type;
    }

    func check_return(mut self, mut return_expr: ast.Expr.Return) ast.Type {
        if self.inside_defer {
            report.error("`return` is not allowed inside `defer` statement", return_expr.pos);
        } else if self.inside_test and return_expr.has_expr {
            report.error("cannot return values inside `test` declaration", return_expr.pos);
        } else if return_expr.has_expr {
            if self.cur_fn.ret_type is .Void {
                report.error(
                    "{} `{}` should not return a value".fmt(
                        self.cur_fn.kind(), self.cur_fn.name
                    ), return_expr.expr.position()
                );
            } else {
                old_expected_type := self.expected_type;
                self.expected_type = if self.cur_fn.ret_type is .Result as res_t {
                    res_t.inner
                } else {
                    self.cur_fn.ret_type
                };
                expr_type := self.check_expr(return_expr.expr);
                self.expected_type = old_expected_type;
                self.check_types(expr_type, self.cur_fn.ret_type) catch |err| {
                    expr_sym := expr_type.symbol()?;
                    if !(
                        self.cur_fn.ret_type is .Result
                        and (
                            expr_sym.implement_trait(self.table.error_sym)
                            or expr_sym != self.table.error_sym
                        )
                    ) {
                        mut err_b := report.error_builder(
                            err.to_string(), return_expr.expr.position()
                        );
                        err_b.add_note(
                            "in return of {} `{}`", self.cur_fn.kind(),
                            self.cur_fn.name
                        );
                        err_b.emit();
                    }
                };
            }
        } else if !(
            self.cur_fn.ret_type is .Void
            or (self.cur_fn.ret_type is .Result as res_t and res_t.inner is .Void)
        ) {
            mut err := report.error_builder(
                "expected `{}` value in return argument".fmt(self.cur_fn.ret_type),
                return_expr.pos
            );
            err.add_note("in return of {} `{}`", self.cur_fn.kind(), self.cur_fn.name);
            err.emit();
        }
        return .Never(return_expr.pos);
    }

    func check_if(mut self, mut if_expr: ast.Expr.If) ast.Type {
        if_expr.expected_type = self.expected_type;
        for i, branch in if_expr.branches {
            if !branch.is_else {
                bcond_t := self.check_expr(branch.cond);
                if branch.cond !is .Guard and bcond_t != self.table.bool_t {
                    report.error(
                        "non-boolean expression used as `if` condition",
                        branch.cond.position()
                    );
                }
            }
            mut branch_t := ast.Type.Void();
            if i == 0 {
                branch_t = self.check_expr(branch.expr);
                if if_expr.expected_type is .Void {
                    if_expr.expected_type = branch_t;
                }
                if_expr.type = branch_t;
            } else {
                old_expected_type := self.expected_type;
                self.expected_type = if_expr.expected_type;
                branch_t = self.check_expr(branch.expr);
                self.expected_type = old_expected_type;
                self.check_types(branch_t, if_expr.expected_type) catch |err| {
                    report.error(err.to_string(), branch.expr.position());
                };
            }
            branch.type = branch_t;
        }
        if if_expr.type !in ast.VOID_TYPES and !if_expr.has_else {
            report.error("`if` expression needs an `else` branch", if_expr.pos);
        }
        return if_expr.expected_type;
    }

    func check_switch(mut self, mut switch_expr: ast.Expr.Switch) ast.Type {
        mut branch_exprs := MapStringUsize();
        switch_expr.type = .Void();
        expr_type := self.check_expr(switch_expr.expr);
        expr_sym := expr_type.symbol()?;
        if switch_expr.is_typeswitch and (expr_sym.info !is .Enum or expr_sym.info !is .Trait) {
            mut err := report.error_builder("invalid value for typeswitch", switch_expr.expr.position());
            err.add_note("expected enum or trait value, found `{}`", expr_type);
            err.emit();
        } else if expr_sym.info is .Enum as enum_info {
            if enum_info.is_boxed and !switch_expr.is_typeswitch {
                mut err := report.error_builder("cannot use `switch` with a boxed enum value", switch_expr.pos);
                err.add_note("use a typeswitch instead");
                err.emit();
            } else if !enum_info.is_boxed and switch_expr.is_typeswitch {
                mut err := report.error_builder("cannot use typeswitch with a enum value", switch_expr.pos);
                err.add_note("use a simple `switch` instead");
                err.emit();
            }
        }

        switch_expr.expected_type = self.expected_type;
        for ib, branch in switch_expr.branches {
            if !branch.is_else {
                old_expected_type := self.expected_type;
                self.expected_type = expr_type;
                for i, mut pattern in branch.patterns {
                    mut pat_t := self.check_expr(pattern);
                    if switch_expr.is_typeswitch {
                        pat_t = self.table.comptime_number_to_type(pat_t);
                    }
                    if i == 0 {
                        branch.var_type = pat_t;
                    }
                    self.check_types(pat_t, expr_type) catch |err| {
                        report.error(err.to_string(), pattern.position());
                    };
                    key := pattern.to_string();
                    if val := branch_exprs.get(key) {
                        if val == 1 {
                            report.error(
                                "switch case is handled more than once", pattern.position()
                            );
                        } else {
                            branch_exprs.set(key, val + 1);
                        }
                    } else {
                        branch_exprs.set(key, 1);
                    }
                }
                if branch.has_var {
                    if branch.var_is_mut {
                        self.check_expr_is_mut(switch_expr.expr);
                    }
                    if branch.patterns.len != 1 {
                        report.error("multiple patterns cannot have variable", branch.var_pos);
                    } else if expr_sym.is_boxed() {
                        if expr_sym.info is .Enum {
                            pat0 := @cast(
                                ast.Expr.EnumLiteral, branch.patterns[0]
                            ).variant;
                            if pat0.has_type {
                                branch.var_type = pat0.type;
                                switch_expr.scope.update_is_hidden_ref(
                                    branch.var_name, branch.var_is_mut
                                );
                            } else {
                                report.error(
                                    "cannot use void expression as value",
                                    branch.patterns[0].position()
                                );
                            }
                        }
                        switch_expr.scope.update_type(branch.var_name, branch.var_type);
                    } else {
                        report.error("only boxed types can have vars", branch.var_pos);
                    }
                }
                if branch.has_cond and self.check_expr(branch.cond) != self.table.bool_t {
                    report.error(
                        "non-boolean expression use as `switch` branch condition",
                        branch.cond.position()
                    );
                }
                self.expected_type = old_expected_type;
            }
            mut branch_t := ast.Type.Void();
            if ib == 0 {
                branch_t = self.check_expr(branch.expr);
                if switch_expr.expected_type is .Void {
                    switch_expr.expected_type = branch_t;
                }
                switch_expr.type = branch_t;
            } else {
                old_expected_type := self.expected_type;
                self.expected_type = switch_expr.expected_type;
                branch_t = self.check_expr(branch.expr);
                self.expected_type = old_expected_type;
                self.check_types(branch_t, switch_expr.expected_type) catch |err| {
                    report.error(err.to_string(), branch.expr.position());
                };
            }
            branch.type = branch_t;
        }

        // check that expressions are exhaustive, this is achieved either by putting
		// an `else` or when the `switch` is on an enum by listing all variants.
		mut is_exhaustive := true;
		mut unhandled := @vec(string);
		if expr_type == self.table.bool_t {
            for v in ["true", "false"]! {
                if !branch_exprs.contains(v) {
                    is_exhaustive = false;
                    unhandled.push("`{}`".fmt(v));
                }
            }
		} else if expr_sym.info is .Enum as enum_info2 {
            for variant in enum_info2.variants {
                e := ".".concat(variant.name);
                if !branch_exprs.contains(e) {
                    is_exhaustive = false;
                    unhandled.push("`{}`".fmt(e));
                }
            }
		} else {
            is_exhaustive = false;
		}

		mut else_branch := switch_expr.branches[switch_expr.branches.len - 1];
		mut has_else := switch_expr.has_else;
		if !has_else {
            for i, branch in switch_expr.branches {
                if branch.is_else and i != switch_expr.branches.len - 1 {
                    report.error("`else` must be the last branch of `switch`", branch.pos);
                    else_branch = branch;
                    has_else = true;
                }
            }
		}
		if is_exhaustive {
            if has_else {
                report.error("`switch` is exhaustive, `else` is unnecessary", else_branch.pos);
            }
            return switch_expr.expected_type;
		}
		if has_else {
            return switch_expr.expected_type;
		}

		mut err := report.error_builder("`switch` must be exhaustive", switch_expr.pos);
		if unhandled.len > 0 {
            mut err_details := "add `switch` branches for: ";
            if unhandled.len < SWITCH_EXHAUSTIVE_CUTOFF_LIMIT {
                err_details = err_details.concat(utils.join(unhandled, ", "));
            } else {
                err_details = err_details.concat(
                    utils.join(unhandled[..SWITCH_EXHAUSTIVE_CUTOFF_LIMIT], ", ")
                );
                remaining := unhandled.len - SWITCH_EXHAUSTIVE_CUTOFF_LIMIT;
                if remaining > 0 {
                    err_details = err_details.concat(", and {} others...".fmt(remaining));
                }
            }
            err.add_help(err_details);
		} else {
            err.add_help("add `else` branch at the end");
		}
		err.emit();
        return switch_expr.expected_type;
    }

    func check_expr_is_mut(self, expr: ast.Expr, from_assign: bool = false) {
        switch expr is {
            .Paren as paren => self.check_expr_is_mut(paren.expr),
            .SelfLiteral as self_lit => {
                if !self_lit.obj.is_mut {
                    mut err := report.error_builder(
                        "cannot use `self` as mutable value", self_lit.pos
                    );
                    err.add_help("consider making `self` as mutable: `mut self`");
                    err.emit();
                }
                self_lit.obj.is_changed = true;
            },
            .Ident as ident => if ident.is_comptime {
                report.error(
                    "cannot use constant `@{}` as mutable value".fmt(ident.name),
                    ident.pos
                );
            } else if ident.name == "_" {
                return;
            } else if ident.found and ident.is_sym {
                self.check_sym_is_mut(ident.sym, ident.pos);
            },
            .Selector as selector => if selector.is_path {
                self.check_sym_is_mut(selector.sym, selector.pos);
            } else {
                self.check_expr_is_mut(selector.left);
                if selector.found and !selector.field_is_mut {
                    report.error(
                        "field `{}` of type `{}` is immutable".fmt(
                            selector.field_name, selector.left_type.symbol()?.name
                        ), selector.pos
                    );
                }
            },
            .Indirect as indirect => if !indirect.is_mut {
                kind := if selector.left_type is .Reference {
                    "reference"
                } else {
                    "pointer"
                };
                report.error(
                    "cannot use a immutable {} as mutable value".fmt(kind),
                    selector.pos
                );
            },
            .OptionCheck as option_check => self.check_expr_is_mut(option_check.left),
            .NoneLiteral => report.error("`none` cannot be modified", expr.position()),
            .StringLiteral => report.error(
                "string literals cannot be modified", expr.position()
            ),
            .TupleLiteral as tuple_lit => if from_assign {
                for value in tuple_lit.values {
                    self.check_expr_is_mut(value);
                }
            } else {
                report.error("tuple literals cannot be modified", tuple_lit.pos);
            },
            .EnumLiteral as enum_lit if !enum_lit.is_instance => report.error(
                "enum literals cannot be modified", enum_lit.pos
            ),
            .BuiltinCall as builtin_call => {
                for arg in builtin_call.args {
                    self.check_expr_is_mut(arg);
                }
            },
            .Block as block if block.is_expr => self.check_expr_is_mut(block.expr),
            .Index as index => {
                if index.left_type is .Pointer as ptr {
                    if !ptr.is_mut {
                        report.error(
                            "cannot modify elements of an immutable pointer", index.pos
                        );
                    }
                    return;
                }
                expr_sym := index.left_type.symbol()?;
                if !expr_sym.info.is_mut_arr_or_vec() {
                    report.error(
                        "cannot modify elements of an immutable {}".fmt(expr_sym.info),
                        index.pos
                    );
                }
            },
            .Unary as unary => self.check_expr_is_mut(unary.right),
            .Binary as binary => {
                self.check_expr_is_mut(binary.left);
                self.check_expr_is_mut(binary.right);
            },
            else => {}
        }
    }

    func check_sym_is_mut(self, sym: ast.Sym, pos: token.Pos) {
        switch sym is {
            ast.Const as const_info => report.error(
                "cannot use constant `{}` as mutable value".fmt(sym.name), pos
            ),
            ast.Var as var_info => {
                if !var_info.is_mut {
                    err := if var_info.level == .Argument {
                        mut err_b := report.error_builder(
                            "cannot use variable `{}` as mutable argument".fmt(sym.name), pos
                        );
                        err_b.add_help(
                            "consider making this argument mutable: `mut {}`", var_info.name
                        );
                        err_b
                    } else {
                        mut err_b := report.error_builder(
                            "cannot use variable `{}` as mutable value".fmt(sym.name), pos
                        );
                        err_b.add_help(
                            "consider making this {} mutable: `mut {}`", var_info.type_of(),
                            var_info.name
                        );
                        err_b
                    };
                    err.emit();
                }
                var_info.is_changed = true;
            },
            else => {}
        }
    }

    func check_expr_evaluated_but_not_used(self, expr_type: ast.Type, pos: token.Pos) {
        if !((expr_type is .Result as res and res.inner in ast.VOID_TYPES)
            or (expr_type is .Option as opt and opt.inner in ast.VOID_TYPES)
            or expr_type in ast.VOID_TYPES) {
            report.warn("expression evaluated but not used", pos);
        }
    }
}
