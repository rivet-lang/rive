// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../token;
import ../report;

extend Checker {
    func check_expr(mut self, mut expr: ast.Expr) ast.Type {
        return switch expr is {
            .Empty, .Type => .Void(),
            .Paren as paren => self.check_expr(paren.expr),
            .NoneLiteral as none_lit => self.table.none_t,
            .BoolLiteral as bool_lit => self.table.bool_t,
            .CharLiteral as char_lit => {
                char_lit.type = if char_lit.is_byte {
                    self.table.uint8_t
                } else {
                    self.table.rune_t
                };
                char_lit.type
            },
            .IntegerLiteral as int_lit => {
                int_lit.type = self.table.comptime_int_t;
                int_lit.type
            },
            .FloatLiteral as float_lit => {
                float_lit.type = self.table.comptime_float_t;
                float_lit.type
            },
            .StringLiteral as string_lit => {
                string_lit.type = if string_lit.is_bytestr {
                    .Basic(self.table.universe.add_or_get_array(
                        self.table.uint8_t, string_lit.value.len, false
                    ))
                } else if string_lit.is_cstr {
                    .Pointer(self.table.uint8_t, is_indexable: true)
                } else {
                    self.table.string_t
                };
                string_lit.type
            },
            .SelfLiteral as self_lit => {
                self_lit.type = .Basic(self_lit.sym);
                self_lit.type
            },
            .SelfTy as self_ty => .Void(),
            .EnumLiteral as enum_lit => {
                enum_lit.type = .Void();
                sym := self.expected_type.symbol()?;
                if sym.info is .Enum as enum_info {
                    if variant := enum_info.get_variant(enum_lit.value) {
                        enum_lit.variant = variant;
                        enum_lit.type = .Basic(sym, pos: enum_lit.pos);
                        if enum_info.is_boxed and !enum_lit.from_is_cmp and !enum_lit.is_instance {
                            mut err := report.error_builder(
                                "cannot use variant `.{}` as a simple value".fmt(enum_lit.value),
                                enum_lit.pos
                            );
                            err.add_note(
                                "make an instance instead: `.{}()`", enum_lit.value
                            );
                            err.emit();
                        }
                    } else {
                        report.error(
                            "enum `{}` has no variant `{}`".fmt(sym.name, enum_lit.value),
                            enum_lit.pos
                        );
                    }
                } else {
                    report.error("`{}` is not a enum".fmt(self.expected_type), enum_lit.pos);
                }
                enum_lit.type
            },
            .Ident as ident => {
                ident.type = if ident.name == "_" {
                    .Void()
                } else if ident.is_comptime {
                    ident.builtin.type()
                } else if ident.is_sym or ident.is_obj {
                    switch ident.sym is {
                        ast.Func as func_sym => {
                            if func_sym.abi != .Rivet {
                                mut err := report.error_builder(
                                    "cannot use an extern function as a value", ident.pos
                                );
                                err.add_help("wrap the extern function with a function");
                                err.emit();
                            }
                            func_sym.type()
                        },
                        ast.Const as const_sym => const_sym.type,
                        ast.Var as var_sym => var_sym.type,
                        else => .Void()
                    }
                } else {
                    .Void()
                };
                ident.type
            },
            .Selector as mut selector => self.check_selector(selector),
            .Indirect as indirect => {
              	indirect.left_type = self.check_expr(indirect.left);
                indirect.type = if indirect.left_type.is_ptr_or_ref()
                    or (indirect.left_type is .Pointer as ptr and ptr.is_indexable)
                    or indirect.left_type is .Anyptr  {
                	indirect.is_mut = indirect.left_type.is_mut_ptr_or_ref();
                    indirect.left_type.ptr_or_ref_inner()
                } else {
                    mut err := report.error_builder(
                        "invalid indirect for `{}`".fmt(indirect.left_type), indirect.pos
                    );
                    if indirect.left_type is .Anyptr {
                        err.add_help(
                            "consider casting this to another pointer type, e.g. `*uint8`"
                        );
                    }
                    err.emit();
                    .Void()
                };
                indirect.type
            },
            .OptionCheck as option_check => {
            	option_check.left_type = self.check_expr(option_check.left);
                option_check.type = if option_check.left_type is .Option as opt {
                    opt.inner
                } else {
                    report.error("cannot check a non-option value", option_check.left.position());
                    .Void()
                };
                option_check.type
            },
            .Index as mut index => self.check_index(index),
            .Call as mut call_expr => self.check_call(call_expr),
            .Block as block => {
                if block.is_unsafe {
                    if self.inside_unsafe {
                        report.warn("unnecessary `unsafe` block", block.pos);
                    }
                    self.inside_unsafe = true;
                }
                old_expected_type := self.expected_type;
                self.expected_type = .Void();
                for mut stmt in block.stmts {
                    self.check_stmt(stmt);
                }
                self.expected_type = old_expected_type;
                block.type = if block.is_expr {
                    self.check_expr(block.expr)
                } else {
                    .Void()
                };
                if block.is_unsafe {
                    self.inside_unsafe = false;
                }
                block.type
            },
            .Unary as mut unary => self.check_unary(unary),
            .Return as mut return_expr => self.check_return(return_expr),
            .Guard as guard => {
                old_inside_guard_expr := self.inside_guard_expr;
                self.inside_guard_expr = true;
                self.check_var_decl(guard.vars, guard.expr, guard.scope, guard.pos);
                if guard.has_cond and self.check_expr(guard.cond) != self.table.bool_t {
                    report.error(
                        "non-boolean expression used as guard condition",
                        guard.cond.position()
                    );
                }
                self.inside_guard_expr = old_inside_guard_expr;
                .Void()
            },
            else => .Void()
        };
    }

    func check_selector(mut self, mut selector: ast.Expr.Selector) ast.Type {
        selector.type = if selector.is_path {
            if selector.left_sym is ast.TypeSym as type_sym {
                .Basic(type_sym, pos: selector.pos)
            } else {
                switch selector.sym is {
                    ast.Func as func_sym => {
                        if func_sym.is_method {
                            report.error(
                                "cannot take value of method `{}`".fmt(
                                    selector.field_name
                                ), selector.field_pos
                            );
                        }
                        func_sym.type()
                    },
                    ast.TypeSym as type_sym_ => .Basic(type_sym_, pos: selector.pos),
                    ast.Const as const_sym => const_sym.type,
                    ast.Var as var_sym => var_sym.type,
                    else => {
                        mut err := report.error_builder(
                            "unexpected bug for selector expression", selector.pos
                        );
                        err.add_note("please report this bug, thanks =D");
                        err.emit();
                        .Void()
                    }
                }
            }
        } else {
            selector.left_type = self.check_expr(selector.left);
            left_sym := selector.left_type.symbol()?;
            if field := left_sym.lookup_field(selector.field_name) {
                selector.found = true;
                selector.field_is_mut = field.is_mut;
                field.type
            } else if sym := left_sym.scope.find(selector.field_name) {
                if sym is ast.Func as func_sym {
                    if func_sym.is_method {
                        mut err := report.error_builder(
                            "cannot take value of method `{}`".fmt(selector.field_name),
                            selector.field_pos
                        );
                        err.add_help("use parentheses to call the method");
                        err.emit();
                        .Void()
                    } else {
                        mut err := report.error_builder(
                            "cannot take value of associated function `{}`".fmt(selector.field_name),
                            selector.field_pos
                        );
                        err.add_help("use `{}.{}` instead", left_sym.name, selector.field_name);
                        err.emit();
                        func_sym.type()
                    }
                } else {
                    report.error(
                        "cannot take value of {} `{}.{}`".fmt(
                            sym.type_of(), left_sym.name, selector.field_name
                        ), selector.pos
                    );
                    .Void()
                }
            } else {
                mut err := report.error_builder(
                    "type `{}` has no field `{}`".fmt(
                        left_sym.name, selector.field_name
                    ), selector.field_pos
                );
                if selector.field_name.is_digit()
                    and (left_sym.info is .Vector or left_sym.info is .Array ) {
                    err.add_note(
                        "instead of using tuple indexing, use array indexing: `{}[{}]`"
                            .fmt(selector.left, selector.field_name)
                    );
                }
                err.emit();
                .Void()
            }
        };
        return selector.type;
    }

    func check_index(mut self, mut index: ast.Expr.Index) ast.Type {
        index.left_type = self.check_expr(index.left);
        left_sym := index.left_type.symbol()?;
        index_t := self.check_expr(index.index);
        if index_t != self.table.comptime_int_t and !self.table.is_unsigned_int(index_t) {
            report.error(
                "expected unsigned integer value, found `{}`".fmt(index_t),
                index.index.position()
            );
        }
        switch left_sym.info is {
            .Array, .Vector => {
                elem_type := left_sym.info.elem_type()?;
                if index.index is .Range as range {
                    is_mut := left_sym.info.is_mut_arr_or_vec();
                    index.type = if left_sym.info is .Vector {
                        index.left_type
                    } else {
                        .Vector(
                            elem_type, is_mut,
                            self.table.universe.add_or_get_vec(elem_type, is_mut)
                        )
                    };
                } else {
                    index.type = elem_type;
                }
            },
            else => {
                if !(index.left_type is .Pointer or index.left_type == self.table.string_t) {
                    mut err := report.error_builder(
                        "type `{}` does not support indexing".fmt(index.left_type),
                        index.pos
                    );
                    err.add_note("only pointers, arrays, slices and string supports indexing");
                    err.emit();
                } else if index.left_type is .Pointer as pointer {
                    if !self.inside_unsafe {
                        report.error(
                            "pointer indexing is only allowed inside `unsafe` blocks",
                            index.pos
                        );
                    } else if index.index is .Range {
                        report.error("cannot slice a pointer", index.index.position());
                    } else if !pointer.is_indexable {
                        report.error("cannot index a non-indexable pointer", index.pos);
                    }
                }
                index.type = if index.left_type == self.table.string_t {
                    if index.index is .Range {
                        self.table.string_t
                    } else {
                        self.table.uint8_t
                    }
                } else {
                    .Void()
                };
            }
        }
        return index.type;
    }

    func check_call(mut self, mut call_expr: ast.Expr.Call) ast.Type {
        call_expr.type = .Void();

        mut left := call_expr.left;
        inside_parens := if left is .Paren as paren
            and paren.expr is .Selector as paren_selector and !paren_selector.is_path {
            left = paren.expr;
            true
        } else {
            false
        };

        switch left is {
            .SelfTy as self_ty => self.check_ctor_call(self_ty.sym, call_expr),
            .Ident as ident => switch ident.sym is {
                ast.TypeSym as mut type_sym if type_sym.info is .Trait
                    or type_sym.info is .Struct or type_sym.info is .String
                    or type_sym.info is .Enum => self.check_ctor_call(type_sym, call_expr),
                ast.Func as func_ => {
                    call_expr.func_ = func_;
                    if func_.is_main {
                        report.error("cannot call to `main` function", ident.pos);
                    } else {
                        self.check_func_call(func_, call_expr);
                    }
                },
                else => if ident.type is .Func as i_func {
                    call_expr.is_closure = true;
                    self.check_func_call(i_func.symbol(), call_expr);
                } else {
                    report.error(
                        "expected function or method to call, found {}".fmt(
                            ident.sym.type_of()
                        ), ident.pos
                    );
                }
            },
            .Selector as selector => if selector.is_path {
                switch selector.sym is {
                    ast.TypeSym as mut s_type_sym if s_type_sym.info is .Trait
                        or s_type_sym.info is .Struct or s_type_sym.info is .String
                        or s_type_sym.info is .Enum => self.check_ctor_call(
                        s_type_sym, call_expr
                    ),
                    ast.Func as s_func_ => {
                        call_expr.func_ = s_func_;
                        self.check_func_call(s_func_, call_expr);
                    },
                    else => if selector.type is .Func as s_func {
                        call_expr.is_closure = true;
                        self.check_func_call(s_func.symbol(), call_expr);
                    } else {
                        report.error(
                            "expected function or method to call, found {}".fmt(
                                selector.sym.type_of()
                            ), selector.pos
                        );
                    }
                }
            } else {
                // call methods
                selector.left_type = self.check_expr(selector.left);
                if selector.left_type is .Option {
                    mut err := report.error_builder(
                        "option value cannot be called directly",
                        selector.left.position()
                    );
                    err.add_help("use the option-check syntax: `foo?.method()`");
                    err.add_help("or use `??`: `(foo ?? 5).method()`");
                    err.emit();
                    return .Void();
                } else if selector.left_type is .Pointer {
                    mut err := report.error_builder(
                        "cannot use a pointer value as receiver", selector.left.position()
                    );
                    err.add_help("consider dereferencing this pointer");
                    err.emit();
                    return .Void();
                }
                left_sym := selector.left_type.symbol()?;
                if method := left_sym.scope.find(selector.field_name) {
                    if method is ast.Func as s_func {
                        if s_func.is_method {
                            self.check_func_call(s_func, call_expr);
                        } else {
                            report.error(
                                "`{}` is not a method".fmt(selector.field_name),
                                selector.field_pos
                            );
                        }
                    } else {
                        report.error(
                            "expected method, found {}".fmt(s_func.kind()),
                            selector.pos
                        );
                    }
                } else if field := left_sym.lookup_field(selector.field_name) {
                    if field.type is .Func as f_func {
                        if inside_parens {
                            call_expr.is_closure = true;
                            selector.field_type = field.type;
                            self.check_func_call(f_func.symbol(), call_expr);
                        } else {
                            mut err := report.error_builder(
                                "type `{}` has no method `{}`".fmt(
                                    left_sym.name, selector.field_name
                                ), selector.field_pos
                            );
                            err.add_help(
                                "to call the function stored in `{}`, "
                                "surround the field access with parentheses"
                                    .fmt(selector.field_name)
                            );
                            err.emit();
                        }
                    } else {
                        report.error(
                            "field `{}` of type `{}` is not function type".fmt(
                                selector.field_name, left_sym.name
                            ), selector.field_pos
                        );
                    }
                } else {
                    report.error(
                        "type `{}` has no method `{}`".fmt(
                            left_sym.name, selector.field_name
                        ), selector.field_pos
                    );
                }
            },
            .EnumLiteral as enum_lit => {
                enum_lit.is_instance = true;
                _ = self.check_expr(left);
                self.check_ctor_call(enum_lit.sym, call_expr);
            },
            else => report.error("invalid expression used in call expression", left.position())
        }

        // result checking
        if call_expr.has_err_handler() {
            if call_expr.type is .Result as result_t {
                if call_expr.err_handler.is_propagate {
                    if !(self.cur_fn.is_main or self.inside_test or self.inside_var_decl
                        or self.cur_fn.ret_type is .Result) {
                        mut err := report.error_builder(
                            "cannot propagate the result value", call_expr.err_handler.pos
                        );
                        err.add_note(
                            "to propagate the result, `{}` must return an result type",
                            self.cur_fn.name
                        );
                        err.emit();
                    }
                } else {
                    self.check_types(
                        self.check_expr(call_expr.err_handler.expr), result_t.inner
                    ) catch |err| {
                        report.error(err.to_string(), call_expr.err_handler.expr.position());
                    };
                }
                call_expr.type = result_t.inner;
            } else {
                report.error(
                    "{} `{}` does not returns a result value".fmt(
                        call_expr.func_.type_of(), call_expr.func_.name
                    ), call_expr.err_handler.pos
                );
            }
        } else if call_expr.type is .Result and !self.inside_guard_expr {
            mut err := report.error_builder(
                "{} `{}` returns a result".fmt(
                    call_expr.func_.type_of(), call_expr.func_.name
                ), call_expr.pos
            );
            err.add_note("should handle this with `catch` or propagate with `!`");
            err.emit();
        }

        return call_expr.type;
    }

    func check_unary(mut self, mut unary: ast.Expr.Unary) ast.Type {
        unary.type = self.check_expr(unary.right);
        switch unary.op {
            .Bang if unary.type != self.table.bool_t => report.error(
                "operator `!` can only be used with boolean values", unary.pos
            ),
            .BitNot if !self.table.is_int(unary.type) => report.error(
                "operator `~` can only be used with numeric values", unary.pos
            ),
            .Minus => if self.table.is_unsigned_int(unary.type) {
                mut err := report.error_builder(
                    "cannot apply unary operator `-` to type `{expr.typ}`".fmt(
                        unary.type
                    ), unary.pos
                );
                err.add_note("unsigned values cannot be negated");
                err.emit();
            } else if !(self.table.is_signed_int(unary.type)
                or self.table.is_float(unary.type)) {
                report.error(
                    "operator `-` can only be used with signed integer or float values",
                    unary.pos
                );
            },
            .Amp => {
                mut expected_pointer := false;
                mut indexable_pointer := false;
                if self.expected_type is .Pointer as ptr {
                    expected_pointer = true;
                    indexable_pointer = ptr.is_indexable;
                } else if self.expected_type is .Option as opt
                    and opt.inner is .Pointer as opt_ptr {
                    expected_pointer = true;
                    indexable_pointer = opt_ptr.is_indexable;
                }
                right := unary.right.clean_paren();
                if right is .Index as index {
                    if index.left_type is .Pointer and !expected_pointer {
                        report.error("cannot reference a pointer indexing", unary.pos);
                    }
                    index.is_ref = true;
                } else if unary.type is .Reference {
                    report.error("cannot take the address of other reference", unary.pos);
                } else if unary.is_ref_mut {
                    self.check_expr_is_mut(right);
                } else {
                    right_sym := unary.type.symbol()?;
                    if right_sym.is_boxed() {
                        report.error("cannot reference a boxed value", unary.pos);
                    }
                }
                unary.type = if expected_pointer {
                    if !self.inside_unsafe {
                        report.error(
                            "cannot take the address of a value outside of an `unsafe` block",
                            unary.pos
                        );
                    }
                    .Pointer(unary.type, unary.is_ref_mut, indexable_pointer)
                } else {
                    .Reference(unary.type, unary.is_ref_mut)
                };
            },
            else => {}
        }
        return unary.type;
    }

    func check_return(mut self, mut return_expr: ast.Expr.Return) ast.Type {
        if self.inside_defer {
            report.error("`return` is not allowed inside `defer` statement", return_expr.pos);
        } else if self.inside_test and return_expr.has_expr {
            report.error("cannot return values inside `test` declaration", return_expr.pos);
        } else if return_expr.has_expr {
            if self.cur_fn.ret_type is .Void {
                report.error(
                    "{} `{}` should not return a value".fmt(
                        self.cur_fn.kind(), self.cur_fn.name
                    ), return_expr.expr.position()
                );
            } else {
                old_expected_type := self.expected_type;
                self.expected_type = if self.cur_fn.ret_type is .Result as res_t {
                    res_t.inner
                } else {
                    self.cur_fn.ret_type
                };
                expr_type := self.check_expr(return_expr.expr);
                self.expected_type = old_expected_type;
                self.check_types(expr_type, self.cur_fn.ret_type) catch |err| {
                    expr_sym := expr_type.symbol()?;
                    if !(
                        self.cur_fn.ret_type is .Result
                        and expr_sym.implement_trait(self.table.error_sym)
                    ) {
                        mut err_b := report.error_builder(
                            err.to_string(), return_expr.expr.position()
                        );
                        err_b.add_note(
                            "in return of {} `{}`", self.cur_fn.kind(),
                            self.cur_fn.name
                        );
                        err_b.emit();
                    }
                };
            }
        } else if !(
            self.cur_fn.ret_type is .Void
            or (self.cur_fn.ret_type is .Result as res_t and res_t.inner is .Void)
        ) {
            mut err := report.error_builder(
                "expected `{}` value in return argument".fmt(self.cur_fn.ret_type),
                return_expr.pos
            );
            err.add_note("in return of {} `{}`", self.cur_fn.kind(), self.cur_fn.name);
            err.emit();
        }
        return .Never(return_expr.pos);
    }

    func check_expr_is_mut(self, expr: ast.Expr, from_assign: bool = false) {
        switch expr is {
            .Paren as paren => self.check_expr_is_mut(paren.expr),
            .SelfLiteral as self_lit => {
                if !self_lit.obj.is_mut {
                    mut err := report.error_builder(
                        "cannot use `self` as mutable value", self_lit.pos
                    );
                    err.add_help("consider making `self` as mutable: `mut self`");
                    err.emit();
                }
                self_lit.obj.is_changed = true;
            },
            .Ident as ident => if ident.is_comptime {
                report.error(
                    "cannot use constant `@{}` as mutable value".fmt(ident.name),
                    ident.pos
                );
            } else if ident.name == "_" {
                return;
            } else if ident.found and ident.is_sym {
                self.check_sym_is_mut(ident.sym, ident.pos);
            },
            .Selector as selector => if selector.is_path {
                self.check_sym_is_mut(selector.sym, selector.pos);
            } else {
                self.check_expr_is_mut(selector.left);
                if selector.found and !selector.field_is_mut {
                    report.error(
                        "field `{}` of type `{}` is immutable".fmt(
                            selector.field_name, selector.left_type.symbol()?.name
                        ), selector.pos
                    );
                }
            },
            .Indirect as indirect => if !indirect.is_mut {
                kind := if selector.left_type is .Reference {
                    "reference"
                } else {
                    "pointer"
                };
                report.error(
                    "cannot use a immutable {} as mutable value".fmt(kind),
                    selector.pos
                );
            },
            .OptionCheck as option_check => self.check_expr_is_mut(option_check.left),
            .NoneLiteral => report.error("`none` cannot be modified", expr.position()),
            .StringLiteral => report.error(
                "string literals cannot be modified", expr.position()
            ),
            .TupleLiteral as tuple_lit => if from_assign {
                for value in tuple_lit.values {
                    self.check_expr_is_mut(value);
                }
            } else {
                report.error("tuple literals cannot be modified", tuple_lit.pos);
            },
            .EnumLiteral as enum_lit if !enum_lit.is_instance => report.error(
                "enum literals cannot be modified", enum_lit.pos
            ),
            .BuiltinCall as builtin_call => {
                for arg in builtin_call.args {
                    self.check_expr_is_mut(arg);
                }
            },
            .Block as block if block.is_expr => self.check_expr_is_mut(block.expr),
            .Index as index => {
                if index.left_type is .Pointer as ptr {
                    if !ptr.is_mut {
                        report.error(
                            "cannot modify elements of an immutable pointer", index.pos
                        );
                    }
                    return;
                }
                expr_sym := index.left_type.symbol()?;
                if !expr_sym.info.is_mut_arr_or_vec() {
                    report.error(
                        "cannot modify elements of an immutable {}".fmt(expr_sym.info),
                        index.pos
                    );
                }
            },
            .Unary as unary => self.check_expr_is_mut(unary.right),
            .Binary as binary => {
                self.check_expr_is_mut(binary.left);
                self.check_expr_is_mut(binary.right);
            },
            else => {}
        }
    }

    func check_sym_is_mut(self, sym: ast.Sym, pos: token.Pos) {
        switch sym is {
            ast.Const as const_info => report.error(
                "cannot use constant `{}` as mutable value".fmt(sym.name), pos
            ),
            ast.Var as var_info => {
                if !var_info.is_mut {
                    err := if var_info.level == .Argument {
                        mut err_b := report.error_builder(
                            "cannot use variable `{}` as mutable argument".fmt(sym.name), pos
                        );
                        err_b.add_help(
                            "consider making this argument mutable: `mut {}`", var_info.name
                        );
                        err_b
                    } else {
                        mut err_b := report.error_builder(
                            "cannot use variable `{}` as mutable value".fmt(sym.name), pos
                        );
                        err_b.add_help(
                            "consider making this {} mutable: `mut {}`", var_info.type_of(),
                            var_info.name
                        );
                        err_b
                    };
                    err.emit();
                }
                var_info.is_changed = true;
            },
            else => {}
        }
    }

    func check_expr_evaluated_but_not_used(self, expr_type: ast.Type, pos: token.Pos) {
        if !((expr_type is .Result as res and res.inner in ast.VOID_TYPES)
            or (expr_type is .Option as opt and opt.inner in ast.VOID_TYPES)
            or expr_type in ast.VOID_TYPES) {
            report.warn("expression evaluated but not used", pos);
        }
    }
}
