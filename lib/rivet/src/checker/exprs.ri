// Copyright (C) 2023-present Jose Mendoza - All rights reserved. Use of this
// source code is governed by an MIT license that can be found in the LICENSE
// file.

import ../{ ast, report };

extend Checker {
    func check_expr(+mut self, expr: +mut ast.Expr) -> +mut ast.Type {
        return match expr.+ {
            .Empty, .Comment -> .Void,
            .Type(type) -> type,
            .ComptimeIf(&mut comptime_if) -> {
                exprs := ast.nodes_to_exprs(
                    self.env.evalue_comptime_if(comptime_if)
                );
                comptime_if.type = self.check_expr(exprs[0]);
                comptime_if.type
            },
            .LoopControl(loop_control) -> {
                self.scope_returns = true;
                if self.loop_control_tracker != .AnyLoop {
                    if self.loop_control_tracker == .Defer {
                        report.error(
                            "`break` and `continue` expressions inside loop cannot be deferred",
                            loop_control.pos
                        );
                    } else {
                        report.error(
                            "`break` and `continue` expressions can only be used inside loops",
                            loop_control.pos
                        );
                    }
                }
                +mut .Never(loop_control.pos)
            },
            .Paren(paren) -> self.check_expr(paren.expr),
            .NoneLiteral -> +mut .None,
            .BoolLiteral -> self.env.bool_t,
            .CharLiteral(&mut char_lit) -> {
                char_lit.type = if char_lit.is_byte {
                    self.env.uint8_t
                } else {
                    if self.expected_type == self.env.uint8_t {
                        char_lit.is_byte = true;
                        self.env.uint8_t
                    } else {
                        self.env.rune_t
                    }
                };
                char_lit.type
            },
            .IntegerLiteral(&mut int_lit) -> {
                int_lit.type = if self.env.is_int(self.expected_type) {
                    self.expected_type
                } else {
                    self.env.comptime_int_t
                };
                int_lit.type
            },
            .FloatLiteral(&mut float_lit) -> {
                float_lit.type = self.env.comptime_float_t;
                float_lit.type
            },
            .StringLiteral(&mut string_lit) -> {
                string_lit.type = if string_lit.is_bytestr {
                    +mut .Basic(self.env.universe.add_or_get_array(
                        self.env.uint8_t, string_lit.value.len, false
                    ))
                } else if string_lit.is_cstr {
                    +mut .Pointer(self.env.uint8_t, is_indexable: true)
                } else {
                    self.env.string_t
                };
                string_lit.type
            },
            .SelfLiteral(&mut self_lit) -> {
                self_lit.type = self_lit.obj.type;
                self_lit.type
            },
            .SelfTy -> +mut .Void,
            .EnumLiteral(&mut enum_lit) -> {
                enum_lit.type = +mut .Void;
                if sym := self.expected_type.symbol(); sym.info is .Enum(enum_info) {
                    if variant := enum_info.get_variant(enum_lit.value) {
                        enum_lit.sym = sym;
                        enum_lit.variant = variant;
                        enum_lit.type = +mut .Basic(sym, pos: enum_lit.pos);
                        if enum_info.is_tagged && !enum_lit.from_is_cmp
                            && !enum_lit.is_instance {
                            if variant.has_type {
                                err := report.error_builder(
                                    "variant `{}` cannot be initialized without arguments".fmt(
                                        enum_lit.value
                                    ),
                                    enum_lit.pos
                                );
                                err.add_help(
                                    "if you intend not to pass any value, add `()`: `{}()`",
                                    enum_lit.value
                                );
                                err.emit();
                            }
                            enum_lit.is_instance = true;
                        }
                    } else {
                        report.error(
                            "enum `{}` has no variant `{}`".fmt(sym.name, enum_lit.value),
                            enum_lit.pos
                        );
                    }
                } else {
                    report.error("`{}` is not a enum".fmt(self.expected_type), enum_lit.pos);
                }
                enum_lit.type
            },
            .TupleLiteral(&mut tuple_lit) -> self.check_tuple_literal(tuple_lit),
            .ArrayCtor(&mut array_ctor) -> {
                if init_value := array_ctor.init_value {
                    init_t := self.check_expr(init_value);
                    if !self.check_compatible_types(init_t, array_ctor.elem_type) {
                        report.error(
                            "argument `init` should have a value of type `{}`".fmt(
                                array_ctor.elem_type
                            ), init_value.position()
                        );
                    }
                    if array_ctor.len_value == none {
                        report.error(
                            "`init` argument should be used together with `len` argument",
                            init_value.position()
                        );
                    }
                }
                if len_value := array_ctor.len_value {
                    len_t := self.check_expr(len_value);
                    if !(len_t == self.env.uint_t || len_t == self.env.comptime_int_t) {
                        report.error(
                            "argument `len` should have a value of type `uint`",
                            len_value.position()
                        );
                    }
                }
                if cap_value := array_ctor.cap_value {
                    cap_t := self.check_expr(cap_value);
                    if !(cap_t == self.env.uint_t || cap_t == self.env.comptime_int_t) {
                        report.error(
                            "argument `cap` should have a value of type `uint`",
                            cap_value.position()
                        );
                    }
                }
                array_ctor.type = if array_ctor.is_dyn {
                    +mut .Basic(
                        self.env.universe.add_or_get_dyn_array(
                            array_ctor.elem_type, array_ctor.is_mut
                        ), pos: array_ctor.pos
                    )
                } else {
                    +mut .Basic(
                        self.env.universe.add_or_get_array(
                            array_ctor.elem_type, array_ctor.len_res, array_ctor.is_mut
                        ), pos: array_ctor.pos
                    )
                };
                array_ctor.type
            },
            .ArrayLiteral(&mut array_lit) -> self.check_array_literal(array_lit),
            .Ident(&mut ident) -> {
                ident.type = if ident.name == "_" {
                    .Void
                } else if ident.is_comptime {
                    ident.builtin.type()
                } else if ident.is_sym || ident.is_obj {
                    match ident.sym is {
                        ast.Const(const_sym) -> const_sym.type,
                        ast.Var(var_sym) -> var_sym.type,
                        ast.Func(mut func_sym) -> {
                            if func_sym.abi != .Rivet {
                                err := report.error_builder(
                                    "cannot use an extern function as a value", ident.pos
                                );
                                err.add_help("wrap the extern function with a function");
                                err.emit();
                            }
                            func_sym.type(self.env.universe)
                        },
                        else -> +mut .Void
                    }
                } else {
                    +mut .Void
                };
                ident.type
            },
            .Selector(&mut selector) -> self.check_selector(selector),
            .Indirect(&mut indirect) -> {
                indirect.left_type = self.check_expr(indirect.left);
                indirect.type = if indirect.left_type.is_pointer()
                    || (indirect.left_type is .Pointer(ptr) && !ptr.is_indexable)
                    || indirect.left_type is .Rawptr  {
                	indirect.is_mut = indirect.left_type.is_pointer();
                    indirect.left_type.ptr_inner()
                } else {
                    err := report.error_builder(
                        "invalid indirect for `{}`".fmt(indirect.left_type), indirect.pos
                    );
                    if indirect.left_type is .Rawptr {
                        err.add_help(
                            "consider casting this to another pointer type, e.g. `*uint8`"
                        );
                    } else if indirect.left_type is .Pointer(ptr2) && ptr2.is_indexable {
                        err.add_help("use index access to element 0 instead");
                    }
                    err.emit();
                    +mut .Void
                };
                indirect.type
            },
            .OptionCheck(&mut option_check) -> {
            	option_check.left_type = self.check_expr(option_check.left);
                option_check.type = if option_check.left_type is .Option(opt) {
                    opt.inner
                } else {
                    report.error("cannot check a non-option value", option_check.left.position());
                    +mut .Void
                };
                option_check.type
            },
            .Range(&mut range) -> {
                range.type = if range.has_start {
                    self.check_expr(range.start)
                } else {
                    self.env.uint_t
                };
                end_type := if range.has_end {
                    self.check_expr(range.end)
                } else {
                    self.env.uint_t
                };
                if !(self.env.is_int(range.type) || self.env.is_int(end_type)) {
                    report.error("non-integer value used as range", range.pos);
                }
                range.type
            },
            .Index(&mut index) -> self.check_index(index),
            .Call(&mut call_expr) -> self.check_call(call_expr),
            .BuiltinCall(&mut builtin_call) -> self.check_builtin_call(builtin_call),
            .Block(&mut block) -> {
                self.defer_stmts_start = self.defer_stmts.len;
                if block.is_unsafe {
                    if self.inside_unsafe_block {
                        report.warn("unnecessary `unsafe` block", block.pos);
                    } else {
                        self.inside_unsafe_block = true;
                    }
                }
                old_expected_type := self.expected_type;
                self.expected_type = +mut .Void;
                self.check_stmts(block.stmts);
                self.expected_type = old_expected_type;
                block.type = if block.is_expr {
                    self.check_expr(block.expr)
                } else {
                    +mut .Void
                };
                if block.type is .Void && block.is_expr {
                    // if the expression has no value then it is another statement
                    block.stmts.push(+mut .Expr(block.expr, block.pos));
                    block.is_expr = false;
                }
                if block.is_unsafe {
                    if self.unsafe_operations == 0 {
                        report.warn("unnecessary `unsafe` block", block.pos);
                    } else {
                        self.unsafe_operations = 0;
                    }
                    self.inside_unsafe_block = false;
                }
                block.defer_stmts = self.defer_stmts[self.defer_stmts_start:].to_dynamic_array();
                self.defer_stmts = self.defer_stmts[:self.defer_stmts_start].to_dynamic_array();
                block.type
            },
            .Unary(&mut unary) -> self.check_unary(unary),
            .Binary(&mut binary) -> self.check_binary(binary),
            .If(&mut if_expr) -> self.check_if(if_expr),
            .Match(&mut match_expr) -> self.check_match(match_expr),
            .Guard(&mut guard) -> {
                old_inside_guard_expr := self.inside_guard_expr;
                self.inside_guard_expr = true;
                self.check_var_decl(guard.vars, guard.expr, guard.scope, guard.pos);
                if guard.has_cond && self.check_expr(guard.cond) != self.env.bool_t {
                    report.error(
                        "non-boolean expression used as guard condition",
                        guard.cond.position()
                    );
                }
                self.inside_guard_expr = old_inside_guard_expr;
                +mut .Void
            },
            .Return(&return_expr) -> self.check_return(return_expr),
            .Throw(&throw_expr) -> self.check_throw(throw_expr),
            .Assign(&mut assign) -> self.check_assign(assign)
        };
    }

    func check_tuple_literal(+mut self, tuple_lit: &mut ast.Expr.TupleLiteral) -> +mut ast.Type {
        old_expected_type := self.expected_type;
        mut has_expected_types := false;
        mut expected_types := []+mut ast.Type();
        if expected_type_sym := self.expected_type.symbol(); expected_type_sym.info is .Tuple(tuple_info) {
            has_expected_types = tuple_lit.values.len == tuple_info.types.len;
            expected_types = tuple_info.types;
        }
        mut types := []+mut ast.Type();
        for i, value in tuple_lit.values {
            if has_expected_types {
                self.expected_type = expected_types[i];
            }
            value_t := self.check_expr(value);
            types.push(if has_expected_types {
                self.check_types(value_t, expected_types[i]) catch |err| {
                    report.error(err.to_string(), value.position());
                };
                expected_types[i]
            } else {
                value_t
            });
        }
        self.expected_type = old_expected_type;
        tuple_lit.type = +mut .Basic(
            self.env.universe.add_or_get_tuple(types), pos: tuple_lit.pos
        );
        return tuple_lit.type;
    }

    func check_array_literal(+mut self, array_lit: &mut ast.Expr.ArrayLiteral) -> +mut ast.Type {
        old_expected_type := self.expected_type;
        mut size: uint := 0;
        mut is_mut := false;
        mut has_expected_type := false;
        mut value_type := +mut ast.Type.Void;
        if value_sym := self.expected_type.symbol(); value_sym.info is .Array
            || value_sym.info is .DynArray {
            has_expected_type = true;
            value_type = value_sym.info.elem_type()?;
            self.expected_type = value_type;
            if value_sym.info is .Array(array_info) {
                size = array_info.size;
            }
            is_mut = value_sym.info.is_mut_array();
        } else if !self.expected_type.is_void() {
            has_expected_type = true;
            value_type = self.expected_type;
        }
        if has_expected_type {
            value_type = self.env.comptime_number_to_type(value_type);
        }
        for i, value in array_lit.values {
            type := self.check_expr(value);
            if i == 0 && !has_expected_type {
                value_type = self.env.comptime_number_to_type(type);
                self.expected_type = value_type;
            } else {
                self.check_types(type, value_type) catch |err| {
                    err_b := report.error_builder(err.to_string(), value.position());
                    err_b.add_note(if array_lit.is_dyn {
                        "in element {} of dynamic array literal"
                    } else {
                        "in element {} of array literal"
                    }.fmt(i + 1));
                    err_b.emit();
                };
            }
        }
        self.expected_type = old_expected_type;
        array_lit.type = if array_lit.is_dyn {
            +mut .Basic(self.env.universe.add_or_get_dyn_array(value_type, is_mut), pos: array_lit.pos)
        } else {
            arr_len := if array_lit.values.len > 0 {
                array_lit.values.len
            } else {
                if !has_expected_type {
                    report.error("could not infer type and size of array", array_lit.pos);
                }
                size
            };
            +mut .Basic(
                self.env.universe.add_or_get_array(value_type, arr_len, is_mut),
                pos: array_lit.pos
            )
        };
        return array_lit.type;
    }

    func check_selector(+mut self, selector: &mut ast.Expr.Selector) -> +mut ast.Type {
        selector.type = if selector.is_path {
            if selector.left_sym is ast.TypeSym(mut type_sym) {
                if type_sym.info is .Enum(enum_info) {
                    if variant := enum_info.get_variant(selector.field_name); variant.has_type {
                        err := report.error_builder(
                            "variant `{}` cannot be initialized without arguments".fmt(
                                selector.field_name
                            ),
                            selector.pos
                        );
                        err.add_help(
                            "if you intend not to pass any value, add `()`: `{}()`",
                            selector.field_name
                        );
                        err.emit();
                    }
                }
                +mut .Basic(type_sym, pos: selector.pos)
            } else {
                match selector.sym is {
                    ast.Func(mut func_sym) -> {
                        if func_sym.is_method {
                            report.error(
                                "cannot take value of method `{}`".fmt(
                                    selector.field_name
                                ), selector.field_pos
                            );
                        }
                        func_sym.type(self.env.universe)
                    },
                    ast.TypeSym(mut type_sym_) -> +mut .Basic(type_sym_, pos: selector.pos),
                    ast.Const(const_sym) -> const_sym.type,
                    ast.Var(var_sym) -> var_sym.type,
                    else -> {
                        err := report.error_builder(
                            "unexpected bug for selector expression", selector.pos
                        );
                        err.add_note("please report this bug, thanks =D");
                        err.emit();
                        +mut .Void
                    }
                }
            }
        } else {
            selector.left_type = self.check_expr(selector.left);
            if left_sym := selector.left_type.symbol() {
                if field := left_sym.lookup_field(selector.field_name) {
                    selector.found = true;
                    selector.field_is_mut = field.is_mut;
                    field.type
                } else if sym := left_sym.scope.find(selector.field_name) {
                    if sym is ast.Func(mut func_sym) {
                        if func_sym.is_method {
                            err := report.error_builder(
                                "cannot take value of method `{}`".fmt(selector.field_name),
                                selector.field_pos
                            );
                            err.add_help("use parentheses to call the method");
                            err.emit();
                            +mut .Void
                        } else {
                            err := report.error_builder(
                                "cannot take value of associated function `{}`".fmt(
                                    selector.field_name
                                ), selector.field_pos
                            );
                            err.add_help(
                                "use `{}.{}` instead", left_sym.name, selector.field_name
                            );
                            err.emit();
                            func_sym.type(self.env.universe)
                        }
                    } else {
                        report.error(
                            "cannot take value of {} `{}.{}`".fmt(
                                sym.type_of(), left_sym.name, selector.field_name
                            ), selector.pos
                        );
                        +mut .Void
                    }
                } else {
                    err := report.error_builder(
                        "type `{}` has no field `{}`".fmt(
                            left_sym.name, selector.field_name
                        ), selector.field_pos
                    );
                    if selector.field_name.is_digit()
                        && (left_sym.info is .DynArray || left_sym.info is .Array ) {
                        err.add_note(
                            "instead of using tuple indexing, use array indexing: `{}[{}]`"
                                .fmt(selector.left, selector.field_name)
                        );
                    }
                    err.emit();
                    +mut .Void
                }
            } else {
                report.error(
                    "type `{}` has no field `{}`".fmt(
                        selector.left_type, selector.field_name
                    ), selector.field_pos
                );
                +mut .Void
            }
        };
        return selector.type;
    }

    func check_index(+mut self, index: &mut ast.Expr.Index) -> +mut ast.Type {
        index.left_type = self.check_expr(index.left);
        left_sym := index.left_type.symbol()?;
        index_t := self.check_expr(index.index);
        if !(index_t == self.env.comptime_int_t || self.env.is_unsigned_int(index_t)) {
            report.error(
                "expected unsigned integer type, found `{}`".fmt(index_t),
                index.index.position()
            );
        }
        index.type = match left_sym.info.+ {
            .Array, .DynArray, .Slice -> {
                elem_type := left_sym.info.elem_type()?;
                if index.index is .Range {
                    is_mut := left_sym.info.is_mut_array();
                    if left_sym.info is .Slice {
                        index.left_type
                    } else {
                        +mut .Slice(
                            elem_type, is_mut,
                            self.env.universe.add_or_get_slice(elem_type, is_mut)
                        )
                    }
                } else {
                    elem_type
                }
            },
            else -> {
                if !(index.left_type is .Pointer || index.left_type == self.env.string_t) {
                    err := report.error_builder(
                        "type `{}` does not support indexing".fmt(index.left_type),
                        index.pos
                    );
                    err.add_note("only pointers, arrays, dynamic arrays and string supports indexing");
                    err.emit();
                } else if index.left_type is .Pointer(pointer) {
                    if !self.inside_unsafe() {
                        report.error(
                            "pointer indexing is only allowed inside `unsafe` blocks",
                            index.pos
                        );
                    } else if !pointer.is_indexable {
                        report.error("cannot index a non-indexable pointer", index.pos);
                    } else if index.index is .Range {
                        report.error("cannot slice a pointer", index.index.position());
                    }
                }
                if index.left_type == self.env.string_t {
                    if index.index is .Range {
                        err := report.error_builder(
                            "`string` does not support slicing syntax", index.pos
                        );
                        err.add_help("use `.substr()` instead");
                        err.emit();
                    }
                    self.env.uint8_t
                } else {
                    @as(ast.Type.Pointer, index.left_type).inner
                }
            }
        };
        return index.type;
    }

    func check_unary(+mut self, unary: &mut ast.Expr.Unary) -> +mut ast.Type {
        unary.type = self.check_expr(unary.right);
        match unary.op {
            .Bang if unary.type != self.env.bool_t -> report.error(
                "operator `!` can only be used with boolean values", unary.pos
            ),
            .BitNot if !self.env.is_int(unary.type) -> report.error(
                "operator `~` can only be used with numeric values", unary.pos
            ),
            .Minus -> if self.env.is_unsigned_int(unary.type) {
                err := report.error_builder(
                    "cannot apply unary operator `-` to type `{expr.typ}`".fmt(
                        unary.type
                    ), unary.pos
                );
                err.add_note("unsigned values cannot be negated");
                err.emit();
            } else if !(self.env.is_signed_int(unary.type)
                || self.env.is_float(unary.type)) {
                report.error(
                    "operator `-` can only be used with signed integer or float values",
                    unary.pos
                );
            },
            .Plus -> unary.type = +mut .Boxed(unary.type, unary.is_mut_ptr, unary.type.position()),
            .Amp -> {
                mut expected_pointer := false;
                mut indexable_pointer := false;
                if self.expected_type is .Rawptr {
                    expected_pointer = true;
                } else if self.expected_type is .Pointer(ptr) {
                    expected_pointer = true;
                    indexable_pointer = ptr.is_indexable;
                } else if self.expected_type is .Option(opt)
                    && opt.inner is .Pointer(opt_ptr) {
                    expected_pointer = true;
                    indexable_pointer = opt_ptr.is_indexable;
                }
                mut right := unary.right.clean_paren();
                if right is .Index(&mut index) {
                    if index.left_type is .Pointer && !expected_pointer {
                        report.error("cannot take the address of a pointer indexing", unary.pos);
                    }
                    index.is_ref = true;
                } else if unary.type is .Pointer {
                    report.error("cannot take the address of other pointer", unary.pos);
                } else {
                    if unary.is_mut_ptr {
                        self.check_expr_is_mut(right);
                    }
                    right_sym := unary.type.symbol()?;
                    if right_sym.is_boxed() {
                        report.error("cannot take the address of a boxed value", unary.pos);
                    }
                }
                unary.type = +mut .Pointer(unary.type, unary.is_mut_ptr, indexable_pointer);
            },
            else -> {}
        }
        return unary.type;
    }

    func check_binary(+mut self, binary: &mut ast.Expr.Binary) -> +mut ast.Type {
        left_type := self.check_expr(binary.left);
        old_expected_type := self.expected_type;
        self.expected_type = left_type;
        right_type := self.check_expr(binary.right);
        self.expected_type = old_expected_type;

        if binary.op in [.Plus, .Minus, .Mul, .Div, .Mod, .Xor, .Amp, .Pipe] {
            if left_type.is_pointer() {
                err := report.error_builder(
                    "pointer arithmetic is not allowed", binary.pos
                );
                if binary.op == .Plus {
                    err.add_help("use the `ptr_add` builtin function instead");
                } else if binary.op == .Minus {
                    err.add_help("use the `ptr_diff` builtin function instead");
                }
                err.emit();
            }
        } else if left_type is .Option && binary.op !in [.Eq, .Ne, .OrElse] {
            report.error("option values only support `??`, `==` and `!=`", binary.pos);
        } else if left_type is .Option && binary.op != .OrElse && right_type !is .None {
            report.error("option values ​​can only be compared with `none`", binary.pos);
        } else if left_type == self.env.bool_t && right_type == left_type
            && binary.op !in [.Eq, .Ne, .LogicalAnd, .LogicalOr, .Pipe, .Amp] {
            report.error("boolean values only support the following operators: `==`, `!=`, `&&`, `||`, `&` and `|`", binary.pos);
        }

        mut return_type := left_type;
        if left_sym := left_type.symbol() {
            match binary.op {
                .Plus, .Minus, .Mul, .Div, .Mod, .Xor, .Amp, .Pipe -> {
                    mut promoted_type := +mut ast.Type.Void;
                    if left_sym.info.is_compound() {
                        if op_method := left_sym.find_method(binary.op.to_string()) {
                            promoted_type = op_method.ret_type;
                        } else {
                            report.error(
                                "type `{}` does not define operator `{}`".fmt(
                                    left_type, binary.op
                                ), binary.pos
                            );
                        }
                    } else {
                        promoted_type = left_type;
                        if promoted_type is .Void {
                            report.error(
                                "mismatched types `{}` and `{}`".fmt(left_type, right_type),
                                binary.pos
                            );
                        } else if promoted_type is .Option {
                            report.error(
                                "operator `{}` cannot be used with option values".fmt(
                                    binary.op
                                ), binary.pos
                            );
                        }
                    }
                    return_type = promoted_type;
                },
                .OrElse -> {
                    if left_type is .Option(opt) {
                        if !self.check_compatible_types(right_type, opt.inner)
                            && right_type !is .Never {
                            err := report.error_builder(
                                "expected type `{}`, found `{}`".fmt(opt.inner, right_type),
                                binary.right.position()
                            );
                            err.add_note("in right operand for operator `??`");
                            err.emit();
                        }
                        binary.type = opt.inner;
                    } else {
                        report.error(
                            "expected option type in left operand for operator `??`",
                            binary.pos
                        );
                    }
                    if self.scope_returns {
                        self.scope_returns = false;
                    }
                    return binary.type;
                },
                .KwIn, .KwNotIn -> {
                    binary.type = self.env.bool_t;
                    if right_sym := right_type.symbol() {
                        if right_sym.info is .Array || right_sym.info is .DynArray {
                            elem_type := right_sym.info.elem_type()?;
                            op_method := if binary.op == .KwIn { "==" } else { "!=" };
                            if !(left_sym.info.is_primitive()
                                || !(left_sym.info is .Enum(enum_info)
                                && enum_info.is_tagged))
                                && !left_sym.has_method(op_method) {
                                err := report.error_builder(
                                    "cannot use operator `{}` with type `{}`".fmt(
                                        binary.op, left_sym.name
                                    ), binary.pos
                                );
                                err.add_help(
                                    "{} should define the operator `{}`",
                                    elem_type, op_method
                                );
                                err.emit();
                            }
                            self.check_types(left_type, elem_type) catch |err| {
                                report.error(err.to_string(), binary.pos);
                            };
                        } else {
                            report.error(
                                "operator `{}` can only be used with arrays and dynamic arrays".fmt(
                                    binary.op
                                ), binary.pos
                            );
                        }
                    }
                    return binary.type;
                },
                .KwIs, .KwNotIs -> {
                    if !(left_sym.info is .Trait || left_sym.info is .Enum) {
                        report.error(
                            "`{}` can only be used with traits and tagged enums".fmt(
                                binary.op
                            ), binary.left.position()
                        );
                    }
                    if binary.has_var_obj {
                        self.check_name_case(
                            .Snake, "variable", binary.var_obj.name, binary.var_obj.pos
                        );
                        if left_sym.info is .Enum(enum_info) && enum_info.is_tagged {
                            variant := @as(ast.Expr.EnumLiteral, binary.right).variant;
                            if variant.has_type {
                                var_t := if binary.var_obj.is_ref {
                                    if variant.type is .Pointer {
                                        report.error(
                                            "cannot take the address of other pointer", binary.var_obj.pos
                                        );
                                    } else if variant.type.is_boxed() {
                                        report.error(
                                            "cannot take the address of a boxed value", binary.var_obj.pos
                                        );
                                    }
                                    +mut ast.Type.Pointer(variant.type, binary.var_obj.is_mut)
                                } else {
                                    variant.type
                                };
                                binary.var_obj.type = var_t;
                                binary.var_obj.sym.type = var_t;
                            } else {
                                report.error(
                                    "variant `{}` has no value".fmt(binary.right),
                                    binary.right.position()
                                );
                            }
                        } else if left_sym.info is .Trait {
                            // trait value
                            binary.var_obj.type = right_type;
                            binary.var_obj.sym.type = right_type;
                        }
                        if binary.var_obj.is_mut {
                            self.check_expr_is_mut(binary.left);
                            if !binary.var_obj.is_ref {
                                binary.var_obj.sym.is_hidden_ref = true;
                            }
                        }
                    }
                    if left_sym.info is .Enum(enum_info) {
                        if enum_info.is_tagged && binary.op !in [.KwIs, .KwNotIs] {
                            report.error(
                                "tagged enum types only support `is` and `!is`", binary.pos
                            );
                        } else if !enum_info.is_tagged && binary.op !in [.Eq, .Ne] {
                            report.error(
                                "enum types only support `==` and `!=`", binary.pos
                            );
                        }
                    }
                    binary.type = self.env.bool_t;
                    return binary.type;
                },
                .LogicalAnd, .LogicalOr -> {
                    if left_type != self.env.bool_t {
                        report.error(
                            "non-boolean expression in left operand for `{}`".fmt(binary.op),
                            binary.left.position()
                        );
                    } else if right_type != self.env.bool_t {
                        report.error(
                            "non-boolean expression in right operand for `{}`".fmt(binary.op),
                            binary.left.position()
                        );
                    } else if binary.left is .Binary(bin_left) {
                        if bin_left.op != binary.op && bin_left.op in [.LogicalAnd, .LogicalOr] {
                            // use `(a && b) || c` instead of `a && b || c`
                            err := report.error_builder(
                                "ambiguous boolean expression", binary.pos
                            );
                            err.add_help(
                                "use `({}) -> {} {}` instead", binary.left, binary.op,
                                binary.right
                            );
                            err.emit();
                        }
                    }
                    binary.type = self.env.bool_t;
                    return binary.type;
                },
                .Lshift, .Rshift -> {
                    if !self.env.is_int(left_type) {
                        report.error(
                            "shift on non-integer type `{}`".fmt(left_type),
                            binary.left.position()
                        );
                    } else if !self.env.is_int(right_type) {
                        report.error(
                            "cannot shift non-integer type `{}` into type `{}`".fmt(
                                right_type, left_type
                            ), binary.left.position()
                        );
                    } else if binary.op == .Lshift && self.env.is_signed_int(left_type)
                        && !self.inside_unsafe() {
                        report.warn(
                            "shifting a value from a signed type `{}` can change the sign"
                                .fmt(left_type),
                            binary.left.position()
                        );
                    }
                    binary.type = left_type;
                    return binary.type;
                },
                else -> {}
            }
        }

        binary.type = if binary.op.is_relational() {
            self.env.bool_t
        } else {
            return_type
        };
        return binary.type;
    }

    func check_if(+mut self, if_expr: &mut ast.Expr.If) -> +mut ast.Type {
        if_expr.expected_type = self.expected_type;
        for i, &mut branch in if_expr.branches {
            if !branch.is_else {
                bcond_t := self.check_expr(branch.cond);
                if branch.cond !is .Guard && bcond_t != self.env.bool_t {
                    report.error(
                        "non-boolean expression used as `if` condition",
                        branch.cond.position()
                    );
                }
            }
            mut branch_t := +mut ast.Type.Void;
            if i == 0 {
                branch_t = self.check_expr(branch.expr);
                if if_expr.expected_type is .Void {
                    if_expr.expected_type = branch_t;
                }
                if_expr.type = branch_t;
            } else {
                old_expected_type := self.expected_type;
                self.expected_type = if_expr.expected_type;
                branch_t = self.check_expr(branch.expr);
                self.expected_type = old_expected_type;
                self.check_types(branch_t, if_expr.expected_type) catch |err| {
                    report.error(err.to_string(), branch.expr.position());
                };
            }
            branch.type = branch_t;
        }
        if !if_expr.type.is_void() && !if_expr.has_else {
            report.error("`if` expression needs an `else` branch", if_expr.pos);
        }
        return if_expr.expected_type;
    }

    func check_return(+mut self, return_expr: &ast.Expr.Return) -> +mut ast.Type {
        if self.cur_func.ret_type is .Never {
            report.error("`never` functions cannot use `return` statements", return_expr.pos);
        } else if self.return_tracker == .Defer {
            report.error("`return` is not allowed inside `defer` statement", return_expr.pos);
        } else if self.inside_test && return_expr.has_expr {
            report.error("cannot return values inside `test` declaration", return_expr.pos);
        } else if return_expr.has_expr {
            if self.cur_func.ret_type is .Void {
                report.error(
                    "{} `{}` should not return a value".fmt(
                        self.cur_func.kind(), self.cur_func.name
                    ), return_expr.expr.position()
                );
            } else {
                old_expected_type := self.expected_type;
                self.expected_type = if self.cur_func.ret_type is .Result(res_t) {
                    res_t.inner
                } else {
                    self.cur_func.ret_type
                };
                expr_type := self.check_expr(return_expr.expr);
                self.expected_type = old_expected_type;
                self.check_types(expr_type, self.cur_func.ret_type) catch |err| {
                    err_b := report.error_builder(
                        err.to_string(), return_expr.expr.position()
                    );
                    err_b.add_note(
                        "in return of {} `{}`", self.cur_func.kind(),
                        self.cur_func.name
                    );
                    err_b.emit();
                };
            }
        } else if !(
            self.cur_func.ret_type is .Void
            || (self.cur_func.ret_type is .Result(res_t) && res_t.inner is .Void)
        ) {
            err := report.error_builder(
                "expected `{}` value in return argument".fmt(self.cur_func.ret_type),
                return_expr.pos
            );
            err.add_note("in return of {} `{}`", self.cur_func.kind(), self.cur_func.name);
            err.emit();
        }
        self.scope_returns = true;
        return +mut .Never(return_expr.pos);
    }

    func check_throw(+mut self, throw_expr: &ast.Expr.Throw) -> +mut ast.Type {
        if self.cur_func.ret_type is .Never {
            report.error("`never` functions cannot use `throw` statements", throw_expr.pos);
        } else if self.return_tracker == .Defer {
            report.error("`throw` is not allowed inside `defer` statement", throw_expr.pos);
        } else if self.inside_test {
            report.error("cannot throw errors inside `test` declaration", throw_expr.pos);
        } else if self.cur_func.ret_type is .Result {
            expr_type := self.check_expr(throw_expr.expr);
            expr_sym := expr_type.symbol()?;
            if !(expr_sym == self.env.throwable_sym
                || expr_sym.implement_trait(self.env.throwable_sym)
            ) {
                err_b := report.error_builder(
                    "using an invalid value as an error to throw",
                    throw_expr.expr.position()
                );
                err_b.add_note(
                    "in order to use that value, type `{}` should implement the `Throwable` trait".fmt(expr_type)
                );
                err_b.add_note(
                    "in throw argument of {} `{}`", self.cur_func.kind(),
                    self.cur_func.name
                );
                err_b.emit();
            }
        } else {
            err_b := report.error_builder(
                "{} `{}` cannot throws errors".fmt(
                    self.cur_func.kind(), self.cur_func.name
                ), throw_expr.expr.position()
            );
            err_b.add_note("if you want to throw errors, add `!` in front of the return type");
            err_b.emit();
        }
        self.scope_returns = true;
        return +mut .Never(throw_expr.pos);
    }

    func check_assign(+mut self, assign: &mut ast.Expr.Assign) -> +mut ast.Type {
        left_type := self.check_expr(assign.left);
        self.check_expr_is_mut(assign.left, true);
        old_expected_type := self.expected_type;
        self.expected_type = left_type;
        right_type := self.check_expr(assign.right);
        self.expected_type = old_expected_type;
        if assign.left is .Ident(ident) && ident.name == "_" {
            return +mut .Void;
        }
        self.check_types(right_type, left_type) catch |err| {
            report.error(err.to_string(), assign.right.position());
        };
        return +mut .Void;
    }
}
