// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../report;

extend Checker {
    func check_expr(mut self, mut expr: ast.Expr) -> ast.Type {
        return match expr is {
            .Empty -> .Void(),
            .Type as type -> type,
            .Branch as branch -> {
                self.scope_returns = true;
                .Never(branch.pos)
            },
            .Paren as paren -> self.check_expr(paren.expr),
            .NoneLiteral -> .None(),
            .BoolLiteral -> self.table.bool_t,
            .CharLiteral as char_lit -> {
                char_lit.type = if char_lit.is_byte {
                    self.table.uint8_t
                } else {
                    self.table.rune_t
                };
                char_lit.type
            },
            .IntegerLiteral as int_lit -> {
                int_lit.type = self.table.comptime_int_t;
                int_lit.type
            },
            .FloatLiteral as float_lit -> {
                float_lit.type = self.table.comptime_float_t;
                float_lit.type
            },
            .StringLiteral as string_lit -> {
                string_lit.type = if string_lit.is_bytestr {
                    .Basic(self.table.universe.add_or_get_array(
                        self.table.uint8_t, string_lit.value.len, false
                    ))
                } else if string_lit.is_cstr {
                    .Pointer(self.table.uint8_t, is_indexable: true)
                } else {
                    self.table.string_t
                };
                string_lit.type
            },
            .SelfLiteral as self_lit -> {
                self_lit.type = self_lit.obj.type;
                self_lit.type
            },
            .SelfTy -> .Void(),
            .EnumLiteral as enum_lit -> {
                enum_lit.type = .Void();
                if sym := self.expected_type.symbol(); sym.info is .Enum as enum_info {
                    if variant := enum_info.get_variant(enum_lit.value) {
                        enum_lit.sym = sym;
                        enum_lit.variant = variant;
                        enum_lit.type = .Basic(sym, pos: enum_lit.pos);
                        if enum_info.is_boxed and !enum_lit.from_is_cmp
                            and !enum_lit.is_instance {
                            mut err := report.error_builder(
                                "cannot use variant `.{}` as a simple value".fmt(
                                    enum_lit.value
                                ), enum_lit.pos
                            );
                            err.add_note(
                                "make an instance instead: `.{}()`", enum_lit.value
                            );
                            err.emit();
                        }
                    } else {
                        report.error(
                            "enum `{}` has no variant `{}`".fmt(sym.name, enum_lit.value),
                            enum_lit.pos
                        );
                    }
                } else {
                    report.error("`{}` is not a enum".fmt(self.expected_type), enum_lit.pos);
                }
                enum_lit.type
            },
            .TupleLiteral as mut tuple_lit -> self.check_tuple_literal(tuple_lit),
            .DynArrayLiteral as mut vec_lit -> self.check_dyn_array_literal(vec_lit),
            .Ident as ident -> {
                ident.type = if ident.name == "_" {
                    .Void()
                } else if ident.is_comptime {
                    ident.builtin.type()
                } else if ident.is_sym or ident.is_obj {
                    match ident.sym is {
                        ast.Const as const_sym -> const_sym.type,
                        ast.Var as var_sym -> var_sym.type,
                        ast.Func as func_sym -> {
                            if func_sym.abi != .Rivet {
                                mut err := report.error_builder(
                                    "cannot use an extern function as a value", ident.pos
                                );
                                err.add_help("wrap the extern function with a function");
                                err.emit();
                            }
                            func_sym.type(self.table.universe)
                        },
                        else -> .Void()
                    }
                } else {
                    .Void()
                };
                ident.type
            },
            .Selector as mut selector -> self.check_selector(selector),
            .Indirect as indirect -> {
                indirect.left_type = self.check_expr(indirect.left);
                indirect.type = if indirect.left_type.is_pointer()
                    or (indirect.left_type is .Pointer as ptr and !ptr.is_indexable)
                    or indirect.left_type is .Rawptr  {
                	indirect.is_mut = indirect.left_type.is_pointer();
                    indirect.left_type.ptr_or_ref_inner()
                } else {
                    mut err := report.error_builder(
                        "invalid indirect for `{}`".fmt(indirect.left_type), indirect.pos
                    );
                    if indirect.left_type is .Rawptr {
                        err.add_help(
                            "consider casting this to another pointer type, e.g. `*uint8`"
                        );
                    } else if indirect.left_type is .Pointer as ptr2 and ptr2.is_indexable {
                        err.add_help("use index access to element 0 instead");
                    }
                    err.emit();
                    .Void()
                };
                indirect.type
            },
            .OptionCheck as option_check -> {
            	option_check.left_type = self.check_expr(option_check.left);
                option_check.type = if option_check.left_type is .Option as opt {
                    opt.inner
                } else {
                    report.error("cannot check a non-option value", option_check.left.position());
                    .Void()
                };
                option_check.type
            },
            .Range as range -> {
                range.type = if range.has_start {
                    self.check_expr(range.start)
                } else {
                    self.table.uint_t
                };
                end_type := if range.has_end {
                    self.check_expr(range.end)
                } else {
                    self.table.uint_t
                };
                if !(self.table.is_int(range.type) or self.table.is_int(end_type)) {
                    report.error("non-integer value used as range", range.pos);
                }
                range.type
            },
            .Index as mut index -> self.check_index(index),
            .Call as mut call_expr -> self.check_call(call_expr),
            .BuiltinCall as mut builtin_call -> self.check_builtin_call(builtin_call),
            .Block as block -> {
                self.defer_stmts_start = self.defer_stmts.len;
                if block.is_unsafe {
                    if self.inside_unsafe_block {
                        report.warn("unnecessary `unsafe` block", block.pos);
                    } else {
                        self.inside_unsafe_block = true;
                    }
                }
                old_expected_type := self.expected_type;
                self.expected_type = .Void();
                self.check_stmts(block.stmts);
                self.expected_type = old_expected_type;
                block.type = if block.is_expr {
                    self.check_expr(block.expr)
                } else {
                    .Void()
                };
                if block.type is .Void and block.is_expr {
                    // if the expression has no value then it is another statement
                    block.stmts.push(.Expr(block.expr, block.pos));
                    block.is_expr = false;
                }
                if block.is_unsafe {
                    if self.unsafe_operations == 0 {
                        report.warn("unnecessary `unsafe` block", block.pos);
                    } else {
                        self.unsafe_operations = 0;
                    }
                    self.inside_unsafe_block = false;
                }
                block.defer_stmts = self.defer_stmts[self.defer_stmts_start..];
                self.defer_stmts = self.defer_stmts[..self.defer_stmts_start];
                block.type
            },
            .Unary as mut unary -> self.check_unary(unary),
            .Binary as mut binary -> self.check_binary(binary),
            .If as mut if_expr -> self.check_if(if_expr),
            .Match as mut match_expr -> self.check_match(match_expr),
            .Guard as guard -> {
                old_inside_guard_expr := self.inside_guard_expr;
                self.inside_guard_expr = true;
                self.check_var_decl(guard.vars, guard.expr, guard.scope, guard.pos);
                if guard.has_cond and self.check_expr(guard.cond) != self.table.bool_t {
                    report.error(
                        "non-boolean expression used as guard condition",
                        guard.cond.position()
                    );
                }
                self.inside_guard_expr = old_inside_guard_expr;
                .Void()
            },
            .Return as mut return_expr -> self.check_return(return_expr),
            .Throw as mut throw_expr -> self.check_throw(throw_expr),
            .Assign as mut assign -> self.check_assign(assign)
        };
    }

    func check_tuple_literal(mut self, mut tuple_lit: ast.Expr.TupleLiteral) -> ast.Type {
        old_expected_type := self.expected_type;
        mut has_expected_types := false;
        mut expected_types := @vec(ast.Type);
        if expected_type_sym := self.expected_type.symbol(); expected_type_sym.info is .Tuple as tuple_info {
            has_expected_types = tuple_lit.values.len == tuple_info.types.len;
            expected_types = tuple_info.types;
        }
        mut types := @vec(ast.Type);
        for i, mut value in tuple_lit.values {
            if has_expected_types {
                self.expected_type = expected_types[i];
            }
            value_t := self.check_expr(value);
            types.push(if has_expected_types {
                self.check_types(value_t, expected_types[i]) catch |err| {
                    report.error(err.to_string(), value.position());
                };
                expected_types[i]
            } else {
                value_t
            });
        }
        self.expected_type = old_expected_type;
        tuple_lit.type = .Basic(
            self.table.universe.add_or_get_tuple(types), pos: tuple_lit.pos
        );
        return tuple_lit.type;
    }

    func check_dyn_array_literal(mut self, mut vec_lit: ast.Expr.DynArrayLiteral) -> ast.Type {
        old_expected_type := self.expected_type;
        mut size: uint := 0;
        mut is_mut := false;
        mut has_expected_type := false;
        mut value_type := ast.Type.Void();
        if value_sym := self.expected_type.symbol(); value_sym.info is .Array
            or value_sym.info is .DynArray {
            has_expected_type = true;
            value_type = value_sym.info.elem_type()?;
            self.expected_type = value_type;
            if value_sym.info is .Array as array_info {
                size = array_info.size;
            }
            is_mut = value_sym.info.is_mut_arr_or_vec();
        } else if !self.expected_type.is_void() {
            has_expected_type = true;
            value_type = self.expected_type;
        }
        if has_expected_type {
            value_type = self.table.comptime_number_to_type(value_type);
        }
        for i, mut value in vec_lit.values {
            type := self.check_expr(value);
            if i == 0 and !has_expected_type {
                value_type = self.table.comptime_number_to_type(type);
                self.expected_type = value_type;
            } else {
                self.check_types(type, value_type) catch |err| {
                    mut err_b := report.error_builder(err.to_string(), value.position());
                    err_b.add_note(if vec_lit.is_arr {
                        "in element {} of array literal"
                    } else {
                        "in element {} of dynamic array literal"
                    }.fmt(i + 1));
                    err_b.emit();
                };
            }
        }
        self.expected_type = old_expected_type;
        vec_lit.type = if vec_lit.is_arr {
            arr_len := if vec_lit.values.len > 0 {
                vec_lit.values.len
            } else {
                if !has_expected_type {
                    report.error("could not infer type and size of array", vec_lit.pos);
                }
                size
            };
            .Basic(
                self.table.universe.add_or_get_array(value_type, arr_len, is_mut),
                pos: vec_lit.pos
            )
        } else {
            .Basic(self.table.universe.add_or_get_dyn_array(value_type, is_mut), pos: vec_lit.pos)
        };
        return vec_lit.type;
    }

    func check_selector(mut self, mut selector: ast.Expr.Selector) -> ast.Type {
        selector.type = if selector.is_path {
            if selector.left_sym is ast.TypeSym as type_sym {
                .Basic(type_sym, pos: selector.pos)
            } else {
                match selector.sym is {
                    ast.Func as func_sym -> {
                        if func_sym.is_method {
                            report.error(
                                "cannot take value of method `{}`".fmt(
                                    selector.field_name
                                ), selector.field_pos
                            );
                        }
                        func_sym.type(self.table.universe)
                    },
                    ast.TypeSym as type_sym_ -> .Basic(type_sym_, pos: selector.pos),
                    ast.Const as const_sym -> const_sym.type,
                    ast.Var as var_sym -> var_sym.type,
                    else -> {
                        mut err := report.error_builder(
                            "unexpected bug for selector expression", selector.pos
                        );
                        err.add_note("please report this bug, thanks =D");
                        err.emit();
                        .Void()
                    }
                }
            }
        } else {
            selector.left_type = self.check_expr(selector.left);
            if left_sym := selector.left_type.symbol() {
                if field := left_sym.lookup_field(selector.field_name) {
                    selector.found = true;
                    selector.field_is_mut = field.is_mut;
                    field.type
                } else if sym := left_sym.scope.find(selector.field_name) {
                    if sym is ast.Func as func_sym {
                        if func_sym.is_method {
                            mut err := report.error_builder(
                                "cannot take value of method `{}`".fmt(selector.field_name),
                                selector.field_pos
                            );
                            err.add_help("use parentheses to call the method");
                            err.emit();
                            .Void()
                        } else {
                            mut err := report.error_builder(
                                "cannot take value of associated function `{}`".fmt(
                                    selector.field_name
                                ), selector.field_pos
                            );
                            err.add_help(
                                "use `{}.{}` instead", left_sym.name, selector.field_name
                            );
                            err.emit();
                            func_sym.type(self.table.universe)
                        }
                    } else {
                        report.error(
                            "cannot take value of {} `{}.{}`".fmt(
                                sym.type_of(), left_sym.name, selector.field_name
                            ), selector.pos
                        );
                        .Void()
                    }
                } else {
                    mut err := report.error_builder(
                        "type `{}` has no field `{}`".fmt(
                            left_sym.name, selector.field_name
                        ), selector.field_pos
                    );
                    if selector.field_name.is_digit()
                        and (left_sym.info is .DynArray or left_sym.info is .Array ) {
                        err.add_note(
                            "instead of using tuple indexing, use array indexing: `{}[{}]`"
                                .fmt(selector.left, selector.field_name)
                        );
                    }
                    err.emit();
                    .Void()
                }
            } else {
                report.error(
                    "type `{}` has no field `{}`".fmt(
                        selector.left_type, selector.field_name
                    ), selector.field_pos
                );
                .Void()
            }
        };
        return selector.type;
    }

    func check_index(mut self, mut index: ast.Expr.Index) -> ast.Type {
        index.left_type = self.check_expr(index.left);
        left_sym := index.left_type.symbol()?;
        index_t := self.check_expr(index.index);
        if !(index_t == self.table.comptime_int_t or self.table.is_unsigned_int(index_t)) {
            report.error(
                "expected unsigned integer type, found `{}`".fmt(index_t),
                index.index.position()
            );
        }
        index.type = match left_sym.info is {
            .Array, .DynArray -> {
                elem_type := left_sym.info.elem_type()?;
                if index.index is .Range {
                    is_mut := left_sym.info.is_mut_arr_or_vec();
                    if left_sym.info is .DynArray {
                        index.left_type
                    } else {
                        .DynArray(
                            elem_type, is_mut,
                            self.table.universe.add_or_get_dyn_array(elem_type, is_mut)
                        )
                    }
                } else {
                    elem_type
                }
            },
            else -> {
                if !(index.left_type is .Pointer or index.left_type == self.table.string_t) {
                    mut err := report.error_builder(
                        "type `{}` does not support indexing".fmt(index.left_type),
                        index.pos
                    );
                    err.add_note("only pointers, arrays, dynamic arrays and string supports indexing");
                    err.emit();
                } else if index.left_type is .Pointer as pointer {
                    if !self.inside_unsafe() {
                        report.error(
                            "pointer indexing is only allowed inside `unsafe` blocks",
                            index.pos
                        );
                    } else if !pointer.is_indexable {
                        report.error("cannot index a non-indexable pointer", index.pos);
                    } else if index.index is .Range {
                        report.error("cannot slice a pointer", index.index.position());
                    }
                }
                if index.left_type == self.table.string_t {
                    if index.index is .Range {
                        self.table.string_t
                    } else {
                        self.table.uint8_t
                    }
                } else {
                    @as(ast.Type.Pointer, index.left_type).inner
                }
            }
        };
        return index.type;
    }

    func check_unary(mut self, mut unary: ast.Expr.Unary) -> ast.Type {
        unary.type = self.check_expr(unary.right);
        match unary.op {
            .Bang if unary.type != self.table.bool_t -> report.error(
                "operator `!` can only be used with boolean values", unary.pos
            ),
            .BitNot if !self.table.is_int(unary.type) -> report.error(
                "operator `~` can only be used with numeric values", unary.pos
            ),
            .Minus -> if self.table.is_unsigned_int(unary.type) {
                mut err := report.error_builder(
                    "cannot apply unary operator `-` to type `{expr.typ}`".fmt(
                        unary.type
                    ), unary.pos
                );
                err.add_note("unsigned values cannot be negated");
                err.emit();
            } else if !(self.table.is_signed_int(unary.type)
                or self.table.is_float(unary.type)) {
                report.error(
                    "operator `-` can only be used with signed integer or float values",
                    unary.pos
                );
            },
            .Amp -> {
                mut expected_pointer := false;
                mut indexable_pointer := false;
                if self.expected_type is .Rawptr {
                    expected_pointer = true;
                } else if self.expected_type is .Pointer as ptr {
                    expected_pointer = true;
                    indexable_pointer = ptr.is_indexable;
                } else if self.expected_type is .Option as opt
                    and opt.inner is .Pointer as opt_ptr {
                    expected_pointer = true;
                    indexable_pointer = opt_ptr.is_indexable;
                }
                right := unary.right.clean_paren();
                if right is .Index as index {
                    if index.left_type is .Pointer and !expected_pointer {
                        report.error("cannot take the address of a pointer indexing", unary.pos);
                    }
                    index.is_ref = true;
                } else if unary.type is .Pointer {
                    report.error("cannot take the address of other pointer", unary.pos);
                } else {
                    if unary.is_mut_ptr {
                        self.check_expr_is_mut(right);
                    }
                    right_sym := unary.type.symbol()?;
                    if right_sym.is_boxed() {
                        report.error("cannot take the address of a boxed value", unary.pos);
                    }
                }
                unary.type = .Pointer(unary.type, unary.is_mut_ptr, indexable_pointer);
            },
            else -> {}
        }
        return unary.type;
    }

    func check_binary(mut self, mut binary: ast.Expr.Binary) -> ast.Type {
        left_type := self.check_expr(binary.left);
        old_expected_type := self.expected_type;
        self.expected_type = left_type;
        right_type := self.check_expr(binary.right);
        self.expected_type = old_expected_type;

        if binary.op in [.Plus, .Minus, .Mul, .Div, .Mod, .Xor, .Amp, .Pipe] {
            if left_type.is_pointer() {
                mut err := report.error_builder(
                    "pointer arithmetic is not allowed", binary.pos
                );
                if binary.op == .Plus {
                    err.add_help("use the `ptr_add` builtin function instead");
                } else if binary.op == .Minus {
                    err.add_help("use the `ptr_diff` builtin function instead");
                }
                err.emit();
            }
        } else if left_type is .Option and binary.op !in [.KwIs, .KwNotIs, .OrElse] {
            report.error("option values only support `??`, `is` and `!is`", binary.pos);
        } else if left_type == self.table.bool_t and right_type == left_type
            and binary.op !in [.Eq, .Ne, .KwAnd, .KwOr, .Pipe, .Amp] {
            report.error("boolean values only support the following operators: `==`, `!=`, `and`, `or`, `&` and `|`", binary.pos);
        }

        mut return_type := left_type;
        if left_sym := left_type.symbol() {
            match binary.op {
                .Plus, .Minus, .Mul, .Div, .Mod, .Xor, .Amp, .Pipe -> {
                    mut promoted_type := ast.Type.Void();
                    if left_sym.info.is_compound() {
                        if op_method := left_sym.find_method(binary.op.to_string()) {
                            promoted_type = op_method.ret_type;
                        } else {
                            report.error(
                                "type `{}` does not define operator `{}`".fmt(
                                    left_type, binary.op
                                ), binary.pos
                            );
                        }
                    } else {
                        promoted_type = self.promote(left_type, right_type);
                        if promoted_type is .Void {
                            report.error(
                                "mismatched types `{}` and `{}`".fmt(left_type, right_type),
                                binary.pos
                            );
                        } else if promoted_type is .Option {
                            report.error(
                                "operator `{}` cannot be used with option values".fmt(
                                    binary.op
                                ), binary.pos
                            );
                        }
                    }
                    return_type = promoted_type;
                },
                .OrElse -> {
                    if left_type is .Option as opt {
                        if !self.check_compatible_types(right_type, opt.inner)
                            and right_type !is .Never {
                            mut err := report.error_builder(
                                "expected type `{}`, found `{}`".fmt(opt.inner, right_type),
                                binary.right.position()
                            );
                            err.add_note("in right operand for operator `??`");
                            err.emit();
                        }
                        binary.type = opt.inner;
                    } else {
                        report.error(
                            "expected option type in left operand for operator `??`",
                            binary.pos
                        );
                    }
                    if self.scope_returns {
                        self.scope_returns = false;
                    }
                    return binary.type;
                },
                .KwIn, .KwNotIn -> {
                    binary.type = self.table.bool_t;
                    if right_sym := right_type.symbol() {
                        if right_sym.info is .Array or right_sym.info is .DynArray {
                            elem_type := right_sym.info.elem_type()?;
                            op_method := if binary.op == .KwIn { "==" } else { "!=" };
                            if !(left_sym.info.is_primitive()
                                or !(left_sym.info is .Enum as enum_info
                                and enum_info.is_boxed))
                                and !left_sym.has_method(op_method) {
                                mut err := report.error_builder(
                                    "cannot use operator `{}` with type `{}`".fmt(
                                        binary.op, left_sym.name
                                    ), binary.pos
                                );
                                err.add_help(
                                    "{} should define the operator `{}`",
                                    elem_type, op_method
                                );
                                err.emit();
                            }
                            self.check_types(left_type, elem_type) catch |err| {
                                report.error(err.to_string(), binary.pos);
                            };
                        } else {
                            report.error(
                                "operator `{}` can only be used with arrays and dynamic arrays".fmt(
                                    binary.op
                                ), binary.pos
                            );
                        }
                    }
                    return binary.type;
                },
                .KwIs, .KwNotIs -> {
                    if !((left_sym.info is .Trait or left_sym.info is .Enum)
                        or left_type is .Option) {
                        report.error(
                            "`{}` can only be used with traits, enums and options".fmt(
                                binary.op
                            ), binary.left.position()
                        );
                    }
                    if binary.has_var_obj {
                        self.check_name_case(
                            .Snake, "variable", binary.var_obj.name, binary.var_obj.pos
                        );
                        if left_sym.info is .Enum as enum_info and enum_info.is_boxed {
                            variant := @as(ast.Expr.EnumLiteral, binary.right).variant;
                            if variant.has_type {
                                binary.var_obj.type = variant.type;
                                binary.var_obj.sym.type = variant.type;
                            } else {
                                report.error(
                                    "variant `{}` has no value".fmt(binary.right),
                                    binary.right.position()
                                );
                            }
                        } else if left_sym.info is .Trait {
                            // trait value
                            binary.var_obj.type = right_type;
                            binary.var_obj.sym.type = right_type;
                        }
                        if binary.var_obj.is_mut {
                            binary.var_obj.sym.is_hidden_ref = true;
                        }
                    }
                    if left_sym.info is .Enum as enum_info {
                        if enum_info.is_boxed and binary.op !in [.KwIs, .KwNotIs] {
                            report.error(
                                "boxed enum types only support `is` and `!is`", binary.pos
                            );
                        } else if !enum_info.is_boxed and binary.op !in [.Eq, .Ne] {
                            report.error(
                                "enum types only support `==` and `!=`", binary.pos
                            );
                        }
                    }
                    binary.type = self.table.bool_t;
                    return binary.type;
                },
                .KwAnd, .KwOr -> {
                    if left_type != self.table.bool_t {
                        report.error(
                            "non-boolean expression in left operand for `{}`".fmt(binary.op),
                            binary.left.position()
                        );
                    } else if right_type != self.table.bool_t {
                        report.error(
                            "non-boolean expression in right operand for `{}`".fmt(binary.op),
                            binary.left.position()
                        );
                    } else if binary.left is .Binary as bin_left {
                        if bin_left.op != binary.op and bin_left.op in [.KwAnd, .KwOr] {
                            // use `(a and b) or c` instead of `a and b or c`
                            mut err := report.error_builder(
                                "ambiguous boolean expression", binary.pos
                            );
                            err.add_help(
                                "use `({}) -> {} {}` instead", binary.left, binary.op,
                                binary.right
                            );
                            err.emit();
                        }
                    }
                    binary.type = self.table.bool_t;
                    return binary.type;
                },
                .Lshift, .Rshift -> {
                    if !self.table.is_int(left_type) {
                        report.error(
                            "shift on non-integer type `{}`".fmt(left_type),
                            binary.left.position()
                        );
                    } else if !self.table.is_int(right_type) {
                        report.error(
                            "cannot shift non-integer type `{}` into type `{}`".fmt(
                                right_type, left_type
                            ), binary.left.position()
                        );
                    } else if binary.op == .Lshift and self.table.is_signed_int(left_type)
                        and !self.inside_unsafe() {
                        report.warn(
                            "shifting a value from a signed type `{}` can change the sign"
                                .fmt(left_type),
                            binary.left.position()
                        );
                    }
                    binary.type = left_type;
                    return binary.type;
                },
                else -> {}
            }
        }

        binary.type = if binary.op.is_relational() {
            self.table.bool_t
        } else {
            return_type
        };
        return binary.type;
    }

    func check_if(mut self, mut if_expr: ast.Expr.If) -> ast.Type {
        if_expr.expected_type = self.expected_type;
        for i, branch in if_expr.branches {
            if !branch.is_else {
                bcond_t := self.check_expr(branch.cond);
                if branch.cond !is .Guard and bcond_t != self.table.bool_t {
                    report.error(
                        "non-boolean expression used as `if` condition",
                        branch.cond.position()
                    );
                }
            }
            mut branch_t := ast.Type.Void();
            if i == 0 {
                branch_t = self.check_expr(branch.expr);
                if if_expr.expected_type is .Void {
                    if_expr.expected_type = branch_t;
                }
                if_expr.type = branch_t;
            } else {
                old_expected_type := self.expected_type;
                self.expected_type = if_expr.expected_type;
                branch_t = self.check_expr(branch.expr);
                self.expected_type = old_expected_type;
                self.check_types(branch_t, if_expr.expected_type) catch |err| {
                    report.error(err.to_string(), branch.expr.position());
                };
            }
            branch.type = branch_t;
        }
        if !if_expr.type.is_void() and !if_expr.has_else {
            report.error("`if` expression needs an `else` branch", if_expr.pos);
        }
        return if_expr.expected_type;
    }

    func check_return(mut self, mut return_expr: ast.Expr.Return) -> ast.Type {
        if self.cur_fn.ret_type is .Never {
            report.error("`never` functions cannot use `return` statements", return_expr.pos);
        } else if self.inside_defer {
            report.error("`return` is not allowed inside `defer` statement", return_expr.pos);
        } else if self.inside_test and return_expr.has_expr {
            report.error("cannot return values inside `test` declaration", return_expr.pos);
        } else if return_expr.has_expr {
            if self.cur_fn.ret_type is .Void {
                report.error(
                    "{} `{}` should not return a value".fmt(
                        self.cur_fn.kind(), self.cur_fn.name
                    ), return_expr.expr.position()
                );
            } else {
                old_expected_type := self.expected_type;
                self.expected_type = if self.cur_fn.ret_type is .Result as res_t {
                    res_t.inner
                } else {
                    self.cur_fn.ret_type
                };
                expr_type := self.check_expr(return_expr.expr);
                self.expected_type = old_expected_type;
                self.check_types(expr_type, self.cur_fn.ret_type) catch |err| {
                    mut err_b := report.error_builder(
                        err.to_string(), return_expr.expr.position()
                    );
                    err_b.add_note(
                        "in return of {} `{}`", self.cur_fn.kind(),
                        self.cur_fn.name
                    );
                    err_b.emit();
                };
            }
        } else if !(
            self.cur_fn.ret_type is .Void
            or (self.cur_fn.ret_type is .Result as res_t and res_t.inner is .Void)
        ) {
            mut err := report.error_builder(
                "expected `{}` value in return argument".fmt(self.cur_fn.ret_type),
                return_expr.pos
            );
            err.add_note("in return of {} `{}`", self.cur_fn.kind(), self.cur_fn.name);
            err.emit();
        }
        self.scope_returns = true;
        return .Never(return_expr.pos);
    }

    func check_throw(mut self, mut throw_expr: ast.Expr.Throw) -> ast.Type {
        if self.cur_fn.ret_type is .Never {
            report.error("`never` functions cannot use `throw` statements", throw_expr.pos);
        } else if self.inside_defer {
            report.error("`throw` is not allowed inside `defer` statement", throw_expr.pos);
        } else if self.inside_test {
            report.error("cannot throw errors inside `test` declaration", throw_expr.pos);
        } else if self.cur_fn.ret_type is .Result {
            expr_type := self.check_expr(throw_expr.expr);
            expr_sym := expr_type.symbol()?;
            if !(expr_sym == self.table.throwable_sym
                or expr_sym.implement_trait(self.table.throwable_sym)
            ) {
                mut err_b := report.error_builder(
                    "using an invalid value as an error to throw",
                    throw_expr.expr.position()
                );
                err_b.add_note(
                    "in order to use that value, type `{}` should implement the `Throwable` trait".fmt(expr_type)
                );
                err_b.add_note(
                    "in throw argument of {} `{}`", self.cur_fn.kind(),
                    self.cur_fn.name
                );
                err_b.emit();
            }
        } else {
            mut err_b := report.error_builder(
                "{} `{}` cannot throws errors".fmt(
                    self.cur_fn.kind(), self.cur_fn.name
                ), throw_expr.expr.position()
            );
            err_b.add_note("if you want to throw errors, add `!` in front of the return type");
            err_b.emit();
        }
        self.scope_returns = true;
        return .Never(throw_expr.pos);
    }

    func check_assign(mut self, mut assign: ast.Expr.Assign) -> ast.Type {
        left_type := self.check_expr(assign.left);
        self.check_expr_is_mut(assign.left, true);
        old_expected_type := self.expected_type;
        self.expected_type = left_type;
        right_type := self.check_expr(assign.right);
        self.expected_type = old_expected_type;
        if assign.left is .Ident as ident and ident.name == "_" {
            return .Void();
        }
        self.check_types(right_type, left_type) catch |err| {
            report.error(err.to_string(), assign.right.position());
        };
        return .Void();
    }
}
