// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../token;
import ../prefs;
import ../report;

[boxed]
public struct Checker {
    mut table: ast.Table;
    mut prefs: prefs.Prefs;

    mut source_file: ast.SourceFile;
    mut sym: ast.Sym;
    mut cur_fn: ast.Func;

    mut expected_type: ast.Type = .Void();

    mut inside_extern: bool;
    mut inside_test: bool;
    mut inside_var_decl: bool;
    mut inside_defer: bool;
    mut inside_unsafe: bool;
    mut inside_guard_expr: bool;
    mut inside_call_expr: bool;

    mut defer_stmts: []ast.Stmt.Defer;

    public func check_files(mut self, source_files: []ast.SourceFile) {
        // check global variables
        for source_file in source_files {
            self.sym = source_file.mod;
            self.source_file = source_file;
            self.expected_type = .Void();
            self.check_global_vars(source_file.decls);
        }
        // check the source code
        for source_file in source_files {
            self.sym = source_file.mod;
            self.source_file = source_file;
            self.expected_type = .Void();
            self.check_decls(source_file.decls);
        }
        // check global mutable variables
        for sym in self.table.universe.scope.syms {
            if sym is ast.Module as module {
                for mod_sym in module.scope.syms {
                    if mod_sym is ast.Var as mod_var {
                        if !mod_var.is_public and mod_var.is_mut and !mod_var.is_changed {
                            report.warn(
                                "variable `{}` does not need to be mutable".fmt(mod_var.name),
                                mod_var.pos
                            );
                        }
                    }
                }
            }
        }
    }

    func check_var_decl(
        mut self, lefts: []ast.ObjectData, mut right: ast.Expr, scope: ast.Scope,
        pos: token.Pos
    ) {
        if lefts.len == 1 {
            old_expected_type := self.expected_type;
            left0 := lefts[0];
            if !left0.is_extern {
                if left0.has_type {
                    self.expected_type = left0.type;
                }
                mut right_type := self.check_expr(right);
                if self.inside_guard_expr {
                    right_type = if right_type is .Result as result_t {
                        result_t.inner
                    } else if right_type is .Option as option_t {
                        option_t.inner
                    } else {
                        report.error("expected result or option value", right.position());
                        right_type
                    };
                }
                if left0.has_type {
                    self.check_types(right_type, left0.type) catch |err| {
                        report.error(err.to_string(), pos);
                    };
                } else {
                    right_type = self.table.comptime_number_to_type(right_type);
                    left0.type = right_type;
                    if left0.sym.name.is_empty() {
                        scope.update_type(left0.name, right_type);
                    } else {
                        left0.sym.type = right_type;
                    }
                }
                self.expected_type = old_expected_type;
            }
        } else {
            mut right_type := self.check_expr(right);
            if self.inside_guard_expr {
                right_type = if right_type is .Result as result_t {
                    result_t.inner
                } else if right_type is .Option as option_t {
                    option_t.inner
                } else {
                    report.error("expected result or option value", right.position());
                    right_type
                };
            }
            right_sym := right_type.symbol()?;
            if right_sym.info is .Tuple as tuple_info {
                if tuple_info.types.len == lefts.len {
                    for i, vd in lefts {
                        if vd.name == "_" {
                            report.error("cannot modify blank identifier (`_`)", vd.pos);
                            continue;
                        }
                        if !vd.has_type {
                            v_type := self.table.comptime_number_to_type(tuple_info.types[i]);
                            vd.type = v_type;
                            if vd.sym.name.is_empty() {
                                scope.update_type(vd.name, right_type);
                            } else {
                                vd.sym.type = v_type;
                            }
                        }
                    }
                } else {
                    report.error(
                        "expected {} values, found {}".fmt(
                            lefts.len, tuple_info.types.len
                        ), right.position()
                    );
                }
            } else {
                report.error(
                    "expected tuple value, found `{}`".fmt(right_type),
                    right.position()
                );
            }
        }
    }

    func check_scope_vars(self, scope: ast.Scope) {
        if !self.inside_extern {
            for sym in scope.syms {
                if sym is ast.Var as var_info {
                    if !var_info.is_used and !var_info.name.ends_with("_") {
                        report.warn(
                            if var_info.level == .Receiver {
                                "receiver `self` is not used"
                            } else {
                                if var_info.level == .Argument {
                                    "argument `{}` is not used"
                                } else {
                                    "variable `{}` declared but never used"
                                }.fmt(var_info.name)
                            },
                            var_info.pos
                        );
                    } else if var_info.is_mut and !var_info.is_changed {
                        report.warn(
                            if var_info.level == .Receiver {
                                "receiver `self` does not need to be mutable"
                            } else {
                                if var_info.level == .Argument {
                                    "argument `{}` does not need to be mutable"
                                } else {
                                    "variable `{}` does not need to be mutable"
                                }.fmt(var_info.name)
                            },
                            var_info.pos
                        );
                    }
                }
            }
            for ch in scope.childrens {
                self.check_scope_vars(ch);
            }
        }
    }
}
