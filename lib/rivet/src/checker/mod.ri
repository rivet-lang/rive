// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../prefs;
import ../report;

[boxed]
public struct Checker {
    mut table: ast.Table;
    mut prefs: prefs.Prefs;

    mut source_file: ast.SourceFile;
    mut sym: ast.Sym;
    mut cur_fn: ast.Func;

    mut expected_type: ast.Type = .Void();

    mut inside_extern: bool;
    mut inside_test: bool;
    mut inside_unsafe: bool;
    mut inside_guard_expr: bool;
    mut inside_var_decl: bool;

    mut defer_stmts: []ast.Stmt.Defer;

    public func check_files(mut self, source_files: []ast.SourceFile) {
        for source_file in source_files {
            self.sym = source_file.mod;
            self.source_file = source_file;
            self.expected_type = .Void();
            self.check_decls(source_file.decls);
        }
        // check global variables
        for sym in self.table.universe.scope.syms {
            if sym is ast.Module as module {
                for mod_sym in module.scope.syms {
                    if mod_sym is ast.Var as mod_var {
                        if !mod_var.is_public and mod_var.is_mut and !mod_var.is_changed {
                            report.warn(
                                "variable `{}` does not need to be mutable".fmt(mod_var.name),
                                mod_var.pos
                            );
                        }
                    }
                }
            }
        }
    }

    func check_decls(mut self, decls: []ast.Decl) {
        for decl in decls {
            if decl !is .Const and decl !is .Var {
                self.check_decl(decl);
            }
        }
    }

    func check_decl(mut self, decl: ast.Decl) {
        old_sym := self.sym;
        defer {
            self.sym = old_sym;
        }
        switch decl is {
            .Extern as extern_decl => {
                self.inside_extern = true;
                self.check_decls(extern_decl.decls);
                self.inside_extern = false;
            },
            .Const as const_decl => {},
            .Func as func_decl => {
                self.check_stmts(func_decl.stmts);
                self.check_scope_vars(func_decl.scope);
            },
            else => {}
        }
    }

    func check_scope_vars(self, scope: ast.Scope) {
        if !self.inside_extern {
            for sym in scope.syms {
                if sym is ast.Var as var_info {
                    if !var_info.is_used and !var_info.name.ends_with("_") {
                        report.warn(
                            if var_info.level == .Argument {
                                "argument `{}` is not used"
                            } else {
                                "variable `{}` declared but never used"
                            }.fmt(var_info.name),
                            var_info.pos
                        );
                    } else if var_info.is_mut and !var_info.is_changed {
                        report.warn(
                            if var_info.level == .Argument {
                                "argument `{}` does not need to be mutable"
                            } else {
                                "variable `{}` does not need to be mutable"
                            }.fmt(var_info.name),
                            var_info.pos
                        );
                    }
                }
            }
            for ch in scope.childrens {
                self.check_scope_vars(ch);
            }
        }
    }
}
