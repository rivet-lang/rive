// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../token;
import ../prefs;
import ../utils;
import ../report;

#[boxed]
public struct Checker {
    mut table: ast.Table;
    mut prefs: prefs.Prefs;

    mut source_file: ast.SourceFile;
    mut sym: ast.Sym = ast.InvalidSym();
    mut cur_fn: ast.Func;

    mut inside_extern: bool;
    mut inside_test: bool;
    mut inside_var_decl: bool;
    mut inside_defer: bool;
    mut inside_unsafe_block: bool;
    mut inside_guard_expr: bool;
    mut inside_match_cond_expr: bool;

    mut expected_type: ast.Type;
    mut scope_returns: bool;
    mut defer_stmts: []ast.Stmt.Defer;
    mut unsafe_operations: usize;

    public func check_files(mut self, source_files: []ast.SourceFile) {
        // check global variables
        for source_file in source_files {
            self.sym = source_file.mod;
            self.source_file = source_file;
            self.expected_type = .Void();
            self.check_global_vars(source_file.decls);
        }
        // check the source code
        for source_file in source_files {
            self.sym = source_file.mod;
            self.source_file = source_file;
            self.expected_type = .Void();
            self.check_decls(source_file.decls);
        }
        // check global mutable variables
        for sym in self.table.universe.scope.syms {
            if sym is ast.Module as module {
                for mod_sym in module.scope.syms {
                    if mod_sym is ast.Var as mod_var {
                        if !mod_var.is_public and mod_var.is_mut and !mod_var.is_changed {
                            report.warn(
                                "variable `{}` does not need to be mutable".fmt(mod_var.name),
                                mod_var.pos
                            );
                        }
                    }
                }
                if module.name == self.prefs.mod_name and !self.prefs.is_test and !module.scope.exists("main") {
                    utils.error("function `main` was not defined on module `{}`".fmt(self.prefs.mod_name));
                }
            }
        }
    }

    func check_var_decl(
        mut self, lefts: []ast.ObjectData, mut right: ast.Expr, scope: ast.Scope,
        pos: token.Pos
    ) {
        if lefts.len == 1 {
            old_expected_type := self.expected_type;
            left0 := lefts[0];
            if !left0.is_extern {
                if left0.name == "_" and left0.is_mut {
                    report.error("cannot use `mut` on `_`", left0.pos);
                }
                self.check_name_case(
                    if left0.is_global {
                        .Camel
                    } else {
                        .Snake
                    }, "variable", left0.name, left0.pos
                );
                if self.inside_match_cond_expr {
                    if left0.sym.name.is_empty() {
                        scope.update_is_used(left0.name, true);
                    } else {
                        left0.sym.is_used = true;
                    }
                }
                if left0.has_type {
                    self.expected_type = left0.type;
                }
                mut right_type := self.check_expr(right);
                if self.inside_guard_expr {
                    right_type = if right_type is .Result as result_t {
                        result_t.inner
                    } else if right_type is .Option as option_t {
                        option_t.inner
                    } else {
                        report.error("expected result or option value", right.position());
                        right_type
                    };
                }
                if left0.has_type {
                    self.check_types(right_type, left0.type) catch |err| {
                        report.error(err.to_string(), pos);
                    };
                    self.expected_type = old_expected_type;
                } else {
                    right_type = self.table.comptime_number_to_type(right_type);
                    left0.type = right_type;
                    if left0.sym.name.is_empty() {
                        scope.update_type(left0.name, right_type);
                    } else {
                        left0.sym.type = right_type;
                    }
                }
            }
        } else {
            mut right_type := self.check_expr(right);
            if self.inside_guard_expr {
                right_type = if right_type is .Result as result_t {
                    result_t.inner
                } else if right_type is .Option as option_t {
                    option_t.inner
                } else {
                    report.error("expected result or option value", right.position());
                    right_type
                };
            }
            right_sym := right_type.symbol()?;
            if right_sym.info is .Tuple as tuple_info {
                if tuple_info.types.len == lefts.len {
                    for i, vd in lefts {
                        if vd.name == "_" and vd.is_mut {
                            report.error("cannot use `mut` on `_`", vd.pos);
                        }
                        self.check_name_case(if vd.is_global {
                            .Camel
                        } else {
                            .Snake
                        }, "variable", vd.name, vd.pos);
                        if self.inside_match_cond_expr {
                            if vd.sym.name.is_empty() {
                                scope.update_is_used(vd.name, true);
                            } else {
                                vd.sym.is_used = true;
                            }
                        }
                        value_type := tuple_info.types[i];
                        if vd.has_type {
                            self.check_types(value_type, vd.type) catch |err| {
                                mut errb := report.error_builder(
                                    err.to_string(), right.position()
                                );
                                errb.add_note("in element {} of tuple value", i);
                                errb.emit();
                            };
                        } else {
                            v_type := self.table.comptime_number_to_type(value_type);
                            vd.type = v_type;
                            if vd.sym.name.is_empty() {
                                scope.update_type(vd.name, right_type);
                            } else {
                                vd.sym.type = v_type;
                            }
                        }
                    }
                } else {
                    report.error(
                        "expected {} values, found {}".fmt(
                            lefts.len, tuple_info.types.len
                        ), right.position()
                    );
                }
            } else {
                report.error(
                    "expected tuple value, found `{}`".fmt(right_type),
                    right.position()
                );
            }
        }
    }

    func check_scope_vars(self, scope: ast.Scope) {
        if !self.inside_extern {
            for sym in scope.syms {
                if sym is ast.Var as var_info {
                    if !var_info.is_used and !var_info.name.starts_with("_") {
                        mut warn_b := report.warn_builder(
                            if var_info.level == .Receiver {
                                "receiver `self` is not used"
                            } else {
                                if var_info.level == .Argument {
                                    "argument `{}` is not used"
                                } else {
                                    "variable `{}` declared but never used"
                                }.fmt(var_info.name)
                            },
                            var_info.pos
                        );
                        warn_b.add_help(
                            "if this is intentional, prefix it with an underscore (`_{}`) or use the blank identifier (`_`)",
                            var_info.name
                        );
                        warn_b.emit();
                    } else if var_info.is_mut and !var_info.is_changed {
                        mut warn_b := report.warn_builder(
                            if var_info.level == .Receiver {
                                "receiver `self` does not need to be mutable"
                            } else {
                                if var_info.level == .Argument {
                                    "argument `{}` does not need to be mutable"
                                } else {
                                    "variable `{}` does not need to be mutable"
                                }.fmt(var_info.name)
                            },
                            var_info.pos
                        );
                        warn_b.add_help(if var_info.level == .Local {
                            "remove `mut` from the assignment"
                        } else if var_info.level == .Receiver {
                            "remove `mut` from receiver definition"
                        } else {
                            "remove `mut` from the declaration"
                        });
                        warn_b.emit();
                    }
                }
            }
            for ch in scope.childrens {
                self.check_scope_vars(ch);
            }
        }
    }

    func check_expr_is_mut(
        self, expr: ast.Expr, from_assign: bool := false,
        from_selector: bool := false
    ) {
        match expr is {
            .Paren as paren => self.check_expr_is_mut(paren.expr),
            .SelfLiteral as self_lit => if self_lit.obj.is_mut {
                self_lit.obj.is_changed = true;
            } else {
                mut err := report.error_builder(
                    "cannot use `self` as mutable value", self_lit.pos
                );
                err.add_help("consider making `self` as mutable: `mut self`");
                err.emit();
            },
            .Ident as ident => if ident.is_comptime {
                report.error(
                    "cannot use constant `@{}` as mutable value".fmt(ident.name),
                    ident.pos
                );
            } else if ident.name == "_" {
                return;
            } else if ident.found and (ident.is_sym or ident.is_obj) {
                self.check_sym_is_mut(ident.sym, ident.pos, from_selector);
            },
            .Selector as selector => if selector.is_path {
                self.check_sym_is_mut(selector.sym, selector.pos, true);
            } else {
                match selector.left is {
                    .Ident as ident2 if ident2.found => if ident2.is_sym {
                        self.check_sym_is_mut(ident2.sym, ident2.pos, true)
                    } else if ident2.sym is ast.Var as i_var and i_var.level == .Argument {
                        if i_var.is_mut {
                           i_var.is_changed = true;
                        } else {
                            mut err := report.error_builder(
                                "cannot use `{}` as mutable argument".fmt(ident2.name),
                                ident.pos
                            );
                            err.add_help(
                                "consider making this argument mutable: `mut {}`",
                                ident2.name
                            );
                            err.emit();
                        }
                    },
                    else => self.check_expr_is_mut(selector.left, from_assign, true)
                }
                if selector.found and !selector.field_is_mut {
                    report.error(
                        "field `{}` of type `{}` is immutable".fmt(
                            selector.field_name, selector.left_type
                        ), selector.pos
                    );
                }
            },
            .Indirect as indirect => if !indirect.is_mut {
                report.error("cannot use a immutable pointer as mutable value", selector.pos);
            },
            .OptionCheck as option_check => self.check_expr_is_mut(option_check.left),
            .NoneLiteral => report.error("`none` cannot be modified", expr.position()),
            .StringLiteral => report.error(
                "string literals cannot be modified", expr.position()
            ),
            .TupleLiteral as tuple_lit => if from_assign {
                for value in tuple_lit.values {
                    self.check_expr_is_mut(value);
                }
            } else {
                report.error("tuple literals cannot be modified", tuple_lit.pos);
            },
            .EnumLiteral as enum_lit if !enum_lit.is_instance => report.error(
                "enum literals cannot be modified", enum_lit.pos
            ),
            .BuiltinCall as builtin_call => {
                for arg in builtin_call.args {
                    self.check_expr_is_mut(arg.expr);
                }
            },
            .Block as block if block.is_expr => self.check_expr_is_mut(block.expr),
            .Index as index => {
                if index.left_type is .Pointer as ptr {
                    if !ptr.is_mut {
                        report.error(
                            "cannot modify elements of an immutable pointer", index.pos
                        );
                    }
                    return;
                }
                expr_sym := index.left_type.symbol()?;
                if !expr_sym.info.is_mut_arr_or_vec() {
                    report.error(
                        "cannot modify elements of an immutable {}".fmt(expr_sym.info),
                        index.pos
                    );
                }
            },
            .Unary as unary => self.check_expr_is_mut(unary.right),
            .Binary as binary => {
                self.check_expr_is_mut(binary.left);
                self.check_expr_is_mut(binary.right);
            },
            .If as if_expr => {
                for branch in if_expr.branches {
                    self.check_expr_is_mut(branch.expr);
                }
            },
            .Match as match_expr => {
                for branch in match_expr.branches {
                    self.check_expr_is_mut(branch.expr);
                }
            },
            else => {}
        }
    }

    func check_sym_is_mut(self, sym: ast.Sym, pos: token.Pos, from_selector: bool) {
        _ = self;
        match sym is {
            ast.Const => report.error(
                "cannot use constant `{}` as mutable value".fmt(sym.name), pos
            ),
            ast.Var as var_info if !(from_selector and var_info.level == .Local) => {
                if var_info.is_mut {
                    var_info.is_changed = true;
                } else {
                    mut err := if var_info.level == .Argument {
                        mut err_b := report.error_builder(
                            "cannot use variable `{}` as mutable argument".fmt(sym.name), pos
                        );
                        err_b.add_help(
                            "consider making this argument mutable: `mut {}`", var_info.name
                        );
                        err_b
                    } else {
                        mut err_b := report.error_builder(
                            "cannot use variable `{}` as mutable value".fmt(sym.name), pos
                        );
                        err_b.add_help(
                            "consider making this {} mutable: `mut {}`", var_info.type_of(),
                            var_info.name
                        );
                        err_b
                    };
                    err.emit();
                }
            },
            else => {}
        }
    }

    func check_expr_evaluated_but_not_used(self, expr_type: ast.Type, pos: token.Pos) {
        _ = self;
        if !((expr_type is .Result as res and !res.inner.is_void())
            or (expr_type is .Option as opt and !opt.inner.is_void())
            or expr_type.is_void()) {
            report.warn("expression evaluated but not used", pos);
        }
    }

    func has_return(self, stmts: []ast.Stmt, allow_throw: bool := false) -> bool {
        for stmt in stmts {
            if stmt is .Expr as expr and self.expr_has_return(expr, allow_throw) {
                return true;
            }
        }
        return false;
    }

    func expr_has_return(self, expr: ast.Expr, allow_throw: bool := false) -> bool {
        return match expr is {
            .Match as match_expr => {
                for i, branch in match_expr.branches {
                    if match_expr.is_exhaustive and i == match_expr.branches.len {
                        if self.expr_has_return(branch.expr, allow_throw) {
                            return true;
                        }
                    } else if branch.is_else and self.expr_has_return(branch.expr, allow_throw) {
                        return true;
                    }
                }
                false
            },
            .If as if_expr => {
                for branch in if_expr.branches {
                    if branch.is_else and self.expr_has_return(branch.expr, allow_throw) {
                        return true;
                    }
                }
                false
            },
            .Call as call_expr => call_expr.type is .Never,
            .Block as block => self.has_return(block.stmts, allow_throw),
            .Return => true,
            .Throw if allow_throw => true,
            else => false
        };
    }

    func inside_unsafe(mut self) -> bool {
        self.unsafe_operations += 1;
        return self.inside_unsafe_block;
    }
}
