// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../token;
import ../report;

#[boxed]
struct IncompatibleTypesError < Throwable {
    msg: string;

    pub func to_string(self) -> string {
        return self.msg;
    }
}

extend Checker {
    func check_argument_type(
        self, got: ast.Type, expected: ast.Type, pos: token.Pos, arg_name: string,
        func_kind: string, func_name: string
    ) {
        if expected_sym := expected.symbol(); expected_sym.info is .Trait(mut trait_info)
            and expected != got {
            got_t := self.table.comptime_number_to_type(got);
            if got_t.symbol()? in trait_info.implements {
                trait_info.mark_has_objects();
            } else {
                mut err := report.error_builder(
                    "type `{}` does not implement trait `{}`".fmt(
                        got_t, expected_sym.name
                    ), pos
                );
                err.add_note(
                    "in argument `{}` of {} `{}`".fmt(arg_name, func_kind, func_name)
                );
                err.emit();
            }
        } else {
            self.check_types(got, expected) catch |err| {
                mut err2 := report.error_builder(err.to_string(), pos);
                err2.add_note(
                    "in argument `{}` of {} `{}`".fmt(arg_name, func_kind, func_name)
                );
                err2.emit();
            };
        }
    }

    func check_types(self, got: ast.Type, expected: ast.Type) -> ! {
        if !self.check_compatible_types(got, expected) {
            got_str := if got is .None {
                if expected is .Option {
                    "`".concat(expected.to_string(), "`")
                } else if expected is .Void {
                    "option"
                } else {
                    "`?".concat(expected.to_string(), "`")
                }
            } else {
                "`".concat(got.to_string(), "`")
            };
            if expected is .Void {
                throw IncompatibleTypesError(
                    "no value expected, found {} value instead".fmt(got_str)
                );
            } else if got is .Void {
                throw IncompatibleTypesError("void expression used as value");
            } else {
                throw IncompatibleTypesError(
                    "expected type `{}`, found {}".fmt(expected, got_str)
                );
            }
        }
    }

    func check_compatible_types(self, got: ast.Type, expected: ast.Type) -> bool {
        if got is .Never {
            return true;
        } else if (expected is .Never and got is .Void)
            or (expected is .Void and got is .Never) {
            return true;
        } else if expected is .Void and got is .Void {
            return true;
        }

        if expected is .Result(result) {
            return self.check_compatible_types(got, result.inner);
        }

        if got is .Option(option) and expected is .Pointer {
            return check_pointer(expected, option.inner);
        } else if got is .Option and expected !is .Option {
            return false;
        } else if expected is .Option(option_) and got is .Option(option2) {
            if option_.inner is .Pointer and option2.inner is .Pointer {
                return check_pointer(option_.inner, option2.inner);
            }
            return option_.inner == option2.inner;
        } else if expected is .Option(option_2) and got !is .Option {
            if got is .None {
                return true;
            }
            return self.check_compatible_types(got, option_2.inner);
        } else if expected is .None and got is .Option {
            return true;
        }

        expected_is_ptr := expected.is_pointer();
        got_is_ptr := got.is_pointer();
        if expected_is_ptr and got_is_ptr {
            return check_pointer(expected, got);
        } else if (expected_is_ptr and !got_is_ptr) or (got_is_ptr and !expected_is_ptr) {
            return false;
        }

        expected_sym := expected.symbol() ?? return false;
        got_sym := got.symbol() ?? return false;

        if expected is .Variadic {
            vec_info := @as(ast.TypeInfo.DynArray, expected_sym.info);
            if got is .Variadic(variadic) {
                return vec_info.elem_type == variadic.inner;
            }
            elem_sym := vec_info.elem_type.symbol()?;
            if got_sym.info is .Trait(trait_info) and elem_sym in trait_info.bases {
                return true;
            }
            return self.check_compatible_types(got, vec_info.elem_type);
        }

        if expected is .Func and got is .Func {
            return expected == got;
        } else if expected is .DynArray(dyn_array_info) and got is .DynArray(dyn_array_info2) {
            return dyn_array_info.inner == dyn_array_info2.inner;
        }

        if expected == self.table.rune_t and got == self.table.comptime_int_t {
            return true;
        } else if expected == self.table.comptime_int_t and got == self.table.rune_t {
            return true;
        }

        if self.table.is_number(expected) and self.table.is_number(got) {
            if self.table.is_comptime_number(expected) or self.table.is_comptime_number(got) {
                return true;
            }
            return self.promote_number(expected, got) == expected;
        }

        match expected_sym.info is {
            .Trait(mut trait_info) -> {
                got_sym2 := self.table.comptime_number_to_type(got).symbol()?;
                if got_sym2 in trait_info.implements {
                    trait_info.mark_has_objects();
                    return true;
                }
            },
            .Array(array_info) if got_sym.info is .Array(array_info2) -> {
                if array_info.is_mut and !array_info2.is_mut {
                    return false;
                }
                return array_info.elem_type == array_info2.elem_type
                    and array_info.size == array_info2.size;
            },
            .DynArray(dyn_array_lhs) if got_sym.info is .DynArray(dyn_array_rhs) -> {
                if dyn_array_lhs.is_mut and !dyn_array_rhs.is_mut {
                    return false;
                }
                return dyn_array_lhs.elem_type == dyn_array_rhs.elem_type;
            },
            .Tuple(tuple_lhs) if got_sym.info is .Tuple(tuple_rhs) -> {
                if tuple_lhs.types.len != tuple_rhs.types.len {
                    return false;
                }
                for i, type in tuple_lhs.types {
                    if type != tuple_rhs.types[i] {
                        return false;
                    }
                }
                return true;
            },
            else -> {}
        }

        mod_sym := self.sym.module()?;
        if mod_sym.is_core() {
            if expected_sym.info is .DynArray and got_sym == self.table.dyn_array_sym {
                return true;
            }
        }

        return expected == got;
    }

    func promote(self, left_type: ast.Type, right_type: ast.Type) -> ast.Type {
        if left_type == right_type {
            return left_type;
        } else if self.table.is_number(left_type) and self.table.is_number(right_type) {
            return self.promote_number(left_type, right_type);
        }
        return left_type;
    }

    func promote_number(self, expected: ast.Type, got: ast.Type) -> ast.Type {
        mut type_hi := expected;
        mut type_lo := got;
        mut bits_hi := self.table.number_bits(type_hi);
        mut bits_lo := self.table.number_bits(type_lo);
        if bits_hi < bits_lo {
            old_hi := type_hi;
            type_hi = type_lo;
            type_lo = old_hi;

            old_bhi := bits_hi;
            bits_hi = bits_lo;
            bits_lo = old_bhi;
        }

        return if self.table.is_float(type_hi) {
            if self.table.is_float(type_lo) {
                // float -> float (good)
                type_hi
            } else {
                // float -> int (bad)
                .Void
            }
        } else {
            is_signed_lo := self.table.is_signed_int(type_lo);
            is_unsigned_lo := !is_signed_lo;

            is_signed_hi := self.table.is_signed_int(type_hi);
            is_unsigned_hi := !is_signed_hi;

            if is_unsigned_lo and is_unsigned_hi {
                // unsigned number -> unsigned number (good)
                type_hi
            } else if is_signed_lo and is_signed_hi {
                // signed number -> signed number (good)
                if bits_lo == 64 and bits_hi != 64 {
                    type_lo
                } else {
                    type_hi
                }
            } else if is_unsigned_lo and is_signed_hi and bits_hi > bits_lo {
                // unsigned number -> signed number (good, if signed type is larger)
                type_lo
            } else {
                // signed number -> unsigned number (bad)
                .Void
            }
        };
    }
}

func check_pointer(expected: ast.Type, got: ast.Type) -> bool {
    if expected is .Rawptr {
        // rawptr == &T, is valid
        return got is .Rawptr or got is .Pointer;
    } else if expected is .Pointer(ptr) and got is .Pointer(ptr2) {
        if ptr.is_mut and !ptr2.is_mut {
            return false;
        }
        if ptr.is_indexable and !ptr2.is_indexable {
            return false;
        }
        return ptr.inner == ptr2.inner;
    }
    return false;
}