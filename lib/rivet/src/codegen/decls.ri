// Copyright (C) 2023-present Jose Mendoza - All rights reserved. Use of this
// source code is governed by an MIT license that can be found in the LICENSE
// file.

import ./mir;
import ../ast;

extend Codegen {
    proc gen_decls(mut self, mut decls: []mut ast.Decl) {
        for mut decl in decls {
            self.gen_decl(decl);
        }
    }

    proc gen_decl(mut self, mut decl: ast.Decl) {
        match decl {
            .Extern(mut extern_decl) -> self.gen_decls(extern_decl.decls),
            .Var(var_decl) -> {
                for left in var_decl.lefts {
                    self.mir.globals.push(mir.Global(
                        is_extern: left.is_extern,
                        name: left.name,
                        type: self.type_to_mir(left.type)
                    ));
                }
            },
            .Trait(mut trait_decl) -> self.gen_decls(trait_decl.decls),
            .Enum(mut enum_decl) -> self.gen_decls(enum_decl.decls),
            .Struct(mut struct_decl) -> self.gen_decls(struct_decl.decls),
            .Extend(mut extend_decl) -> self.gen_decls(extend_decl.decls),
            .Proc(mut proc_decl) -> self.gen_proc(proc_decl),
            else -> {}
        }
    }

    proc gen_proc(mut self, mut proc_decl: ast.Decl.Proc) {
        ret_type_is_void := proc_decl.ret_type.is_void();
        self.cur_proc = mir.Proc(
            name: if proc_decl.is_extern && proc_decl.abi != .Rivet {
                proc_decl.name
            } else {
                self.mangle_symbol(proc_decl.sym)
            },
            args_len: proc_decl.args.len + if proc_decl.is_method { 1 } else { 0 },
            ret_type: self.type_to_mir(proc_decl.ret_type),
            is_extern: proc_decl.is_extern
        );
        self.add_locals(proc_decl.scope);
        if !ret_type_is_void {
            self.cur_proc.add_local(mir.Var(
                dbg_name: "_return_value",
                level: .Local,
                type: self.type_to_mir(proc_decl.ret_type)
            ));
        }
        self.cur_proc.cur_block = mir.Block();
        self.cur_proc.add_block(self.cur_proc.cur_block);
        self.gen_stmts(proc_decl.stmts);
        self.cur_proc.add_block(
            mir.Block(stmts: +[
                if ret_type_is_void {
                    .Return()
                } else {
                    .Return(true, .Ident(self.cur_proc.locals[self.cur_proc.locals.len - 1]))
                }
            ])
        );
        if self.cur_proc.is_extern {
            self.mir.externs.push(self.cur_proc);
        } else {
            self.mir.procs.push(self.cur_proc);
        }
    }
}
