// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/fs;
import std/traits;
import std/strings;

import ../../utils;

[boxed]
public struct ModuleIR : traits.Stringable {
    public name: string;
    public mut structs: []Struct;
    public mut globals: []Global;
    public mut vtables: []VTable;
    public mut funcs: []Func;

    [inline]
    public func to_file(self) ! {
        fs.write_file("{}.mir".fmt(self.name), self.to_string())!;
    }

    public func to_string(self) string {
        mut sb := strings.Builder.new();
        sb.writeln_fmt("// Rivet Intermediate Representation for module `{}`.", self.name);
        sb.writeln_fmt("// Auto-generated by {}.\n//", utils.full_version());
        sb.writeln("// WARNING: This output format is intended for human consumers only");
        sb.writeln("// and is subject to change without notice. Knock yourself out.");
        sb.writeln();
        return sb.to_string();
    }
}

[boxed]
public struct Struct {
    public name: string;
    public fields: []Ident;
    public is_opaque: bool;
}

[boxed]
public struct Global {
    public name: string;
    public type: Type;
}

[boxed]
public struct VTable {
    public funcs: []Func;
}

[boxed]
public struct Func {
    public name: string;
    public args: []Ident;
    public ret_type: Type;
    public is_variadic: bool;
}

public enum Type : traits.Stringable {
    Void,
    Never,
    Basic {
        name: string;
        size: usize;
    },
    Pointer {
        inner: Type;
    },
    Array {
        elem_type: Type;
        count: usize;
        size: usize;
    },
    Func {
        args: []Type;
        ret_type: Type;
        size: usize;
    };

    public func to_string(self) string {
        return switch self is {
            .Void => "void",
            .Never => "never",
            .Basic as basic => basic.name,
            .Pointer as ptr => "*".concat(ptr.inner.to_string()),
            .Array as arr => "[{}]{}".fmt(arr.count, arr.elem_type),
            .Func as fn => {
                mut sb := strings.Builder.from_string("*func(");
                for i, arg in fn.args {
                    sb.write_string(arg.to_string());
                    if i < fn.args.len - 1 {
                        sb.write_string(", ");
                    }
                }
                sb.write_fmt(") {}", fn.ret_type);
                sb.to_string()
            }
        };
    }
}
