// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import "std/traits";
import "std/env";
import "std/fs";
import "std/fs/path";
import "std/console";
import "std/process";

import "./ast";
import "./utils";
import "./prefs";
import "./report";
import "./parser";

public var RIVET_DIR = path.join(env.HOME_DIR, ".rivet_lang").!;
public var RIVETC_DIR = path.dirname(process.executable().!).?;

public var OBJ_DIR = path.join(RIVET_DIR, "obj").!;
public var LIB_DIR = path.join(RIVET_DIR, "lib").!;

[boxed]
public struct Compiler {
    public mut table: ast.Table;
    public mut prefs: prefs.Prefs;
    public mut source_files: []string;

    public func new(args: []string, is_test: bool, run_output: bool) ! {
        mut prefs_ := prefs.Prefs.new(args, is_test, run_output).!;
        report.reports.prefs = prefs_;
        Self(table: ast.Table.new(prefs_), prefs: prefs_).run().!;
    }

    func run(mut self) ! {
        self.make_rivet_directory().!;
        self.load_root_module().!;
    }

    func make_rivet_directory(self) ! {
        if !path.exists(RIVET_DIR) {
            self.vlog("making Rivet directory");
            fs.make_directory(RIVET_DIR).!;
            fs.make_directory(OBJ_DIR).!;
            fs.make_directory(LIB_DIR).!;
        }
    }

    func load_root_module(mut self) ! {
        files := if path.is_directory(self.prefs.input) {
            mut filtered_files := self.table.filter_files(
                fs.walk_directory(self.prefs.input, ".ri").!
            );
            src_dir := path.join(self.prefs.input, "src").!;
            if path.is_directory(src_dir) { // support `src/` directory
                for file in self.table.filter_files(fs.walk_directory(src_dir, ".ri").!) {
                    filtered_files.push(file);
                }
            }
            filtered_files
        } else {
            [self.prefs.input]
        };
        if files.is_empty() {
            utils.error("no input received");
        } else if self.prefs.is_verbose {
            self.vlog("loaded root module files:");
            for file in files {
                self.vlog("  {}", file);
            }
        }
        root_sym := ast.Module(name: self.prefs.mod_name, is_root: true);
        self.table.universe.scope.add(root_sym) catch |err| utils.error(
            "Compiler.load_root_module(): {}", err
        );
        self.parse_files(root_sym, files);
    }

    func parse_files(mut self, mod_sym: ast.Sym, files: []string) {
        for sf in parser.Parser(table: self.table, prefs: self.prefs).parse_module(mod_sym, files) {
            self.table.source_files.push(sf);
        }
        if report.total_errors() > 0 {
            self.abort();
        }
    }

    func vlog(self, msg: string, args: ...traits.Stringable) {
        if self.prefs.is_verbose {
            console.println(">> ".concat(msg), args);
        }
    }

    func abort(self) {
        mut msg := if report.total_errors() == 1 {
            "could not compile module `{}`, aborting due to previous error".fmt(self.prefs.mod_name)
        } else {
            "could not compile module `{}`, aborting due to {} previous errors".fmt(
                self.prefs.mod_name, report.total_errors()
            )
        };
        if report.total_warns() > 0 {
            msg = msg.fmt(", {} {} emitted", report.total_warns(), if report.total_warns() == 1 {
                "warning"
            } else {
                "warnings"
            });
        }
        utils.error(msg);
        process.exit(1);
    }
}
