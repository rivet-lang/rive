// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import "std/traits";
import "std/env";
import "std/fs";
import "std/fs/path";
import "std/console";
import "std/process";

import "./ast";
import "./utils";
import "./prefs";
import "./report";
import "./parser";

let RIVET_DIR: string = path.join(env.HOME_DIR, ".rivet_lang").!;
let RIVETC_DIR: string = path.dirname(process.executable().!).?;

pub class Compiler {
    pub mut table: ast.Table;
    pub mut prefs: prefs.Prefs;
    pub mut source_files: []string;

    pub fn new(args: []string, is_test: bool, run_output: bool) ! {
        let prefs_ = prefs.Prefs.new(args, is_test, run_output).!;
        report.reports.prefs = prefs_;
        let mut compiler = Self(table: ast.Table.new(prefs_), prefs: prefs_);
        compiler.make_rivet_directory().!;
        compiler.run().!;
    }

    fn make_rivet_directory(self) ! {
        if !path.exists(RIVET_DIR) {
            self.vlog("making Rivet directory");
            fs.Dir.make(RIVET_DIR).!;
            fs.Dir.make(path.join(RIVET_DIR, "obj").!).!;
            fs.Dir.make(path.join(RIVET_DIR, "lib").!).!;
        }
    }

    pub fn run(mut self) ! {
        self.load_root_module().!;
    }

    fn load_root_module(mut self) ! {
        let files = if path.is_directory(self.prefs.input) {
            let mut filtered_files = self.table.filter_files(
                fs.Dir.walk(self.prefs.input).!
            );
            let src_dir = path.join(self.prefs.input, "src").!;
            if path.is_directory(src_dir) { // support `src/` directory
                for file in self.table.filter_files(fs.Dir.walk(src_dir).!) {
                    filtered_files.push(file);
                }
            }
            filtered_files
        } else {
            [self.prefs.input]
        };
        if files.is_empty() {
            utils.error("no input received");
        } else if self.prefs.is_verbose {
            self.vlog("loaded root module files:");
            for file in files {
                self.vlog("  {}", file);
            }
        }
        let root_sym = ast.Mod(vis: .Priv, name: self.prefs.mod_name, is_root: true);
        self.table.universe.scope.add(root_sym) catch |err| utils.error(
            "Compiler.load_root_module(): {}", err
        );
        self.parse_files(root_sym, files);
    }

    fn parse_files(mut self, mod_sym: ast.Sym, files: []string) {
        for sf in parser.Parser(table: self.table, prefs: self.prefs).parse_module(mod_sym, files) {
            self.table.source_files.push(sf);
        }
        if report.total_errors() > 0 {
            self.abort();
        }
    }

    fn vlog(self, msg: string, args: ...traits.ToString) {
        if self.prefs.is_verbose {
            console.println(">> ".concat(msg), args);
        }
    }

    fn abort(self) {
        let mut msg = if report.reports.errors == 1 {
            "could not compile module `{}`, aborting due to previous error".fmt(self.prefs.mod_name)
        } else {
            "could not compile module `{}`, aborting due to {} previous errors".fmt(
                self.prefs.mod_name, report.reports.errors
            )
        };
        if report.reports.warns > 0 {
            msg = msg.fmt(", {} {} emitted", report.reports.warns, if report.reports.warns == 1 {
                "warning"
            } else {
                "warnings"
            });
        }
        utils.error(msg);
        process.exit(1);
    }
}
