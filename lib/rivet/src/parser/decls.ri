// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/strings;

import ../ast;
import ../utils;
import ../prefs;
import ../report;
import ../token;
import ../tokenizer;

extend Parser {
    func parse_doc_comment(mut self) ast.DocComment {
        mut pos := self.tok.pos;
        mut lines := @vec(string);
        while self.accept(.DocComment) {
            lines.push(self.prev_tok.lit);
            pos += self.prev_tok.pos;
        }
        return ast.DocComment(lines, pos);
    }

    public func parse_annotations(
        mut self, parse_mod_annotations: bool = false
    ) ast.Annotations {
        mut annotations := ast.Annotations();
        if parse_mod_annotations {
            self.expect(.Bang);
        }
        if self.accept(.Lbracket) {
            while {
                mut args := @vec(ast.AnnotationArgument);
                pos := self.tok.pos;
                annotation_name := if self.accept(.KwUnsafe) {
                    "unsafe"
                } else {
                    self.parse_name()
                };
                if self.accept(.Lparen) {
                    while {
                        name := if self.tok.kind == .Name and self.peek_tok.kind == .Colon {
                            n := self.parse_name();
                            self.expect(.Colon);
                            n
                        } else {
                            ""
                        };
                        args.push(ast.AnnotationArgument(name, self.parse_expr()));
                        if !self.accept(.Comma) {
                            break;
                        }
                    }
                }
                annotations.add(ast.Annotation(annotation_name, args, pos)) catch |err| {
                    report.error(err.to_string(), pos);
                };
                if !self.accept(.Semicolon) {
                    break;
                }
            }
            self.expect(.Rbracket);
        }
        return annotations;
    }

    [inline]
    func is_public(mut self) bool {
        return self.inside_trait or self.accept(.KwPublic);
    }

    func parse_abi(mut self) ast.ABI {
        self.expect(.Lparen);
        abi_pos := self.tok.pos;
        abi := self.parse_name();
        self.expect(.Rparen);
        return if abi_value := ast.ABI.from_string(abi) {
            abi_value
        } else {
            report.error("unknown ABI: `{}`".fmt(abi), abi_pos);
            .Rivet
        };
    }

    func parse_decls(mut self) []ast.Decl {
        mut decls := @vec(ast.Decl);
        while self.tok.kind != .EndOfFile {
            decls.push(self.parse_decl());
        }
        return decls;
    }

    func parse_decl(mut self) ast.Decl {
        doc_comment := self.parse_doc_comment();
        annotations := self.parse_annotations(
            self.tok.kind == .Bang and self.peek_tok.kind == .Lbracket
        );
        is_public := self.is_public();
        pos := self.tok.pos;
        switch {
            self.accept(.KwImport) => {
                mut import_list := @vec(ast.ImportListInfo);
                mut glob := false;
                if self.accept(.Lbrace) {
                    while {
                        info_pos := self.tok.pos;
                        switch {
                            self.accept(.KwSelf) => {
                                name := "self";
                                info_alias := if self.accept(.KwAs) {
                                    self.parse_name()
                                } else {
                                    name
                                };
                                import_list.push(
                                    ast.ImportListInfo(name, info_alias, info_pos)
                                );
                            },
                            self.accept(.Mul) => {
                                glob = true;
                                break;
                            },
                            else => {
                                name := self.parse_name();
                                info_alias := if self.accept(.KwAs) {
                                    self.parse_name()
                                } else {
                                    name
                                };
                                import_list.push(
                                    ast.ImportListInfo(name, info_alias, info_pos)
                                );
                            }
                        }
                        if !self.accept(.Comma) {
                            break;
                        }
                    }
                }
                mod_path := self.parse_import_path();
                alias_name := if import_list.is_empty() and self.accept(.KwAs) {
                    self.parse_name()
                } else {
                    ""
                };
                self.expect(.Semicolon);
                return .Import(
                    annotations: annotations,
                    is_public: is_public,
                    path: mod_path,
                    alias_name: alias_name,
                    glob: glob,
                    import_list: import_list,
                    pos: pos
                );
            },
            self.accept(.KwFunc) => return self.parse_func_decl(
                doc_comment, annotations, is_public, annotations.has("unsafe") or (
                    self.inside_extern and self.extern_abi != .Rivet
                ), if self.inside_extern { self.extern_abi } else { .Rivet }
            ),
            self.tok.kind != .EndOfFile => {
                report.error("expected declaration, found {}".fmt(self.tok), pos);
                self.next();
            }
        }
        return .Empty(pos);
    }

    func parse_import_path(mut self) string {
        mut sb := strings.Builder();
        if self.accept(.Dot) {
            sb.write_string("./");
            self.expect(.Div);
        } else {
            while self.accept(.DotDot) {
                sb.write_string("../");
                self.expect(.Div);
            }
        }
        sb.write_string(self.parse_name());
        while self.accept(.Div) {
            sb.write_join(["/", self.parse_name()]);
        }
        return sb.to_string();
    }

    func parse_func_decl(
        mut self, docs: ast.DocComment, annotations: ast.Annotations,
        is_public: bool, is_unsafe: bool, abi: ast.ABI
    ) ast.Decl {
        pos := self.tok.pos;
        name := if token.is_overloadable_operator(self.tok.kind) {
            self.next();
            self.prev_tok.kind.to_string()
        } else {
            self.parse_name()
        };

        mut args := @vec(ast.Arg);
        mut is_method := false;
        mut is_variadic := false;
        mut self_is_mut := false;
        mut self_is_ref := false;
        mut has_named_args := false;

        self.open_scope();
        sc := self.scope.?;
        self.expect(.Lparen);
        if self.tok.kind != .Rparen {
            // receiver (`self`|`&self`|`mut self`)
            if self.tok.kind == .KwSelf or (
                self.tok.kind in [.Amp, .KwMut] and self.peek_tok.kind == .KwSelf
            ) {
                is_method = true;
                self_is_ref = self.accept(.Amp);
                self_is_mut = !self_is_ref and self.accept(.KwMut);
                self.expect(.KwSelf);
                if self.tok.kind != .Rparen {
                    self.expect(.Comma);
                }
            }
            // arguments
            while self.tok.kind != .Rparen {
                if self.inside_extern and self.accept(.Ellipsis) {
                    is_variadic = true;
                    break;
                } else {
                    arg_pos := self.tok.pos;
                    arg_is_mut := self.accept(.KwMut);
                    arg_name := self.parse_name();
                    self.expect(.Colon);
                    arg_type := self.parse_type();
                    is_variadic = arg_type is .Variadic;
                    arg_expr := if self.accept(.Assign) {
                        has_named_args = true;
                        self.parse_expr()
                    } else {
                        .Empty(self.tok.pos)
                    };
                    args.push(ast.Arg(
                        name: name,
                        is_mut: arg_is_mut,
                        type: arg_type,
                        def_expr: arg_expr,
                        has_def_expr: arg_expr !is .Empty,
                        pos: arg_pos + self.prev_tok.pos
                    ));
                }
                if !self.accept(.Comma) {
                    break;
                }
            }
        }
        self.expect(.Rparen);

        is_result := self.accept(.Bang);
        mut ret_type := if self.tok.kind in [.Lbrace, .Semicolon] {
            ast.Type.Void // default: `void`
        } else {
            self.parse_type()
        };
        if is_result {
            ret_type = .Result(ret_type);
        }

        mut stmts := @vec(ast.Stmt);
        mut has_body := true;
        if (self.inside_trait or self.inside_extern) and self.accept(.Semicolon) {
            has_body = false;
        } else {
            self.expect(.Lbrace);
            while !self.accept(.Rbrace) {
                stmts.push(self.parse_stmt());
            }
        }
        self.close_scope();
        return .Func(
            docs: docs,
            annotations: annotations,
            is_public: is_public,
            is_extern: self.inside_extern,
            is_unsafe: is_unsafe,
            name: name,
            args: args,
            has_named_args: has_named_args,
            ret_type: ret_type,
            stmts: stmts,
            has_body: has_body,
            is_method: is_method,
            self_is_mut: self_is_mut,
            self_is_ref: self_is_ref,
            scope: sc,
            pos: pos + self.prev_tok.pos
        );
    }
}
