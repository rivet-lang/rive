// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import "std/fs/path";

import "../ast";
import "../utils";
import "../prefs";
import "../report";
import "../token";
import "../tokenizer";

[boxed]
public struct Parser {
    mut table: ast.Table;
    mut prefs: prefs.Prefs;

    mut tokenizer: tokenizer.Tokenizer;
    mut prev_tok: token.Token;
    mut tok: token.Token;
    mut peek_tok: token.Token;
    mut last_err_pos: token.Pos;

    mut mod_sym: ?ast.Sym;
    mut file_path: string;
    mut file_dir: string;
    mut scope: ?ast.Scope;

    mut inside_extern: bool;
    mut extern_abi: ast.ABI;
    mut inside_mod: bool;
    mut inside_struct: bool;
    mut inside_trait: bool;
    mut inside_switch_header: bool;
    mut inside_block: bool;

    public func parse_module(mut self, mod_sym: ast.Sym, files: []string) []ast.SourceFile {
        self.mod_sym = mod_sym;
        mut source_files := @vec(ast.SourceFile);
        for file in files {
            source_files.push(self.parse_file(file));
        }
        return source_files;
    }

    public func parse_file(mut self, file: string) ast.SourceFile {
        self.file_path = file;
        self.file_dir = path.dirname(file) ?? file;
        self.tokenizer = tokenizer.Tokenizer.from_file(file, self.prefs, self.table);
        if report.total_errors() > 0 {
            return ast.SourceFile(file, self.mod_sym.?, []);
        }
        self.advance(2);
        return ast.SourceFile(file, self.mod_sym.?, self.parse_decls());
    }

    // ---- useful functions for working with tokens ----
    func next(mut self) {
        self.prev_tok = self.tok;
        self.tok = self.peek_tok;
        self.peek_tok = self.tokenizer.next();
    }

    [inline]
    func peek_token(self, n: usize) token.Token {
        return self.tokenizer.peek_token(n - 2);
    }

    func advance(mut self, n: usize) {
        mut i: usize := 0;
        while i < n : i += 1 {
            self.next();
        }
    }

    [inline]
    func accept(mut self, kind: token.Kind) bool {
        return if self.tok.kind == kind {
            self.next();
            true
        } else {
            false
        };
    }

    func expect(mut self, kind: token.Kind) {
        if self.accept(kind) {
            return;
        } else if self.last_err_pos.pos == self.tok.pos.pos {
            self.next(); // avoid infinite output
            return;
        }
        self.last_err_pos = self.tok.pos;
        mut kstr := kind.to_string();
        if token.is_keyword(kstr) or (kstr.len > 0 and !kstr[0].is_letter()) {
            kstr = "`{}`".fmt(kstr);
        }
        report.error("expected {}, found {}".fmt(kstr, self.tok), self.tok.pos).emit();
    }

    // ---- utilities ------------------
    func parse_name(mut self) string {
        lit := self.tok.lit;
        self.expect(.Name);
        return lit;
    }

    [inline]
    func open_scope(mut self) {
        self.scope = ast.Scope(start: self.tok.pos.pos, parent: self.scope);
    }

    func close_scope(mut self) {
        if scope := self.scope {
            scope.end = self.tok.pos.pos;
            if parent := scope.parent {
                parent.childrens.push(scope);
            }
            self.scope = scope.parent;
        }
    }

    // ---- declarations --------------
    func parse_doc_comment(mut self) ast.Decl {
        pos := self.tok.pos;
        mut lines := @vec(string);
        while self.accept(.DocComment) {
            lines.push(self.prev_tok.lit);
        }
        return .DocComment(ast.DocComment(lines: lines));
    }

    func parse_abi(mut self) ast.ABI {
        self.expect(.Lparen);
        abi_pos := self.tok.pos;
        abi := self.parse_name();
        self.expect(.Rparen);
        if abi_value := ast.ABI.from_string(abi) {
            return abi_value;
        }
        report.error("unknown ABI: `{}`".fmt(abi), abi_pos).emit();
        return .Rivet;
    }

    [inline]
    func is_public(mut self) bool {
        return self.accept(.KwPublic);
    }

    func parse_decls(mut self) []ast.Decl {
        mut decls := @vec(ast.Decl);
        while self.tok.kind != .EndOfFile {
            decls.push(self.parse_decl());
        }
        return decls;
    }

    func parse_decl(mut self) ast.Decl {
        doc_comment := self.parse_doc_comment();
        /*
        annotations := self.parse_annotations(
            self.tok.kind == .Bang and self.peek_tok.kind == .Lbracket
        );
        */
        is_public := self.inside_trait or self.is_public();
        pos := self.tok.pos;
        switch {
            self.tok.kind != .EndOfFile => {
                report.error("expected declaration, found {}".fmt(self.tok), pos).emit();
                self.next();
            }
        }
        return .EmptyDecl();
    }
}
