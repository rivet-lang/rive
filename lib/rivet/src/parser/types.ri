// Copyright (C) 2023-present Jose Mendoza - All rights reserved. Use of this
// source code is governed by an MIT license that can be found in the LICENSE
// file.

import ../{ ast, report };

extend Parser {
    func parse_type(+mut self) -> +mut ast.Type {
        mut pos := self.tok.pos;
        return match {
            self.accept(.Question) -> +mut .Option(
                self.parse_type(), pos + self.prev_tok.pos
            ),
            self.tok.kind == .KwFunc -> {
                // function types
                self.expect(.KwFunc);
                self.expect(.Lparen);
                mut args := []+mut ast.Arg();
                if self.tok.kind != .Rparen {
                    while {
                        arg_pos := self.tok.pos;
                        is_mut := self.accept(.KwMut);
                        arg_type := self.parse_type();
                        args.push(ast.Arg(
                            name: "arg{}".fmt(args.len),
                            is_mut: is_mut,
                            type: arg_type,
                            has_def_expr: false,
                            pos: arg_pos + self.prev_tok.pos
                        ));
                        if !self.accept(.Comma) {
                            break;
                        }
                    }
                }
                self.expect(.Rparen);
                ret_type := if self.accept(.Arrow) {
                    self.parse_type()
                } else {
                    .Void
                };
                +mut .Func(args: args, ret_type: ret_type, pos: pos + self.prev_tok.pos)
            },
            self.accept(.Amp) -> {
                // pointers
                is_mut := self.accept(.KwMut);
                if self.tok.kind == .Mul {
                    err := report.error_builder("cannot declare pointer to pointer", pos + self.tok.pos);
                    err.add_help("use an indexable pointer instead (`[&]T`)");
                    err.emit();
                }
                +mut .Pointer(self.parse_type(), is_mut, pos: pos + self.prev_tok.pos)
            },
            self.accept(.Lbracket) -> {
                // arrays or dynamic arrays
                if self.tok.kind != .Rbracket {
                    if self.accept(.Amp) {
                        // indexable pointers
                        self.expect(.Rbracket);
                        is_mut := self.accept(.KwMut);
                        .Pointer(
                            self.parse_type(), is_mut, true, pos: pos + self.prev_tok.pos
                        )
                    } else if self.accept(.Colon) {
                        // slice
                        self.expect(.Rbracket);
                        is_mut := self.accept(.KwMut);
                        .Slice(self.parse_type(), is_mut, pos: pos + self.prev_tok.pos)
                    } else {
                        // array
                        size := self.parse_expr();
                        self.expect(.Rbracket);
                        is_mut := self.accept(.KwMut);
                        .Array(self.parse_type(), is_mut, size, pos: pos + self.prev_tok.pos)
                    }
                } else {
                    self.expect(.Rbracket);
                    is_mut := self.accept(.KwMut);
                    +mut .DynArray(self.parse_type(), is_mut, pos: pos + self.prev_tok.pos)
                }
            },
            self.accept(.Lparen) -> {
                // tuples
                mut inners := []+mut ast.Type();
                while {
                    inners.push(self.parse_type());
                    if !self.accept(.Comma) {
                        break;
                    }
                }
                if inners.len > 8 {
                    err := report.error_builder("tuples can have a maximum of 8 types", pos + self.tok.pos);
                    err.add_help("you can use a struct instead");
                    err.emit();
                }
                pos += self.tok.pos;
                self.expect(.Rparen);
                +mut .Tuple(inners, pos: pos)
            },
            self.accept(.Ellipsis) -> +mut .Variadic(
                self.parse_type(), pos: pos + self.prev_tok.pos
            ),
            self.accept(.KwSelfTy) -> +mut .Basic(
                expr: +mut ast.Expr.SelfTy(self.scope, self.prev_tok.pos),
                is_unresolved: true
            ),
            self.tok.kind in [.Plus, .Name] -> {
                prev_tok_kind := self.prev_tok.kind;
                is_boxed := self.accept(.Plus);
                is_mut := is_boxed && self.accept(.KwMut);
                if self.accept(.KwSelfTy) {
                    return .Basic(
                        expr: +mut ast.Expr.SelfTy(self.scope, self.prev_tok.pos),
                        is_unresolved: true, is_boxed: is_boxed, is_mut: is_mut
                    );
                }
                mut expr := self.parse_ident();
                if self.accept(.Dot) {
                    expr = self.parse_selector_expr(expr);
                    while self.accept(.Dot) {
                        expr = self.parse_selector_expr(expr);
                    }
                    +mut .Basic(expr: expr, is_unresolved: true, is_boxed: is_boxed, is_mut: is_mut)
                } else {
                    // normal type
                    expr_name := @as(ast.Expr.Ident, expr).name;
                    expr_pos := expr.position();
                    match expr_name {
                        "never" -> {
                            if prev_tok_kind != .Arrow {
                                report.error("invalid use of `never` type", pos);
                            }
                            +mut .Never(self.prev_tok.pos)
                        },
                        "rawptr" -> +mut .Rawptr(self.prev_tok.pos),
                        "boxedptr" -> +mut .Boxedptr(self.prev_tok.pos),
                        "bool" -> +mut .Basic(self.env.bool_sym, pos: expr_pos),
                        "rune" -> +mut .Basic(self.env.rune_sym, pos: expr_pos),
                        "int8" -> +mut .Basic(self.env.int8_sym, pos: expr_pos),
                        "int16" -> +mut .Basic(self.env.int16_sym, pos: expr_pos),
                        "int32" -> +mut .Basic(self.env.int32_sym, pos: expr_pos),
                        "int64" -> +mut .Basic(self.env.int64_sym, pos: expr_pos),
                        "int" -> +mut .Basic(self.env.int_sym, pos: expr_pos),
                        "uint8" -> +mut .Basic(self.env.uint8_sym, pos: expr_pos),
                        "uint16" -> +mut .Basic(self.env.uint16_sym, pos: expr_pos),
                        "uint32" -> +mut .Basic(self.env.uint32_sym, pos: expr_pos),
                        "uint64" -> +mut .Basic(self.env.uint64_sym, pos: expr_pos),
                        "uint" -> +mut .Basic(self.env.uint_sym, pos: expr_pos),
                        "float32" -> +mut .Basic(self.env.float32_sym, pos: expr_pos),
                        "float64" -> +mut .Basic(self.env.float64_sym, pos: expr_pos),
                        "string" -> +mut .Basic(self.env.string_sym, pos: expr_pos),
                        "comptime_int" -> +mut .Basic(self.env.comptime_int_sym, pos: expr_pos),
                        "comptime_float" -> +mut .Basic(self.env.comptime_float_sym, pos: expr_pos),
                        else -> +mut .Basic(
                            expr: expr, is_unresolved: true, is_boxed: is_boxed, is_mut: is_mut
                        )
                    }
                }
            },
            else -> {
                report.error("expected type, found {}".fmt(self.tok), pos);
                self.next();
                +mut .Basic(expr: .Empty(pos), is_unresolved: true)
            }
        };
    }
}
