// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/strconv;

import ../ast;
import ../prefs;
import ../token;
import ../report;

struct Prelude {
    name: string;
    sym: ast.Sym;
}

[boxed]
public struct Resolver {
    mut table: ast.Table;
    mut prefs: prefs.Prefs;

    mut sym: ast.Sym;
    mut self_sym: ast.TypeSym;
    mut preludes: []Prelude;

    mut self_sym_is_set: bool;

    mut source_file: ast.SourceFile;

    public func resolve_files(mut self, source_files: []ast.SourceFile) {
        Register(self.table, self.prefs).walk_files(source_files);
        if report.total_errors() > 0 {
            return;
        }
        self.preludes = [
            Prelude("Error", self.table.error_sym)
        ];
        for sf in source_files {
            self.sym = sf.mod;
            self.source_file = sf;
            self.resolve_decls(self.source_file.decls);
            // check unused imports
            for imported_sym in sf.imported_symbols.syms {
                if !imported_sym.is_used and imported_sym.name != "_" {
                    report.warn(
                        "{} `{}` is imported but never used".fmt(
                            imported_sym.sym.type_of(), imported_sym.sym.name
                        ), imported_sym.pos
                    );
                }
            }
        }
    }

    func resolve_decls(mut self, decls: []ast.Decl) {
        for decl in decls {
            old_sym := self.sym;
            old_self_sym := self.self_sym;
            old_self_sym_is_set := self.self_sym_is_set;
            switch decl is {
                .Empty as empty_pos => report.error("BUG: empty declaration found", empty_pos),
                .Extern as extern_decl => self.resolve_decls(extern_decl.decls),
                .Alias as alias_decl => if alias_decl.is_typealias {
                    _ = self.resolve_type(alias_decl.parent_type);
                } else {
                    sym_ref := @cast(ast.SymRef, alias_decl.sym);
                    self.resolve_expr(sym_ref.ref_expr);
                    if sym_ref.ref_expr is .Ident as ident and ident.found and ident.is_sym {
                        sym_ref.ref = ident.sym;
                        sym_ref.ref_resolved = true;
                    } else if sym_ref.ref_expr is .Selector as selector and selector.found {
                        sym_ref.ref = selector.sym;
                        sym_ref.ref_resolved = true;
                    }
                },
                .Const as const_decl => if self.resolve_type(const_decl.type) {
                    self.resolve_expr(const_decl.expr)
                },
                .Var as var_decl => {
                    for left in var_decl.lefts {
                        self.check_variable_shadowing(left.name, left.pos);
                        _ = self.resolve_type(left.type);
                    }
                    if !var_decl.is_extern {
                        self.resolve_expr(var_decl.right);
                    }
                },
                .Trait as trait_decl => {
                    self.self_sym = @cast(ast.TypeSym, trait_decl.sym);
                    self.self_sym_is_set = true;
                    for mut base in trait_decl.bases {
                        if self.resolve_type(base) {
                            base_sym := base.symbol()?;
                            if base_sym.info is .Trait as mut trait_info {
                                trait_info.bases.push(base_sym);
                                for impl in trait_info.implements {
                                    if impl.info is .Struct as struct_info {
                                        if !struct_info.contains_trait(base_sym) {
                                            trait_info.implement(impl);
                                            struct_info.traits.push(base_sym);
                                        }
                                    }
                                }
                            } else {
                                report.error(
                                    "type `{}` is not a trait".fmt(base_sym.name),
                                    base.position()
                                );
                            }
                        }
                    }
                    self.resolve_decls(trait_decl.decls);
                },
                .Enum as enum_decl => {
                    if self.resolve_type(enum_decl.underlying_type) {
                        self.self_sym = @cast(ast.TypeSym, enum_decl.sym);
                        self.self_sym_is_set = true;
                        enum_info := @cast(ast.TypeInfo.Enum, self.self_sym.info);
                        for variant in enum_info.variants {
                            if !self.resolve_type(variant.type) {
                                continue;
                            }
                        }
                        for mut base in enum_decl.bases {
                            if self.resolve_type(base) {
                                base_sym := base.symbol()?;
                                if base_sym.info is .Trait as trait_info {
                                    trait_info.implements.push(base_sym);
                                } else {
                                    report.error(
                                        "type `{}` is not a trait".fmt(
                                            base_sym.name
                                        ), base.position()
                                    );
                                }
                            }
                        }
                        for variant in enum_decl.variants {
                            if !variant.decls.is_empty() {
                                self.self_sym = variant.type.symbol() ?? self.self_sym;
                                self.resolve_decls(variant.decls);
                            }
                        }
                        self.resolve_decls(enum_decl.decls);
                    }
                },
                .Struct as struct_decl => {
                    self.self_sym = @cast(ast.TypeSym, struct_decl.sym);
                    self.self_sym_is_set = true;
                    for mut base in struct_decl.bases {
                        if self.resolve_type(base) {
                            struct_info := @cast(ast.TypeInfo.Struct, self.self_sym.info);
                            base_sym := base.symbol()?;
                            if base_sym.info is .Trait as mut trait_info {
                                struct_info.traits.push(base_sym);
                                trait_info.implement(self.self_sym);
                            } else if base_sym.info is .Struct as struct_info2 {
                                struct_info.bases.push(base_sym);
                                for b_trait in struct_info2.traits {
                                    @cast(ast.TypeInfo.Trait, b_trait.info).implement(
                                        self.self_sym
                                    );
                                }
                            } else {
                                report.error(
                                    "type `{}` is not a trait or struct".fmt(
                                        base_sym.name
                                    ), base.position()
                                );
                            }
                        }
                    }
                    self.resolve_decls(struct_decl.decls);
                },
                .Extend as extend_decl => if self.resolve_type(extend_decl.type) {
                    self_sym := extend_decl.type.symbol()?;
                    self.self_sym = self_sym;
                    self.self_sym_is_set = true;
                    for mut base in extend_decl.bases {
                        if self.resolve_type(base) {
                            base_sym := base.symbol()?;
                            if base_sym.info is .Trait as trait_info {
                                trait_info.implements.push(self.self_sym);
                            } else if self.self_sym.info is .Struct as struct_info
                                and base_sym.info is .Struct {
                                struct_info.bases.push(base_sym);
                            } else {
                                report.error(
                                    "type `{}` is not a trait or a struct".fmt(
                                        base_sym.name
                                    ), base.position()
                                );
                            }
                        }
                    }
                    self.resolve_decls(extend_decl.decls);
                },
                .Field as field_decl => {
                    _ = self.resolve_type(field_decl.type);
                    if field_decl.has_def_expr {
                        self.resolve_expr(field_decl.def_expr);
                    }
                },
                .Func as func_decl => {
                    if func_decl.is_method {
                        mut self_type := ast.Type.Basic(self.self_sym);
                        if func_decl.self_is_ref {
                            self_type = .Reference(self_type);
                        }
                        func_decl.scope.add_local(ast.Var(
                            name: "self",
                            is_mut: func_decl.self_is_mut,
                            level: .Receiver,
                            type: self_type,
                            pos: func_decl.pos
                        )) catch |err| report.error(
                            err.to_string(), func_decl.pos
                        );
                        func_decl.self_type = self_type;
                        @cast(ast.Func, func_decl.sym).self_type = self_type;
                    }
                    for arg in func_decl.args {
                        if self.resolve_type(arg.type) {
                            self.check_variable_shadowing(arg.name, arg.pos);
                            func_decl.scope.add_local(ast.Var(
                                is_mut: arg.is_mut,
                                name: arg.name,
                                level: .Argument,
                                pos: arg.pos,
                                type: arg.type
                            )) catch |err| report.error(
                                err.to_string(), arg.pos
                            );
                        }
                    }
                    _ = self.resolve_type(func_decl.ret_type);
                    for mut stmt in func_decl.stmts {
                        self.resolve_stmt(stmt);
                    }
                },
                .Test as test_decl => {
                    for mut stmt in test_decl.stmts {
                        self.resolve_stmt(stmt);
                    }
                }
            }
            self.sym = old_sym;
            self.self_sym = old_self_sym;
            self.self_sym_is_set = old_self_sym_is_set;
        }
    }

    func check_vis(self, sym: ast.Sym, pos: token.Pos) {
        if !sym.is_public and !self.source_file.mod.has_access_to(sym) {
            report.error("{} `{}` is private".fmt(sym.type_of(), sym.name), pos);
        }
    }

    func eval_size(mut self, mut expr: ast.Expr) ?isize {
        return switch expr is {
            .Paren as paren => self.eval_size(paren.expr),
            .IntegerLiteral as int_lit => @cast(
                isize, strconv.parse_int(int_lit.value, 0, isize.bits()) catch return none
            ),
            .Ident as mut ident => {
                self.resolve_ident(ident);
                if ident.found {
                    self.eval_sym(ident.sym, ident.pos)
                } else {
                    none
                }
            },
            .Selector as mut selector => {
                self.resolve_selector(selector);
                if selector.found {
                    self.eval_sym(selector.sym, selector.pos)
                } else {
                    none
                }
            },
            .Binary as binary => if left := self.eval_size(binary.left) {
                if right := self.eval_size(binary.right) {
                    switch binary.op {
                        .Plus => left + right,
                        .Minus => left - right,
                        .Mul => left * right,
                        .Div => left / right,
                        .Mod => left % right,
                        .Amp => left & right,
                        .Pipe => left | right,
                        .Xor => left ^ right,
                        .Lshift => @cast(isize, @cast(usize, left) << right),
                        .Rshift => left >> right,
                        else => none
                    }
                } else {
                    none
                }
            } else {
                none
            },
            else => none
        };
    }

    func eval_sym(mut self, sym: ast.Sym, pos: token.Pos) ?isize {
        if sym is ast.Const as const_ {
            if !const_.has_evaled_size {
                const_.evaled_size = self.eval_size(const_.expr)?;
            }
            return const_.evaled_size;
        }
        report.error("`{}` is not a constant value".fmt(sym.name), pos);
        return none;
    }

    func check_variable_shadowing(self, name: string, pos: token.Pos) {
        if self.source_file.imported_symbols.exists(name) {
            report.error(
                "name `{}` hide an imported symbol".fmt(name), pos
            );
        }
    }
}
