// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../prefs;
import ../report;

extend Resolver {
    [inline]
    func resolve_type(self, type: ast.Type) bool {
        return switch type is {
            .Void, .Never, .Anyptr => true,
            .Option as opt => self.resolve_type(opt.inner),
            .Result as res => self.resolve_type(res.inner),
            .Vector as vec => self.resolve_type(vec.inner),
            .Reference as ref => self.resolve_type(ref.inner),
            .Pointer as ptr => self.resolve_type(ptr.inner),
            .Basic as basic => if basic.is_unresolved {
                switch basic.expr is {
                    .SelfTy as self_ty => if self.self_sym_is_set {
                        //self_ty.
                        true
                    } else {
                        false
                    },
                    else => {
                        report.error(
                            "expected type, found expression", basic.expr.position()
                        );
                        false
                    }
                }
            } else {
                true
            }
        };
    }
}
