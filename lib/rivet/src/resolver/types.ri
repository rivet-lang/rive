// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../report;

extend Resolver {
    func resolve_type(mut self, mut type: ast.Type) -> bool {
        return match type is {
            .Void, .Never, .Rawptr -> true,
            .Option(opt) -> self.resolve_type(opt.inner),
            .Result(res) -> self.resolve_type(res.inner),
            .Variadic(variadic) -> if self.resolve_type(variadic.inner) {
                elem_sym := variadic.inner.symbol()?;
                if elem_sym.info is .Trait(trait_info) {
                    trait_info.has_objects = true;
                }
                variadic.sym = self.table.universe.add_or_get_dyn_array(variadic.inner, false);
                true
            } else {
                false
            },
            .DynArray(vec) -> if self.resolve_type(vec.inner) {
                vec.sym = self.table.universe.add_or_get_dyn_array(vec.inner, vec.is_mut);
                true
            } else {
                false
            },
            .Array(arr) -> if self.resolve_type(arr.inner) {
                if arr_size := self.eval_size(arr.size) {
                    if arr_size <= 0 {
                        mut err := report.error_builder(
                            "array size cannot be zero or negative", arr.size.position()
                        );
                        err.add_note("array size is {}", arr_size);
                        err.emit();
                        false
                    } else {
                    	arr.size_value = @as(uint, arr_size);
                        arr.sym = self.table.universe.add_or_get_array(
                            arr.inner, arr.size_value, arr.is_mut
                        );
                        true
                    }
                } else {
                    report.error(
                        "array size cannot use non-constant value", arr.size.position()
                    );
                    false
                }
            } else {
                false
            },
            .Pointer(ptr) -> self.resolve_type(ptr.inner),
            .Tuple(tuple) -> {
                mut resolved := false;
                for mut inner in tuple.inners {
                    resolved = self.resolve_type(inner);
                }
                if resolved {
                    tuple.sym = self.table.universe.add_or_get_tuple(tuple.inners);
                }
                resolved
            },
            .Func(func_t) -> {
                mut res1 := false;
                for arg in func_t.args {
                    res1 = self.resolve_type(arg.type);
                }
                res1 = self.resolve_type(func_t.ret_type);
                func_t.sym = self.table.universe.add_or_get_func(func_t.symbol());
                func_t.has_sym = true;
                res1
            },
            .Basic(basic) -> if basic.is_unresolved {
                match basic.expr is {
                    .SelfTy -> if self.self_sym_is_set {
                        basic.is_unresolved = false;
                        basic.sym = self.self_sym;
                        true
                    } else {
                        false
                    },
                    .Ident(mut ident) -> {
                        self.resolve_ident(ident);
                        if ident.found {
                            if ident.sym is ast.TypeSym(type_sym) {
                                basic.is_unresolved = false;
                                basic.sym = type_sym;
                                if type_sym.info is .Alias(alias_info) {
                                    if self.resolve_type(alias_info.parent) {
                                        type.unalias_in_place();
                                    }
                                }
                            } else {
                                report.error(
                                    "expected type, found {}".fmt(ident.sym.type_of()),
                                    ident.pos
                                );
                            }
                        }
                        ident.found
                    },
                    .Selector(mut selector) -> {
                        self.resolve_selector(selector);
                        if selector.found {
                            if selector.sym is ast.TypeSym(type_sym) {
                                if type_sym.info is .Placeholder {
                                    report.error(
                                        "cannot find type `{}` in {} `{}`".fmt(
                                            type_sym.name, selector.left_sym.type_of(),
                                            selector.left_sym.name
                                        ),
                                        selector.field_pos
                                    );
                                    return false;
                                } else {
                                    basic.is_unresolved = false;
                                    basic.sym = type_sym;
                                    if type_sym.info is .Alias(alias_info) {
                                        if self.resolve_type(alias_info.parent) {
                                            type.unalias_in_place();
                                        }
                                    }
                                    return true;
                                }
                            } else {
                                report.error(
                                    "expected type, found {}".fmt(selector.sym.type_of()),
                                    selector.pos
                                );
                                return false;
                            }
                        }
                        selector.found
                    },
                    else -> {
                        report.error("expected type, found expression", basic.expr.position());
                        false
                    }
                }
            } else {
                true
            },
            else -> false
        };
    }
}