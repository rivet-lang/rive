// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import ../ast;
import ../report;

extend Resolver {
    func resolve_type(mut self, mut type: ast.Type) -> bool {
        return switch type is {
            .Void, .Never, .Anyptr => true,
            .Option as opt => self.resolve_type(opt.inner),
            .Result as res => self.resolve_type(res.inner),
            .Variadic as variadic => if self.resolve_type(variadic.inner) {
                elem_sym := variadic.inner.symbol()?;
                if elem_sym.info is .Trait as trait_info {
                    trait_info.has_objects = true;
                }
                variadic.sym = self.table.universe.add_or_get_vec(variadic.inner, false);
                true
            } else {
                false
            },
            .Vector as vec => if self.resolve_type(vec.inner) {
                vec.sym = self.table.universe.add_or_get_vec(vec.inner, vec.is_mut);
                true
            } else {
                false
            },
            .Array as arr => if self.resolve_type(arr.inner) {
                if arr_size := self.eval_size(arr.size) {
                    if arr_size <= 0 {
                        mut err := report.error_builder(
                            "array size cannot be zero or negative", arr.size.position()
                        );
                        err.add_note("array size is {}", arr_size);
                        err.emit();
                        false
                    } else {
                    	arr.size_value = @as(usize, arr_size);
                        arr.sym = self.table.universe.add_or_get_array(
                            arr.inner, arr.size_value, arr.is_mut
                        );
                        true
                    }
                } else {
                    report.error(
                        "array size cannot use non-constant value", arr.size.position()
                    );
                    false
                }
            } else {
                false
            },
            .Pointer as ptr => self.resolve_type(ptr.inner),
            .Tuple as tuple => {
                mut resolved := false;
                for mut inner in tuple.inners {
                    resolved = self.resolve_type(inner);
                }
                if resolved {
                    tuple.sym = self.table.universe.add_or_get_tuple(tuple.inners);
                }
                resolved
            },
            .Func as func_t => {
                mut res1 := false;
                for arg in func_t.args {
                    res1 = self.resolve_type(arg.type);
                }
                res1 = self.resolve_type(func_t.ret_type);
                func_t.sym = self.table.universe.add_or_get_func(func_t.symbol());
                func_t.has_sym = true;
                res1
            },
            .Basic as basic => if basic.is_unresolved {
                switch basic.expr is {
                    .SelfTy => if self.self_sym_is_set {
                        basic.is_unresolved = false;
                        basic.sym = self.self_sym;
                        true
                    } else {
                        false
                    },
                    .Ident as mut ident => {
                        self.resolve_ident(ident);
                        if ident.found {
                            if ident.sym is ast.TypeSym as type_sym {
                                basic.is_unresolved = false;
                                basic.sym = type_sym;
                                if type_sym.info is .Alias as alias_info {
                                    if self.resolve_type(alias_info.parent) {
                                        type.unalias_in_place();
                                    }
                                }
                            } else {
                                report.error(
                                    "expected type, found {}".fmt(ident.sym.type_of()),
                                    ident.pos
                                );
                            }
                        }
                        ident.found
                    },
                    .Selector as mut selector => {
                        self.resolve_selector(selector);
                        if selector.found {
                            if selector.sym is ast.TypeSym as type_sym {
                                if type_sym.info is .Placeholder {
                                    report.error(
                                        "cannot find type `{}` in {} `{}`".fmt(
                                            type_sym.name, selector.left_sym.type_of(),
                                            selector.left_sym.name
                                        ),
                                        selector.field_pos
                                    );
                                    return false;
                                } else {
                                    basic.is_unresolved = false;
                                    basic.sym = type_sym;
                                    if type_sym.info is .Alias as alias_info {
                                        if self.resolve_type(alias_info.parent) {
                                            type.unalias_in_place();
                                        }
                                    }
                                    return true;
                                }
                            } else {
                                report.error(
                                    "expected type, found {}".fmt(selector.sym.type_of()),
                                    selector.pos
                                );
                                return false;
                            }
                        }
                        selector.found
                    },
                    else => {
                        report.error("expected type, found expression", basic.expr.position());
                        false
                    }
                }
            } else {
                true
            },
            else => false
        };
    }
}
