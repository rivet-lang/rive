// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import std/traits;
import std/console;
import std/process;
import std/console/styles;

public const LF: uint8 = 10;
public const CR: uint8 = 13;

public static mut stderrSupportStyles = styles.stderr_support_styles();

@[inline]
public func min(a: usize, b: usize) -> usize {
   return if a < b { a } else { b };
}

@[inline]
public func max(a: usize, b: usize) -> usize {
   return if a > b { a } else { b };
}

public func option(args: []string, param: string) -> ?string {
    for i, arg in args {
        if param == arg {
            if i + 1 < args.len {
                return args[i + 1];
            }
            break;
        }
    }
    return none;
}

public func error(msg: string, args: ...traits.Stringable) -> never {
   console.eprintln("{} {} {}", bold("rivet:"), bold(red("error:")), msg.fmt(args));
   process.exit(1);
}

@[inline]
public func warn(msg: string, args: ...traits.Stringable) {
   console.eprintln("{} {} {}", bold("rivet:"), bold(yellow("warning:")), msg.fmt(args));
}

@[inline]
public func info(msg: string, args: ...traits.Stringable) {
   console.eprintln("{} {} {}", bold("rivet:"), bold(blue("info:")), msg.fmt(args));
}

@[inline]
public func bold(msg: string) -> string {
    return if stderrSupportStyles { styles.bold(msg) } else { msg };
}

@[inline]
public func red(msg: string) -> string {
    return if stderrSupportStyles { styles.red(msg) } else { msg };
}

@[inline]
public func yellow(msg: string) -> string {
    return if stderrSupportStyles { styles.yellow(msg) } else { msg };
}

@[inline]
public func cyan(msg: string) -> string {
    return if stderrSupportStyles { styles.cyan(msg) } else { msg };
}

@[inline]
public func blue(msg: string) -> string {
    return if stderrSupportStyles { styles.blue(msg) } else { msg };
}

@[inline]
public func green(msg: string) -> string {
    return if stderrSupportStyles { styles.green(msg) } else { msg };
}

/// Rounds the number `n` up to the next mult
/// NOTE: `multiple` must be a power of 2.@[inline]
public func round_up(n: usize, multiple: usize) -> usize {
    n_ := @as(isize, n);
    multiple_ := @as(isize, multiple);
    return @as(usize, (n_ + multiple_ - 1) & (-multiple_));
}
