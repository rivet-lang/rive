// Copyright (C) 2023-present Jose Mendoza - All rights reserved. Use of this
// source code is governed by an MIT license that can be found in the LICENSE
// file.

import std/{ traits, console, process, console/styles };

pub const LF: uint8 := 10;
pub const CR: uint8 := 13;

pub var mut support_ansi_escape_codes := styles.support_ansi_escape_codes();

pub var tabs_table := [
    "",
    "\t",
    "\t\t",
    "\t\t\t",
    "\t\t\t\t",
    "\t\t\t\t\t",
    "\t\t\t\t\t\t",
    "\t\t\t\t\t\t\t",
    "\t\t\t\t\t\t\t\t",
    "\t\t\t\t\t\t\t\t\t",
    "\t\t\t\t\t\t\t\t\t\t"
];

pub proc tabs(n: uint) -> string {
    return if n < tabs_table.len {
        tabs_table[n]
    } else {
        "\t".repeat(n)
    };
}

#[inline]
pub proc min(a: uint, b: uint) -> uint {
   return if a < b { a } else { b };
}

#[inline]
pub proc max(a: uint, b: uint) -> uint {
   return if a > b { a } else { b };
}

pub proc option(args: []string, param: string) -> ?string {
    for i, arg in args {
        if param == arg {
            if i + 1 < args.len {
                return args[i + 1];
            }
            break;
        }
    }
    return none;
}

pub proc error(msg: string, args: ...traits.Stringable) -> never {
   console.ewriteln("{} {} {}", bold("rivet:"), bold(red("error:")), msg.fmt(args));
   process.exit(1);
}

#[inline]
pub proc warn(msg: string, args: ...traits.Stringable) {
   console.ewriteln("{} {} {}", bold("rivet:"), bold(yellow("warning:")), msg.fmt(args));
}

#[inline]
pub proc info(msg: string, args: ...traits.Stringable) {
   console.ewriteln("{} {} {}", bold("rivet:"), bold(blue("info:")), msg.fmt(args));
}

#[inline]
pub proc bold(msg: string) -> string {
    return if support_ansi_escape_codes { styles.bold(msg) } else { msg };
}

#[inline]
pub proc red(msg: string) -> string {
    return if support_ansi_escape_codes { styles.red(msg) } else { msg };
}

#[inline]
pub proc yellow(msg: string) -> string {
    return if support_ansi_escape_codes { styles.yellow(msg) } else { msg };
}

#[inline]
pub proc cyan(msg: string) -> string {
    return if support_ansi_escape_codes { styles.cyan(msg) } else { msg };
}

#[inline]
pub proc blue(msg: string) -> string {
    return if support_ansi_escape_codes { styles.blue(msg) } else { msg };
}

#[inline]
pub proc green(msg: string) -> string {
    return if support_ansi_escape_codes { styles.green(msg) } else { msg };
}

/// Rounds the number `n` up to the next mult
/// NOTE: `multiple` must be a power of 2.
#[inline]
pub proc round_up(n: uint, multiple: uint) -> uint {
    n_ := @as(int, n);
    multiple_ := @as(int, multiple);
    return @as(uint, (n_ + multiple_ - 1) & (-multiple_));
}
