// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import { Builder } from std/strings;

const BACKSLASH: uint8 = 92;
const BACKSLASH_R: uint8 = 13;
const BACKSLASH_N: uint8 = 10;
const DOUBLE_QUOTE: uint8 = 34;
var DOUBLE_ESCAPE = "\\\\";
var INVALID_ESCAPES = b"({`.";

public func smart_quote(s: string, raw: bool = false) string {
    if s.len == 0 {
        return "";
    } else if s.len < 256 {
        mut is_pure := true;
        mut i: usize := 0;
        while i < s.len : i += 1 {
            ch := s[i];
            if (ch >= 37 and ch <= 90) or (ch >= 95 and ch <= 126)
                or (ch in [b' ', b'!', b'#', b'[', b']']) {
                // safe punctuation + digits + big latin letters, small latin
                // letters + more safe punctuation, important punctuation exceptions,
                // that are not placed conveniently in a consequitive span in the ASCII
                // table.
                continue;
            }
            is_pure = false;
            break;
        }
        if is_pure {
            return s;
        }
    }
    // ensure there is enough space for the potential expansion of several b'\\' or b'\n'
    mut result := Builder.new(s.len + 10);
    mut pos: int64 := -1;
    mut current: uint8 := 0;
    mut next: uint8 := 0;
    mut skip_next := false;
    while {
        pos += 1;
        if skip_next {
            skip_next = false;
            pos += 1;
        }
        if pos >= @cast(int64, s.len) {
            break;
        }
        pos_1 := @cast(usize, pos);
        current = s[pos_1];
        pos_2 := pos_1 + 1;
        next = if pos_1 < s.len {
            s[pos_2]
        } else {
            0
        };
        switch current {
            DOUBLE_QUOTE => {
                current = 0;
                result.write_byte(BACKSLASH);
                result.write_byte(DOUBLE_QUOTE);
            },
            BACKSLASH => {
                if raw {
                    result.write_string(DOUBLE_ESCAPE);
                } else if next == BACKSLASH {
                    // escaped backslash - keep as is
                    current = 0;
                    skip_next = true;
                    result.write_string(DOUBLE_ESCAPE);
                } else if next != 0 {
                    if raw {
                        skip_next = true;
                        result.write_string(DOUBLE_ESCAPE);
                        continue;
                    }
                    if arr_4_uint8_contains(INVALID_ESCAPES, next) {
                        current = 0;
                        skip_next = true;
                        result.write_byte(next);
                        continue;
                    }
                    // keep all valid escape sequences
                    skip_next = true;
                    result.write_byte(current);
                    result.write_byte(next);
                    current = 0;
                }
            },
            BACKSLASH_N => {
                // keep newlines in string
                current = 0;
                result.write_byte(BACKSLASH);
                result.write_byte(b'n');
            },
            BACKSLASH_R if next == BACKSLASH_N => {
                result.write_byte(current);
                result.write_byte(next);
                current = 0;
                skip_next = true;
            },
            else => result.write_byte(current)
        }
    }
    return result.to_string();
}
