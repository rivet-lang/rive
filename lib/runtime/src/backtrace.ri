// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

#if !_RELEASE_ // skip backtrace in release mode

#![compile_c_source("lib/runtime/thirdparty/libbacktrace/backtrace.c")]

import "c";

struct backtrace_state;

struct BacktraceData {
    mut has_error: bool;
}

type BacktraceErrorCB = fn (mut_anyptr, ?*mut u8, i32);
type BacktraceFullCB = fn (mut_anyptr, i32, ?*mut u8, i32, ?*mut u8) i32;

extern (C) {
    fn backtrace_create_state(
        filename: *u8, threaded: bool, error_cb: BacktraceErrorCB,
        data: ?mut_anyptr
    ) ?*mut backtrace_state;

    fn backtrace_full(
        state: *backtrace_state, skip: i32, cb: BacktraceFullCB,
        error_cb: BacktraceErrorCB, data: mut_anyptr
    ) i32;
}

let state: *mut backtrace_state = unsafe {
    backtrace_create_state(ARGS[0].ptr, true, bt_error_handler, nil).?
};

fn bt_print_callback(
    data: mut_anyptr, pc: i32, filename_ptr: ?*mut u8, lineno: i32, fn_ptr: ?*mut u8
) i32 {
    unsafe {
        if let safe_fn_ptr = fn_ptr {
            if mem_cmp(safe_fn_ptr, c"_R7runtime4mainF", 16) == 0 {
                return -1; // stop backtracing
            }
        }
        let fn_name = if fn_ptr is nil {
            "???"
        } else {
            demangle_symbol(string.from_raw(fn_ptr))
        };
        let file_name = if filename_ptr is nil {
            "???"
        } else {
            string.from_raw(filename_ptr)
        };
        console_eprintln("   at {} ({}:{})", fn_name, file_name, lineno);
    }
    return 0;
}

fn bt_error_handler(data: mut_anyptr, msg_ptr: ?*mut u8, errnum: i32) {
    unsafe {
        let bdata = @as(*mut BacktraceData, data);
        if !bdata.has_error {
            console_eprint("   libbacktrace error: ");
            console_eprint(string.from_raw(msg_ptr));
            if errnum > 0 {
                console_eprint(" (");
                console_eprint(c.errno_msg(errnum));
                console_eprint(")");
            }
            console_eprintln();
            bdata.has_error = true;
        }
    }
}

fn demangle_symbol(name: string) string {
    @assert(name.len > 0);
    if !name.starts_with("_R") {
        return name;
    }

    let name_ptr = unsafe { name.ptr };
    let mut idx: usize = 2;
    let mut buf = StaticBuffer();
    let mut res = StringBuilder.new(name.len);
    while idx < name.len {
        let mut byte = unsafe { name_ptr[idx] };
        if byte.is_digit() {
            buf.push(byte);
            idx += 1;
            continue;
        }

        if !res.is_empty() {
            res.write_string(".");
        }

        let buf_len = @as(usize, buf.as_u64());
        let mut i_: usize = 0;
        while i_ < buf_len : i_ += 1 {
            res.write_byte(unsafe { name_ptr[idx] });
            idx += 1;
        }

        buf.clear();

        byte = unsafe { name_ptr[idx] };
        if byte == b'F' or byte == b'M' {
            res.write_string("()");
            break;
        } else if !byte.is_digit() {
            break; // end
        }
    }
    return res.to_string();
}
#endif

pub fn bt_print(frames_to_skip: i32 = 0) {
#if _RELEASE_
    _ = frames_to_skip;
#else
    unsafe {
        if runtime_started {
            let mut data = BacktraceData();
            _ = backtrace_full(
                state, frames_to_skip, bt_print_callback, bt_error_handler, &mut data
            );
        }
    }
#endif
}
