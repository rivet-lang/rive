// Copyright (C) 2023 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import c;
import c/libc;

#[boxed]
public struct CannotMakeDirectoryError < Throwable {
    msg: string;

    public func to_string(self) -> string {
        return self.msg;
    }
}

#[boxed]
public struct CannotMakeFileError < Throwable {
    msg: string;

    public func to_string(self) -> string {
        return self.msg;
    }
}

#[boxed]
public struct CouldNotOpenDirectoryError < Throwable {
    msg: string;

    public func to_string(self) -> string {
        return self.msg;
    }
}

#[boxed]
public struct EmptyStringError < Throwable {
    msg: string;

    public func to_string(self) -> string {
        return self.msg;
    }
}

public struct Directory {
    public func make(path_: string, mode: usize = 0o777) -> ! {
        if path_ == "." {
            return;
        }
        rpath := Path.resolve(path_)!;
        if unsafe { libc.mkdir(rpath.ptr, mode) } == -1 {
            throw CannotMakeDirectoryError(
                "cannot make directory `{}`: {}".fmt(path_, c.errno_msg())
            );
        }
    }

    public func remove(dir: string) -> ! {
        rpath := Path.resolve(dir)!;
        if unsafe { libc.rmdir(rpath.ptr) == -1 } {
            throw CannotMakeFileError("cannot remove directory `{}`: {}".fmt(dir, c.errno_msg()));
        }
    }

    public func walk(path_: string, ext: string = "") -> ![]string {
        if path_.is_empty() {
            throw EmptyStringError("`Directory.walk` expects a folder, not an empty string");
        }
        rpath := Path.resolve(path_)!;
        unsafe {
            if dir := libc.opendir(path_.ptr) {
                mut res := @vec(string, 15);
                while ent := libc.readdir(dir) {
                    bptr: [&]uint8 := &ent.*.d_name[0];
                    if (bptr[0] == 0 or (bptr[0] == b'.' and bptr[1] == 0)
                        or (bptr[0] == b'.' and bptr[1] == b'.' and bptr[2] == 0)) {
                        continue;
                    }
                    bptr_str := string.from_raw(bptr);
                    if !ext.is_empty() and Path.extension(bptr_str) != ext {
                        continue;
                    }
                    full_path := Path.join(rpath, bptr_str)!;
                    res.push(full_path);
                }
                _ = libc.closedir(dir);
                return res;
            }
        }
        throw CouldNotOpenDirectoryError(
            "Directory.walk: couldn't open `{}`: {}".fmt(path_, c.errno_msg())
        );
    }
}
