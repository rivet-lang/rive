// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import "c/libc";

import "../mem";
import { Stringable } from "../traits";

public class File {
    f: *mut libc.FILE;
    mut is_opened: bool;

    public func open(path: string, mode: string = "r") !File {
        unsafe {
            if let f = libc.fopen(path.ptr, mode.ptr) {
                return Self(f, true);
            }
        }
        return Error("File.open: failed to open file '{}'".fmt(path));
    }

    /// Writes the byte `b` into the file.
    #[inline]
    public func write_byte(mut self, b: uint8) {
        _ = unsafe { libc.fputc(@as(int32, b), self.f) };
    }

    /// Writes the string `s` into the file.
    #[inline]
    public func write_string(mut self, s: string) {
        _ = unsafe { libc.fputs(s.ptr, self.f) };
    }

    /// Writes the string `s` into the file and appends a '\n' character.
    public func writeln(mut self, s: string) {
        self.write_string(s);
        self.write_byte(b'\n');
    }

    #[inline]
    public func write_string_fmt(mut self, s: string, args: ...Stringable) {
        self.write_string(s.fmt(args));
    }

    public func writeln_fmt(mut self, s: string, args: ...Stringable) {
        self.write_string(s.fmt(args));
        self.write_byte(b'\n');
    }

    /// Returns the current file contents.
    public func read_all(mut self) !string {
        if !self.is_opened {
            return "";
        }
        unsafe {
            seek := libc.fseek(self.f, 0, 2);
            if seek != 0 {
                return Error("fseek failed");
            }

            fsize := libc.ftell(self.f);
            if fsize < 0 {
                return Error("ftell failed");
            }

            libc.rewind(self.f);

            // On some systems `ftell` can return values in the 64-bit range
            // that, when cast to `int32`, can result in values below 0.
            allocate := @as(int32, fsize);
            if @as(int64, allocate) < fsize {
                return Error("{} cast to `int32` results in {}".fmt(fsize, @as(int32, fsize)));
            }

            mut res := @as([*]mut uint8, mem.alloc(@as(usize, allocate) + 1).!);
            nelements := libc.fread(res, 1, @as(usize, allocate), self.f);

            if self.eof() and libc.ferror(self.f) != 0 {
                mem.dealloc(res);
                return Error("fread failed");
            }

            res[nelements] = 0;
            return string.from_raw_with_len(res, nelements);
        }
    }

    /// Returns true if the file is at end.
    #[inline]
    public func eof(self) bool {
        return unsafe { libc.feof(self.f) != 0 };
    }

    /// Closes the current file.
    public func close(mut self) {
        if !self.is_opened {
            return;
        }
        unsafe {
            _ = libc.fflush(self.f);
            _ = libc.fclose(self.f);
        }
        self.is_opened = false;
    }
}
