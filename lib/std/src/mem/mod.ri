// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// TODO: use public import list with alias
import "runtime";

/// Allocates dynamically a `size` bytes block of memory on the heap.
/// Returns a pointer to the memory address of the allocated space.
///
/// NOTE: Unlike the `mem::alloc_zeroed` function, `mem::alloc` will
/// not zero the memory block.
pub fn alloc(size: usize) !*mut void {
    return runtime::mem_alloc(size).!;
}

/// Allocates dynamically a zeroed `n` bytes block of memory on the heap.
/// Returns a pointer to the memory address of the allocated space.
pub fn alloc_zeroed(n: usize) !*mut void {
    return runtime::mem_alloc_zeroed(n).!;
}

/// Resizes the memory block `ptr` with `sz` bytes.
///
/// NOTE: The `ptr` must be a pointer to an existing memory block previously
/// allocated with `mem::alloc` or `mem::alloc_zeroed`.
pub fn realloc(ptr: *mut void, sz: usize) !*mut void {
    return unsafe { runtime::mem_realloc(ptr, sz).! };
}

/// Fills the first `n` bytes of the memory area pointed to by `s`, with the
/// constant byte `c`.
pub fn set(s: *mut void, c: i32, n: usize) {
    unsafe { runtime::mem_set(s, c, n); }
}

/// Copies `sz` bytes from memory area `source` to memory area `dest`.
///
/// NOTE: The memory areas *MUST NOT OVERLAP*. Use `mem::move`, if the memory
/// areas do overlap.
pub fn copy(dest: *mut void, src: *void, sz: usize) {
    unsafe { runtime::mem_copy(dest, src, sz); }
}

/// Copies `sz` bytes from memory area `source` to memory area `dest`.
///
/// NOTE: The memory areas *MAY* overlap: copying takes place as though the bytes
/// in `source` are first copied into a temporary array that does not overlap
/// `source` or `dest`, and the bytes are then copied from the temporary array to
/// `dest`.
pub fn move(dest: *mut void, src: *void, sz: usize) {
    unsafe { runtime::mem_move(dest, src, sz); }
}

/// Allocates dynamically a `sz` bytes block of memory on the heap, then copies
/// the contents of `source` into the allocated space and returns a pointer to
/// the newly allocated space.
pub fn dup(src: *void, sz: usize) !*mut void {
    return unsafe { runtime::mem_dup(src, sz).! };
}

/// Compares the first `n` bytes (each interpreted as `u8`) of the memory areas
/// `s1` and `s2`. It returns an integer less than, equal to, or greater than
/// zero, if the first n bytes of `s1` is found, respectively, to be less than,
/// to match, or be greater than the first n bytes of `s2`.
///
/// For a nonzero return value, the sign is determined by the sign of the
/// difference between the first pair of bytes (interpreted as `u8`) that
/// differ in `s1` and `s2`.
///
/// If n is zero, the return value is zero.
///
/// NOTE: Do NOT use `mem::cmp` to compare security critical data, such
/// as cryptographic secrets, because the required CPU time depends on the
/// number of equal bytes. You should use a function that performs comparisons
/// in constant time for this.
pub fn cmp(s1: *void, s2: *void, n: usize) i32 {
    return unsafe { runtime::mem_cmp(s1, s2, n) };
}

/// Deallocates manually the memory referenced by `ptr`.
#[unsafe]
pub fn dealloc(ptr: *void) {
    unsafe { runtime::mem_dealloc(ptr); }
}
