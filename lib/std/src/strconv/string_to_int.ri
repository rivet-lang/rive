// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

import "std/errors" {
    InvalidSyntaxError, InvalidBaseError, InvalidBitSizeError, ValueOutOfRangeError
};

const INT_SIZE: u32 = #if _x64_ 64 #else 32 #endif;

fn lower(c: u8) u8 {
    return c | (b'x' - b'X');
}

/// This is like `string_to_int` but for unsigned numbers.
/// A sign prefix is not permitted.
pub fn string_to_uint(s_: string, base__: i32, bit_size_: u32) !u64 {
    if s_ == "" {
        return InvalidSyntaxError("empty string");
    }
    let s = s_;
    let base0 = base__ == 0;
    let mut base_ = base__;
    let mut bit_size = bit_size_;

    let mut start_index: usize = 0;
    switch {
        (base_ >= 2 and base_ <= 36) => { /* valid base; nothing to do */ },
        (base_ == 0) => {
            // look for octal, hex prefix.
            base_ = 10;
            if s[0] == b'0' {
                switch {
                    (s.len >= 3 and lower(s[1]) == b'b') => {
                        base_ = 2;
                        start_index = 2;
                    },
                    (s.len >= 3 and lower(s[1]) == b'o') => {
                        base_ = 8;
                        start_index = 2;
                    },
                    (s.len >= 3 and lower(s[1]) == b'x') => {
                        base_ = 16;
                        start_index = 2;
                    },
                    // manage leading zeros in decimal base's numbers
                    s.len >= 2 and (s[1] >= b'0' and s[1] <= b'9') => {
                        base_ = 10;
                        start_index = 1;
                    },
                    else => {
                        base_ = 8;
                        start_index = 1;
                    }
                }
            }
        },
        else => return InvalidBaseError("invalid base {}".fmt(base_))
    }

    if bit_size == 0 {
        bit_size = INT_SIZE;
    } else if bit_size < 0 or bit_size > 64 {
        return InvalidBitSizeError("invalid bit size {}".fmt(bit_size));
    }

    // Cutoff is the smallest number such that `cutoff * base > MAX_U64`.
    // Use compile-time constants for common cases.
    let cutoff: u64 = switch base_ {
        10 => u64.MAX / 10 + 1,
        16 => u64.MAX / 16 + 1,
        else => u64.MAX / as(u64, base_) + as(u64, 1)
    };

    let max_val: u64 = if bit_size == 64 {
        u64.MAX
    } else {
        (as(u64, 1) << as(u64, bit_size)) - as(u64, 1)
    };
    let mut underscores = false;
    let mut n: u64 = 0;
    for i in start_index..s.len {
        let c = s[i];
        let cl = lower(c);

        let mut d: u8 = 0;
        switch {
            (c == b'_' and base0) => {
                underscores = true;
                continue;
            },
            (b'0' <= c and c <= b'9') => d = c - b'0',
            (b'a' <= cl and cl <= b'z') => d = cl - b'a' + 1,
            else => return InvalidSyntaxError("invalid syntax")
        }

        if d >= as(u8, base_) {
            return InvalidSyntaxError("invalid syntax");
        }

        if n >= cutoff {
            // `n * base_` overflows
            return ValueOutOfRangeError("value out of range");
        }
        n *= as(u64, base_);

        let n1 = n + as(u64, d);
        if n1 < n or n1 > max_val {
            // `n + d` overflows
            return ValueOutOfRangeError("value out of range");
        }
        n = n1;
    }

    if underscores and !underscore_ok(s) {
        return InvalidSyntaxError("invalid syntax");
    }

    return n;
}

/// Interprets a string `s` in the given `base_` (0, 2 to 36) and bit size
/// (0 to 64) and returns the corresponding value i.
///
/// The string may begin with a leading sign: "+" or "-".
///
/// If the base argument is 0, the true base is implied by the string's
/// prefix following the sign (if present): 2 for "0b", 8 for "0" or "0o",
/// 16 for "0x", and 10 otherwise. Also, for argument base 0 only,
/// underscore characters are permitted as defined by the Rivet syntax for
/// integer literals.
///
/// The `bit_size` argument specifies the integer type that the result must
/// fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to i8, i16, i32, and
/// i64. If `bit_size` is below 0 or above 64, an error is returned.
pub fn string_to_int(s: string, base_: i32, bit_size_: u32) !i64 {
    if s == "" {
        return InvalidSyntaxError("invalid syntax");
    }

    // pick off leading sign.
    let mut bit_size = bit_size_;
    let mut s0 = s;
    let mut neg = false;
    if s[0] == b'+' {
        s0 = s[1..];
    } else if s[0] == b'-' {
        neg = true;
        s0 = s[1..];
    }

    // convert unsigned and check range.
    let un = string_to_uint(s0, base_, bit_size).!;
    if bit_size == 0 {
        bit_size = INT_SIZE;
    }

    let cutoff = as(u64, 1) << as(u32, bit_size - 1);
    if !neg and un >= cutoff {
        return ValueOutOfRangeError("value out of range");
    }
    if neg and un > cutoff {
        return ValueOutOfRangeError("value out of range");
    }

    return if neg { -as(i64, un) } else { as(i64, un) };
}

/// Reports whether the underscores in `s_` are allowed.
/// Checking them in this one function lets all the parsers skip over them
/// simply. Underscore must appear only between digits or between a base
/// prefix and a digit.
fn underscore_ok(s_: string) bool {
    let mut s = s_;
    // saw tracks the last character (class) we saw:
    // ^ for beginning of number,
    // 0 for a digit or base prefix,
    // _ for an underscore,
    // ! for none of the above.
    let mut saw = b'^';
    let mut i: usize = 0;

    // optional sign.
    if s.len >= 1 and (s[0] == b'-' or s[0] == b'+') {
        s = s[1..];
    }

    // optional base prefix.
    let mut hex = false;
    if s.len >= 2 and s[i] == b'0' and (
        lower(s[1]) == b'b' or lower(s[1]) == b'o' or lower(s[1]) == b'x'
    ) {
        // base prefix counts as a digit for "underscore as digit separator"
        i = 2;
        saw = b'0';
        hex = lower(s[1]) == b'x';
    }

    // number proper.
    for i_ in i..s.len {
        // digits are always okay.
        if (b'0' <= s[i_] and s[i_] <= b'9') or
            (hex and b'a' <= lower(s[i_]) and lower(s[i_]) <= b'f') {
            saw = b'0';
            continue;
        }
        // underscore must follow digit.
        if s[i_] == b'_' {
            if saw != b'0' {
                return false;
            }
            saw = b'_';
            continue;
        }
        // underscore must also be followed by digit.
        if saw == b'_' {
            return false;
        }
        // saw non-digit, non-underscore.
        saw = b'!';
    }

    return saw != b'_';
}
