# Copyright (C) 2022 The Rivet Team. All rights reserved.
# Use of this source code is governed by an MIT license
# that can be found in the LICENSE file.

import os
from enum import IntEnum as Enum, auto as auto_enum

from ..ast import sym, type
from ..ast.sym import TypeKind
from .. import ast, prefs, colors, report, utils
from ..token import Kind, OVERLOADABLE_OPERATORS_STR

MAX_INT8 = 127
MIN_INT8 = -128
MAX_INT16 = 32767
MIN_INT16 = -32768
MAX_INT32 = 2147483647
MIN_INT32 = -2147483648
MAX_INT64 = 9223372036854775807
MIN_INT64 = -9223372036854775808

MAX_UINT8 = 255
MAX_UINT16 = 65535
MAX_UINT32 = 4294967295
MAX_UINT64 = 18446744073709551615

MAX_RUNE = 0x10FFFF

def prefix_type(tt):
	prefix = ""
	if isinstance(tt, type.Ptr):
		_t = tt
		while isinstance(_t, type.Ptr):
			prefix += "ptr_"
			if tt.is_mut:
				prefix += "mut_"
			else:
				prefix += "const_"
			_t = _t.typ
		prefix += prefix_type(tt.typ)
	elif isinstance(tt, type.Ref):
		prefix += "ref_"
		if tt.is_mut:
			prefix += "mut_"
		prefix += prefix_type(tt.typ)
	elif isinstance(tt, type.Optional):
		prefix += "opt_" + prefix_type(tt.typ)
	return prefix

def mangle_type(typ):
	return prefix_type(typ) + mangle_symbol(typ.get_sym())

def mangle_symbol(s):
	if len(s.mangled_name) > 0:
		return s.mangled_name
	res = []
	root = s
	while True:
		if s.is_universe:
			break
		if isinstance(s, sym.Type):
			if s.kind.is_primitive():
				name = str(s.kind)
				name = f"{len(name)}{name}"
				res.insert(0, name)
			elif s.kind == sym.TypeKind.Tuple:
				name = "Tuple_"
				for i, tt in enumerate(s.info.types):
					name += mangle_type(tt)
					if i < len(s.info.types) - 1:
						name += "_"
				name = f"{len(name)}{name}"
				res.insert(0, name)
				s.mangled_name = name
			elif s.kind == sym.TypeKind.Slice:
				res.insert(0, "4core6_slice")
				s.mangled_name = "_R4core6_slice"
			elif s.kind == sym.TypeKind.Array:
				name = f"Array_{mangle_type(s.info.elem_typ)}_{s.info.size}"
				name = f"{len(name)}{name}"
				res.insert(0, name)
				s.mangled_name = name
			elif s.kind == sym.TypeKind.Enum:
				if isinstance(root, sym.Fn):
					name = s.name
				else:
					name = str(s.info.underlying_typ)
				name = f"{len(name)}{name}"
				res.insert(0, name)
				s.mangled_name = name
			elif s.kind == sym.TypeKind.Str:
				res.insert(0, "4core4_str")
				s.mangled_name = "_R4core4_str"
			elif s.name == "error" and s.kind == sym.TypeKind.Struct and s.parent != None and (
			    s.parent.is_core or s.parent.is_universe
			):
				res.insert(0, "4core6_error")
				s.mangled_name = "_R4core6_error"
			else:
				res.insert(0, f"{len(s.name)}{s.name}")
		elif s.name in OVERLOADABLE_OPERATORS_STR:
			name = OVERLOADABLE_OPERATORS_STR[s.name]
			name = f"{len(name)}{name}"
			res.insert(0, name)
			s.mangled_name = name
		else:
			res.insert(0, f"{len(s.name)}{s.name}")
		if s.parent == None:
			break
		s = s.parent
	res.insert(0, "_R")

	if isinstance(root, sym.Fn):
		if root.is_method:
			res.append("M")
		else:
			res.append("F")

	root.mangled_name = "".join(res)
	return root.mangled_name

class RIR:
	def __init__(self, pkg_name, types, externs, statics, decls):
		self.pkg_name = pkg_name
		self.types = types
		self.externs = externs
		self.statics = statics
		self.decls = decls

	def __repr__(self):
		sb = utils.Builder()
		sb.writeln(
		    f"// Rivet Intermediate Representation for package `{self.pkg_name}`."
		)
		sb.writeln(f"// Auto-generated by {utils.full_version()}.\n//")
		sb.writeln(
		    "// WARNING: This output format is intended for human consumers only"
		)
		sb.writeln(
		    "// and is subject to change without notice. Knock yourself out."
		)
		sb.writeln()
		for i, t in enumerate(self.types):
			sb.writeln(str(t))
			if i < len(self.types) - 1:
				sb.writeln()
		sb.writeln()
		for i, e in enumerate(self.externs):
			sb.writeln(str(e))
		sb.writeln()
		for i, s in enumerate(self.statics):
			sb.writeln(str(s))
		sb.writeln()
		for i, d in enumerate(self.decls):
			sb.writeln(str(d))
			if i < len(self.decls) - 1:
				sb.writeln()
		return str(sb)

	def __str__(self):
		return self.__repr__()

class Alias:
	def __init__(self, name, sy):
		self.name = name
		self.sy = sy

	def __str__(self):
		return f'type_alias "{self.name}" = {self.sy.qualname()}'

class VTable:
	def __init__(self, structure, name, trait_name, implement_nr, funcs):
		self.structure = structure
		self.name = name
		self.trait_name = trait_name
		self.implement_nr = implement_nr
		self.funcs = funcs

	def __str__(self):
		sb = utils.Builder()
		sb.writeln(f'vtable for "{self.trait_name}" {{')
		for i, ft in enumerate(self.funcs):
			sb.writeln(f'  {i} {{')
			for f, impl in ft.items():
				sb.writeln(f'    "{f}": "{impl}"')
			sb.write("  }")
			if i < len(self.funcs) - 1:
				sb.writeln(",")
			else:
				sb.writeln()
		sb.write("}")
		return str(sb)

class RiUnion:
	def __init__(self, is_pub, name, variants):
		self.is_pub = is_pub
		self.name = name
		self.variants = variants

	def __str__(self):
		sb = utils.Builder()
		if self.is_pub:
			sb.write("pub ")
		sb.writeln(f'type "{self.name}" {{')
		sb.writeln("  union {")
		for i, v in enumerate(self.variants):
			sb.write(f'    {v}')
			if i < len(self.variants) - 1:
				sb.writeln(",")
			else:
				sb.writeln()
		sb.writeln('  },')
		sb.writeln('  i64 "idx"')
		sb.write("}")
		return str(sb)

class Field:
	def __init__(self, name, typ):
		self.name = name
		self.typ = typ

class Struct:
	def __init__(self, is_pub, is_union, is_opaque, name, fields):
		self.is_pub = is_pub
		self.is_union = is_union
		self.is_opaque = is_opaque
		self.name = name
		self.fields = fields

	def __str__(self):
		sb = utils.Builder()
		if self.is_pub:
			sb.write("pub ")
		if self.is_opaque:
			sb.write(f'type "{self.name}" opaque')
		else:
			sb.writeln(f'type "{self.name}" {{')
			for i, f in enumerate(self.fields):
				sb.write(f'  {f.typ} "{f.name}"')
				if i < len(self.fields) - 1:
					sb.writeln(",")
				else:
					sb.writeln()
			sb.write("}")
		return str(sb)

class StaticVar:
	def __init__(self, is_pub, is_extern, typ, name):
		self.is_pub = is_pub
		self.is_extern = is_extern
		self.typ = typ
		self.name = name

	def __str__(self):
		kw = "pub " if self.is_pub else ""
		kw2 = "extern " if self.is_extern else ""
		return f'{kw}{kw2}static {self.typ} %"{self.name}"'

class ExternFn:
	def __init__(self, name, ret_typ, args, is_variadic, attrs):
		self.name = name
		self.ret_typ = ret_typ
		self.args = args
		self.is_variadic = is_variadic
		self.attrs = attrs

	def __str__(self):
		sb = utils.Builder()
		sb.write(f'extern fn "{self.name}"(')
		for i, arg in enumerate(self.args):
			sb.write(f'{arg.typ} %"{arg.name}"')
			if i < len(self.args) - 1:
				sb.write(", ")
		if self.is_variadic:
			sb.write(", ...")
		sb.write(f") {self.ret_typ}")
		return str(sb)

class FnDecl:
	def __init__(self, is_pub, name, ret_typ, args):
		self.is_pub = is_pub
		self.name = name
		self.ret_typ = ret_typ
		self.args = args
		self.locals = 0
		self.bb = list()

	def add_comment(self, comment):
		self.bb.append(Comment(comment))

	def local_name(self):
		name = f"_{self.locals}_"
		self.locals += 1
		return name

	def add_label(self, label):
		self.bb.append(Label(label))

	def add_and_get_label(self):
		label = self.local_name()
		self.add_label(label)
		return label

	def alloca(self, typ, tmp, inst):
		self.add_inst(Alloca(typ, tmp, inst))

	def alloca_var(self, var):
		self.add_inst(Inst(InstKind.Alloca, [var]))

	def store(self, var, val):
		self.add_inst(Inst(InstKind.Store, [var, val]))

	def store_ptr(self, var, val):
		self.add_inst(Inst(InstKind.StorePtr, [var, val]))

	def add_inst(self, inst):
		self.bb.append(inst)

	def add_br(self, label):
		self.add_inst(Inst(InstKind.Br, [Name(label)]))

	def add_cond_single_br(self, cond, label1):
		self.add_inst(Inst(InstKind.Br, [cond, Name(label1)]))

	def add_cond_br(self, cond, label1, label2):
		self.add_inst(Inst(InstKind.Br, [cond, Name(label1), Name(label2)]))

	def add_call(self, name, args = list()):
		args_ = [Name(name)]
		args_ += args
		self.add_inst(Inst(InstKind.Call, args_))

	def unreachable(self):
		self.add_inst(Inst(InstKind.Unreachable, []))

	def breakpoint(self):
		self.add_inst(Inst(InstKind.Breakpoint, []))

	def add_ret(self, expr):
		self.add_inst(Inst(InstKind.Ret, [expr]))

	def add_ret_void(self):
		self.add_inst(Inst(InstKind.Ret, []))

	def add_dbg_stmt_line(self, pos):
		self.add_inst(
		    Inst(
		        InstKind.DbgStmtLine,
		        [Name(pos.file), Name(str(pos.line + 1))]
		    )
		)

	def __str__(self):
		sb = utils.Builder()
		if self.is_pub:
			sb.write("pub ")
		sb.write(f'fn "{self.name}"(')
		for i, arg in enumerate(self.args):
			sb.write(f'{arg.typ} %"{arg.name}"')
			if i < len(self.args) - 1:
				sb.write(", ")
		sb.writeln(f") {self.ret_typ} {{")
		for i in self.bb:
			if isinstance(i, Label): sb.writeln()
			else: sb.write("  ")
			sb.writeln(str(i))
		sb.write("}")
		return str(sb)

class Comment:
	def __init__(self, text):
		self.text = text

	def __repr__(self):
		return f"// {self.text}"

	def __str__(self):
		return self.__repr__()

class NoneLiteral:
	def __init__(self, typ):
		self.typ = typ

	def __repr__(self):
		return "none"

	def __str__(self):
		return self.__repr__()

class IntLiteral:
	def __init__(self, typ, lit):
		self.typ = typ
		self.lit = lit

	def value(self):
		return int(self.lit, 0)

	def __repr__(self):
		return f"{self.typ} {self.lit}"

	def __str__(self):
		return self.__repr__()

class FloatLiteral:
	def __init__(self, typ, lit):
		self.typ = typ
		self.lit = lit

	def __repr__(self):
		return f"{self.typ} {self.lit}"

	def __str__(self):
		return self.__repr__()

class RuneLiteral:
	def __init__(self, typ, lit):
		self.lit = lit
		self.typ = typ

	def __repr__(self):
		return f"rune '{self.lit}'"

	def __str__(self):
		return self.__repr__()

class StringLiteral:
	def __init__(self, typ, lit, len_):
		self.typ = typ
		self.lit = lit
		self.len = len_

	def __repr__(self):
		return f'{self.typ} "{self.lit}"'

	def __str__(self):
		return self.__repr__()

class ArrayLiteral:
	def __init__(self, typ, elems, is_variadic_init = False):
		self.typ = typ
		self.elems = elems
		self.is_variadic_init = is_variadic_init

	def __repr__(self):
		if self.is_variadic_init:
			return f"{self.typ}... [{', '.join([str(e) for e in self.elems])}]"
		return f"{self.typ} [{', '.join([str(e) for e in self.elems])}]"

	def __str__(self):
		return self.__repr__()

class Ident: # Variables, local and static values
	def __init__(self, typ, name):
		self.typ = typ
		self.name = name
		self.use_arr_field = False

	def __repr__(self):
		return f'{self.typ} %"{self.name}"'

	def __str__(self):
		return self.__repr__()

class Selector: # struct/union/tuple fields
	def __init__(self, typ, left, name):
		self.typ = typ
		self.left = left
		self.name = name

	def __repr__(self):
		return f'({self.typ} ({self.left}).{self.name})'

	def __str__(self):
		return self.__repr__()

class Name: # Simple identifier, e.g. labels
	def __init__(self, name):
		self.name = name

	def __repr__(self):
		return self.name

	def __str__(self):
		return self.__repr__()

class Label:
	def __init__(self, label):
		self.label = label

	def __repr__(self):
		return f"{self.label}:"

	def __str__(self):
		return self.__repr__()

class Type:
	def __init__(self, typ):
		self.typ = typ

	def __repr__(self):
		return f"{self.typ}"

	def __str__(self):
		return self.__repr__()

class Skip:
	def __repr__(self):
		return "<skip>"

	def __str__(self):
		return self.__repr__()

class Alloca:
	def __init__(self, typ, name, inst):
		self.name = name
		self.inst = inst
		self.typ = typ

	def __repr__(self):
		return f'{self.typ} %"{self.name}" = {self.inst}'

	def __str__(self):
		return self.__repr__()

class InstKind(Enum):
	Nop = auto_enum()
	Alloca = auto_enum()
	Store = auto_enum()
	StorePtr = auto_enum()
	LoadPtr = auto_enum()
	GetElementPtr = auto_enum()
	GetRef = auto_enum()

	Cast = auto_enum()
	Cmp = auto_enum()
	Select = auto_enum()

	DbgStmtLine = auto_enum()
	Unreachable = auto_enum()
	Breakpoint = auto_enum()

	# arithmetic operators
	Add = auto_enum()
	Sub = auto_enum()
	Mult = auto_enum()
	Div = auto_enum()
	Mod = auto_enum()
	Inc = auto_enum()
	Dec = auto_enum()

	# unary operators
	Neg = auto_enum()
	BitNot = auto_enum()

	# boolean operators
	BooleanNot = auto_enum()

	# bitwise operators
	BitAnd = auto_enum()
	BitOr = auto_enum()
	BitXor = auto_enum()
	Lshift = auto_enum()
	Rshift = auto_enum()

	# routine operators
	Br = auto_enum()
	Call = auto_enum()
	Ret = auto_enum()

	def __repr__(self):
		if self == InstKind.Alloca: return "alloca"
		elif self == InstKind.Store: return "store"
		elif self == InstKind.StorePtr: return "store_ptr"
		elif self == InstKind.LoadPtr: return "load_ptr"
		elif self == InstKind.GetElementPtr: return "get_element_ptr"
		elif self == InstKind.GetRef: return "get_ref"
		elif self == InstKind.Cast: return "cast"
		elif self == InstKind.Cmp: return "cmp"
		elif self == InstKind.Select: return "select"
		elif self == InstKind.DbgStmtLine: return "dbg_stmt_line"
		elif self == InstKind.Unreachable: return "unreachable"
		elif self == InstKind.Breakpoint: return "breakpoint"
		elif self == InstKind.Add: return "add"
		elif self == InstKind.Sub: return "sub"
		elif self == InstKind.Mult: return "mult"
		elif self == InstKind.Div: return "div"
		elif self == InstKind.Mod: return "mod"
		elif self == InstKind.Inc: return "inc"
		elif self == InstKind.Dec: return "dec"
		elif self == InstKind.Neg: return "neg"
		elif self == InstKind.BitNot: return "bit_not"
		elif self == InstKind.BooleanNot: return "boolean_not"
		elif self == InstKind.BitAnd: return "bit_and"
		elif self == InstKind.BitOr: return "bit_or"
		elif self == InstKind.BitXor: return "bit_xor"
		elif self == InstKind.Lshift: return "lshift"
		elif self == InstKind.Rshift: return "rshift"
		elif self == InstKind.Br: return "br"
		elif self == InstKind.Call: return "call"
		elif self == InstKind.Ret: return "ret"
		return "nop"

	def __str__(self):
		return self.__repr__()

class Inst:
	def __init__(self, kind, args):
		self.kind = kind
		self.args = args

	def __repr__(self):
		if self.kind == InstKind.Call:
			return f'{self.kind} {self.args[0]}({", ".join([str(arg) for arg in self.args[1:]])})'
		return f"{self.kind} {', '.join([str(arg) for arg in self.args])}"

	def __str__(self):
		return self.__repr__()

# AST to Rivet Intermediate Representation
class AST2RIR:
	def __init__(self, comp):
		self.comp = comp
		self.types = list()
		self.externs = list()
		self.statics = list()
		self.decls = list()

		self.cur_fn = None
		self.cur_fn_qualname = ""
		self.cur_fn_is_main = False
		self.cur_concrete_types = {}

		self.loop_entry_label = ""
		self.loop_exit_label = ""

		self.void_types = (self.comp.void_t, self.comp.no_return_t)

		self.init_statics = FnDecl(
		    True, "_R12init_staticsZ", self.comp.void_t, []
		)

	def convert(self, source_files):
		self.convert_types(self.comp.universe)
		for sf in source_files:
			self.convert_source_file(sf)
		self.decls.append(self.init_statics)
		return RIR(
		    self.comp.prefs.pkg_name, self.types, self.externs, self.statics,
		    self.decls
		)

	def convert_types(self, root):
		type_symbols = self.sort_type_symbols(self.get_type_symbols(root))
		for ts in type_symbols:
			if not ts.is_used():
				continue
			if ts.kind == sym.TypeKind.Tuple:
				fields = list()
				for i, f in enumerate(ts.info.types):
					fields.append(Field(f"f{i}", f))
				self.types.append(
				    Struct(False, False, False, mangle_symbol(ts), fields)
				)
			elif ts.kind == sym.TypeKind.Array:
				self.types.append(Alias(mangle_symbol(ts), ts))
			elif ts.kind == sym.TypeKind.Enum:
				for i, v in enumerate(ts.info.variants):
					v.value = i
			elif ts.kind == sym.TypeKind.Trait:
				if ts.info.has_objects:
					ts_name = mangle_symbol(ts)
					self.types.append(
					    Struct(
					        ts.vis.is_pub(), False, False, ts_name, [
					            Field("obj", type.Ptr(self.comp.void_t)),
					            Field("idx", self.comp.usize_t)
					        ]
					    )
					)
					# Virtual table
					vtbl_name = f"{ts_name}4Vtbl"
					static_vtbl_name = f"{ts_name}4VTBL"
					fields = list()
					for m in ts.syms:
						if isinstance(m, sym.Fn):
							fields.append(Field(m.name, m.typ()))
					self.types.append(
					    Struct(False, False, False, vtbl_name, fields)
					)
					funcs = []
					for its in ts.info.implements:
						map = {}
						for m in ts.syms:
							if isinstance(m, sym.Fn):
								if ts_method := its.find(m.name):
									map[m.name] = mangle_symbol(ts_method)
								else:
									map[m.name] = mangle_symbol(m)
						funcs.append(map)
					self.decls.append(
					    VTable(
					        vtbl_name, static_vtbl_name, ts_name,
					        len(ts.info.implements), funcs
					    )
					)
			elif ts.kind == sym.TypeKind.Union:
				if ts.info.is_c_union:
					fields = list()
					for v in ts.info.variants:
						fields.append(Field(mangle_type(v), v))
					self.types.append(
					    Struct(
					        ts.vis.is_pub(), True, False, mangle_symbol(ts),
					        fields
					    )
					)
				else:
					self.types.append(
					    RiUnion(
					        ts.vis.is_pub(), mangle_symbol(ts), ts.info.variants
					    )
					)
			elif ts.kind == sym.TypeKind.Struct:
				fields = list()
				for f in ts.fields:
					fields.append(Field(f.name, f.typ))
				self.types.append(
				    Struct(
				        ts.vis.is_pub(), False, ts.info.is_opaque,
				        mangle_symbol(ts), fields
				    )
				)

	def convert_source_file(self, sf):
		self.convert_decls(sf.decls)

	def convert_decls(self, decls):
		for d in decls:
			self.convert_decl(d)

	def convert_decl(self, d):
		if isinstance(d, ast.ComptimeIfDecl):
			if d.branch_idx != -1:
				self.convert_decls(d.branches[d.branch_idx].decls)
		elif isinstance(d, ast.ExternDecl):
			self.convert_decls(d.protos)
		elif isinstance(d, ast.ConstDecl):
			self.convert_const(d.sym)
		elif isinstance(d, ast.StaticDecl):
			name = d.sym.name if d.is_extern else mangle_symbol(d.sym)
			self.statics.append(
			    StaticVar(d.vis.is_pub(), d.is_extern, d.typ, name)
			)
			if not d.is_extern and name != "_R4core4ARGS": # TODO(StunxFS): temp
				self.cur_fn = self.init_statics
				self.cur_fn.store(
				    Ident(d.typ, name),
				    self.convert_expr_with_cast(d.typ, d.expr)
				)
				self.cur_fn = None
		elif isinstance(d, ast.ModDecl):
			self.convert_decls(d.decls)
		elif isinstance(d, ast.UnionDecl):
			if d.sym.is_used():
				self.convert_decls(d.decls)
		elif isinstance(d, ast.StructDecl):
			if d.sym.is_used():
				if d.is_generic:
					for g in d.sym.syms:
						for i,gt in enumerate(d.type_arguments):
							self.cur_concrete_types[gt.name] = d.type_arguments[gt.idx]
				self.convert_decls(d.decls)
				if d.is_generic:
					for gt in d.type_arguments:
						del self.cur_concrete_types[gt.name]
		elif isinstance(d, ast.EnumDecl):
			if d.sym.is_used():
				self.convert_decls(d.decls)
		elif isinstance(d, ast.ExtendDecl):
			self.convert_decls(d.decls)
		elif isinstance(d, ast.FnDecl):
			if d.is_generic:
				for g in d.sym.syms:
					if not g.is_generic_instance:
						continue
					for i,gt in enumerate(d.type_arguments):
						self.cur_concrete_types[gt.name] = g.type_arguments[gt.idx]
					self.cur_fn_qualname = g.qualname()
					args = g.args.copy()
					if d.is_method:
						args.insert(
						    0,
						    sym.Arg("self", d.self_typ, None, None, d.name_pos)
						)
					self.cur_fn = FnDecl(
					    d.vis.is_pub(), mangle_symbol(g), g.ret_typ, args
					)
					self.convert_stmts(d.stmts)
					if len(d.stmts) == 0 or (
					    isinstance(d.stmts[-1], ast.ExprStmt)
					    and not isinstance(
					        d.stmts[-1].expr, (ast.ReturnExpr, ast.RaiseExpr)
					    )
					):
						if isinstance(
						    g.ret_typ, type.Result
						) and g.ret_typ.typ == self.comp.void_t:
							self.cur_fn.add_ret(self.result_void_ok(g.ret_typ))
						elif g.ret_typ not in self.void_types:
							self.cur_fn.add_ret(self.default_value(g.ret_typ))
					self.decls.append(self.cur_fn)
					for gt in d.type_arguments:
						del self.cur_concrete_types[gt.name]
			elif d.is_extern and not d.has_body:
				self.externs.append(
				    ExternFn(d.name, d.ret_typ, d.args, d.is_variadic, d.attrs)
				)
			elif d.sym.is_used():
				self.decls.append(self.convert_fn_decl(d))
		elif isinstance(d, ast.DestructorDecl):
			self.cur_fn = FnDecl(
			    True,
			    mangle_symbol(d.self_typ.get_sym()) + "_dtor", self.comp.void_t,
			    [sym.Arg("self", d.self_typ, None, None, None)]
			)
			self.convert_stmts(d.stmts)
			self.decls.append(self.cur_fn)

	def convert_fn_decl(self, fn_decl):
		self.cur_fn_is_main = fn_decl.is_main
		self.cur_fn_qualname = fn_decl.sym.qualname()
		args = fn_decl.args.copy()
		if fn_decl.is_method:
			args.insert(
			    0,
			    sym.Arg("self", fn_decl.self_typ, None, None, fn_decl.name_pos)
			)
		self.cur_fn = FnDecl(
		    fn_decl.vis.is_pub(), mangle_symbol(fn_decl.sym), fn_decl.ret_typ,
		    args
		)
		self.convert_stmts(fn_decl.stmts)
		if len(fn_decl.stmts) == 0 or (
		    isinstance(fn_decl.stmts[-1], ast.ExprStmt) and not isinstance(
		        fn_decl.stmts[-1].expr, (ast.ReturnExpr, ast.RaiseExpr)
		    )
		):
			if isinstance(
			    fn_decl.ret_typ, type.Result
			) and fn_decl.ret_typ.typ == self.comp.void_t:
				self.cur_fn.add_ret(self.result_void_ok(fn_decl.ret_typ))
			elif fn_decl.ret_typ not in self.void_types:
				self.cur_fn.add_ret(self.default_value(fn_decl.ret_typ))
		return self.cur_fn

	def convert_stmts(self, stmts):
		for stmt in stmts:
			self.convert_stmt(stmt)

	def convert_stmt(self, stmt):
		# if self.comp.prefs.build_mode != prefs.BuildMode.Release:
		# 	self.cur_fn.add_dbg_stmt_line(stmt.pos)
		if isinstance(stmt, ast.LabelStmt):
			self.cur_fn.add_label(stmt.label)
		elif isinstance(stmt, ast.GotoStmt):
			self.cur_fn.add_br(stmt.label)
		elif isinstance(stmt, ast.ForInStmt):
			old_entry_label = self.loop_entry_label
			old_exit_label = self.loop_exit_label

			vars_len = len(stmt.vars)
			iterable_sym = stmt.iterable.typ.get_sym()
			self.loop_entry_label = self.cur_fn.local_name()
			body_label = self.cur_fn.local_name()
			self.loop_exit_label = self.cur_fn.local_name()

			self.cur_fn.add_comment("for in stmt")

			if isinstance(stmt.iterable,
			              ast.RangeExpr) or iterable_sym.kind in (
			                  TypeKind.Array, TypeKind.Slice, TypeKind.Str
			              ):
				if isinstance(stmt.iterable, ast.RangeExpr):
					self.cur_fn.alloca(
					    stmt.iterable.typ, stmt.vars[0],
					    self.convert_expr(stmt.iterable.start)
					)
					idx = Ident(self.comp.usize_t, stmt.vars[0])
					self.cur_fn.add_label(self.loop_entry_label)
					self.cur_fn.add_cond_br(
					    Inst(
					        InstKind.Cmp, [
					            Name(
					                "<=" if stmt.iterable.is_inclusive else "<"
					            ), idx,
					            self.convert_expr(stmt.iterable.end)
					        ]
					    ), body_label, self.loop_exit_label
					)
					self.cur_fn.add_label(body_label)
				else:
					idx_name = self.cur_fn.local_name(
					) if vars_len == 1 else stmt.vars[0]
					iterable = self.convert_expr(stmt.iterable)
					self.cur_fn.alloca(
					    self.comp.usize_t, idx_name,
					    IntLiteral(self.comp.usize_t, "0")
					)
					idx = Ident(self.comp.usize_t, idx_name)
					self.cur_fn.add_label(self.loop_entry_label)
					if iterable_sym.kind == TypeKind.Array:
						len_ = IntLiteral(
						    self.comp.usize_t, iterable_sym.info.size.lit
						)
					elif iterable_sym.kind == TypeKind.Str and isinstance(
					    iterable, StringLiteral
					):
						len_ = IntLiteral(self.comp.usize_t, iterable.len)
					else:
						len_ = Selector(
						    self.comp.usize_t, iterable, Name("len")
						)
					self.cur_fn.add_cond_br(
					    Inst(InstKind.Cmp, [Name("<"), idx, len_]), body_label,
					    self.loop_exit_label
					)

					self.cur_fn.add_label(body_label)
					value_t = self.comp.uint8_t if iterable_sym.kind == TypeKind.Str else iterable_sym.info.elem_typ
					if iterable_sym.kind == TypeKind.Array:
						value = Inst(InstKind.GetElementPtr, [iterable, idx])
					else:
						value = Selector(
						    type.Ptr(self.comp.void_t), iterable, Name("ptr")
						)
						if iterable_sym.kind == TypeKind.Slice:
							value = Inst(
							    InstKind.Add, [
							        Inst(
							            InstKind.Cast,
							            [value, Type(type.Ptr(value_t))]
							        ), idx
							    ]
							)
						else:
							value = Inst(InstKind.GetElementPtr, [value, idx])
					self.cur_fn.alloca(
					    value_t,
					    stmt.vars[0] if vars_len == 1 else stmt.vars[1],
					    Inst(InstKind.LoadPtr, [value])
					)
				self.convert_stmt(stmt.stmt)
				self.cur_fn.add_inst(Inst(InstKind.Inc, [idx]))
				self.cur_fn.add_br(self.loop_entry_label)
				self.cur_fn.add_label(self.loop_exit_label)

			self.loop_entry_label = old_entry_label
			self.loop_exit_label = old_exit_label
		elif isinstance(stmt, ast.WhileStmt):
			old_entry_label = self.loop_entry_label
			old_exit_label = self.loop_exit_label
			self.cur_fn.add_comment(f"while stmt (is_inf: {stmt.is_inf})")
			self.loop_entry_label = self.cur_fn.local_name()
			body_label = self.cur_fn.local_name()
			self.loop_exit_label = self.cur_fn.local_name()

			self.cur_fn.add_label(self.loop_entry_label)
			if stmt.is_inf:
				cond = IntLiteral(self.comp.bool_t, "1")
				self.cur_fn.add_br(body_label)
			else:
				if isinstance(stmt.cond, ast.GuardExpr):
					gexpr = self.convert_expr_with_cast(
					    stmt.cond.expr.typ, stmt.cond.expr
					)
					if stmt.cond.is_result:
						cond = Inst(
						    InstKind.BooleanNot,
						    [Selector(self.comp.bool_t, gexpr, Name("is_err"))]
						)
					else:
						cond = Inst(
						    InstKind.BooleanNot, [
						        Selector(
						            self.comp.bool_t, gexpr, Name("is_none")
						        )
						    ]
						)
					self.cur_fn.alloca(
					    stmt.cond.expr.typ.typ, stmt.cond.vars[0],
					    Selector(stmt.cond.expr.typ.typ, gexpr, Name("value"))
					)
					if stmt.cond.has_cond:
						gcond = self.convert_expr_with_cast(
						    self.comp.bool_t, stmt.cond.cond
						)
						self.cur_fn.add_cond_br(
						    gcond, body_label, self.loop_exit_label
						)
				else:
					cond = self.convert_expr_with_cast(
					    self.comp.bool_t, stmt.cond
					)
				if isinstance(cond, IntLiteral) and cond.lit == "1":
					self.cur_fn.add_br(body_label)
				else:
					self.cur_fn.add_cond_br(
					    cond, body_label, self.loop_exit_label
					)

			gen_stmt = True
			if isinstance(cond, IntLiteral) and cond.lit == "0":
				self.cur_fn.add_comment("skip while stmt (cond: false)")
				gen_stmt = False

			self.cur_fn.add_label(body_label)
			if gen_stmt:
				self.convert_stmt(stmt.stmt)
				self.cur_fn.add_comment(
				    f"while stmt (goto to `{self.loop_entry_label}` for continue)"
				)
				self.cur_fn.add_br(self.loop_entry_label)
			self.cur_fn.add_label(self.loop_exit_label)

			self.loop_entry_label = old_entry_label
			self.loop_exit_label = old_exit_label
		elif isinstance(stmt, ast.LetStmt):
			if len(stmt.lefts) == 1:
				left = stmt.lefts[0]
				unwrapped_left_typ = self.unwrap(left.typ)
				ident = Ident(
				    unwrapped_left_typ,
				    self.cur_fn.local_name() if left.name == "_" else left.name
				)
				self.cur_fn.alloca_var(ident)
				value = self.convert_expr_with_cast(
				    unwrapped_left_typ, stmt.right
				)
				self.cur_fn.store(ident, value)
				if isinstance(value, IntLiteral
				              ) and self.comp.is_int(unwrapped_left_typ):
					self.check_number_limit(
					    unwrapped_left_typ, value.value(), stmt.right.pos
					)
			else:
				right = self.convert_expr(stmt.right)
				for i, left in enumerate(stmt.lefts):
					unwrapped_left_typ = self.unwrap(left.typ)
					ident = Ident(
					    unwrapped_left_typ,
					    self.cur_fn.local_name()
					    if left.name == "_" else left.name
					)
					self.cur_fn.alloca_var(ident)
					self.cur_fn.store(
					    ident,
					    Selector(
					        unwrapped_left_typ, right, Name(f"f{i}")
					    )
					)
		elif isinstance(stmt, ast.AssignStmt):
			left = None
			if isinstance(stmt.left, ast.Ident):
				if stmt.left.name == "_":
					_ = self.convert_expr(stmt.right)
					return
				else:
					left = self.convert_expr(stmt.left)
			elif isinstance(stmt.left, ast.SelectorExpr):
				if stmt.left.is_indirect:
					left = Inst(
					    InstKind.LoadPtr, [self.convert_expr(stmt.left.left)]
					)
				else:
					left = self.convert_expr(stmt.left)
			elif isinstance(stmt.left, ast.IndexExpr):
				unwrapped_left_typ = self.unwrap(stmt.left.left_typ)
				left_sym = unwrapped_left_typ.get_sym()
				if left_sym.kind == TypeKind.Slice and stmt.op == Kind.Assign:
					rec = self.convert_expr_with_cast(
					    unwrapped_left_typ, stmt.left.left
					)
					if not isinstance(unwrapped_left_typ, type.Ref):
						rec = Inst(InstKind.GetRef, [rec])
					self.cur_fn.add_call(
					    "_R4core6_slice3setM", [
					        rec,
					        self.convert_expr(stmt.left.index),
					        Inst(
					            InstKind.GetRef, [
					                self.convert_expr_with_cast(
					                    stmt.right.typ, stmt.right
					                )
					            ]
					        )
					    ]
					)
					return
				left = Inst(InstKind.LoadPtr, [self.convert_expr(stmt.left)])
			if left == None: return
			unwrapped_left_typ = self.unwrap(stmt.left.typ)
			if stmt.op == Kind.Assign:
				value = self.convert_expr_with_cast(
				    unwrapped_left_typ, stmt.right
				)
				if isinstance(value, IntLiteral
				              ) and self.comp.is_int(unwrapped_left_typ):
					self.check_number_limit(
					    unwrapped_left_typ, value.value(), stmt.right.pos
					)
				self.cur_fn.store(left, value)
			else:
				right = self.convert_expr_with_cast(
				    unwrapped_left_typ, stmt.right
				)
				if stmt.op == Kind.PlusAssign:
					op_kind = InstKind.Add
				elif stmt.op == Kind.MinusAssign:
					op_kind = InstKind.Sub
				elif stmt.op == Kind.MultAssign:
					op_kind = InstKind.Mult
				elif stmt.op == Kind.DivAssign:
					op_kind = InstKind.Div
				elif stmt.op == Kind.ModAssign:
					op_kind = InstKind.Mod
				elif stmt.op == Kind.AmpAssign:
					op_kind = InstKind.BitAnd
				elif stmt.op == Kind.PipeAssign:
					op_kind = InstKind.BitOr
				elif stmt.op == Kind.XorAssign:
					op_kind = InstKind.BitXor
				self.cur_fn.store(left, Inst(op_kind, [left, right]))
		elif isinstance(stmt, ast.ExprStmt):
			_ = self.convert_expr(stmt.expr)

	def convert_expr_with_cast(self, expected_typ_, expr):
		expected_typ = self.unwrap(expected_typ_)
		res_expr = self.convert_expr(expr)

		if isinstance(res_expr, IntLiteral) and self.comp.is_int(expected_typ):
			res_expr.typ = expected_typ
		elif isinstance(res_expr,
		                FloatLiteral) and self.comp.is_float(expected_typ):
			res_expr.typ = expected_typ

		if (not isinstance(res_expr, (Skip, NoneLiteral, Inst))) and isinstance(
		    res_expr.typ, (type.Ptr, type.Ref)
		) and res_expr.typ.typ != self.comp.void_t:
			if isinstance(expected_typ, (type.Ptr, type.Ref)):
				nr_level_expected = expected_typ.nr_level()
				nr_level = res_expr.typ.nr_level()
				while nr_level > nr_level_expected:
					res_expr = Inst(InstKind.LoadPtr, [res_expr])
					nr_level -= 1
			else:
				res_expr = Inst(InstKind.LoadPtr, [res_expr])

		expr_sym = expr.typ.get_sym()
		expected_sym = expected_typ.get_sym()
		if expected_sym.kind == TypeKind.Trait and expr_sym != expected_sym:
			res_expr = self.trait_value(res_expr, expr.typ, expected_typ)

		# wrap optional value
		if isinstance(expected_typ, type.Optional
		              ) and not isinstance(expected_typ.typ, type.Ref):
			if isinstance(res_expr, NoneLiteral):
				res_expr = self.optional_none(expected_typ)
			elif not isinstance(res_expr, (Skip, NoneLiteral)
			                    ) and not isinstance(expr.typ, type.Optional):
				res_expr = self.optional_ok(expected_typ, res_expr)

		return res_expr

	def convert_expr(self, expr):
		if isinstance(expr, ast.ParExpr):
			return self.convert_expr(expr.expr)
		elif isinstance(expr, ast.NoneLiteral):
			return NoneLiteral(self.comp.none_t)
		elif isinstance(expr, ast.BoolLiteral):
			return IntLiteral(self.comp.bool_t, str(int(expr.lit)))
		elif isinstance(expr, ast.CharLiteral):
			if expr.is_byte:
				b, _ = utils.bytestr(expr.lit)
				return IntLiteral(expr.typ, str(b[0]))
			else:
				return RuneLiteral(self.comp.rune_t, expr.lit)
		elif isinstance(expr, ast.IntegerLiteral):
			return IntLiteral(expr.typ, expr.lit)
		elif isinstance(expr, ast.FloatLiteral):
			return FloatLiteral(self.comp.float64_t, expr.lit)
		elif isinstance(expr, ast.StringLiteral):
			escaped_val = utils.smart_quote(expr.lit, expr.is_raw)
			bytes, _ = utils.bytestr(escaped_val)
			_, size = utils.bytestr(expr.lit)
			if expr.is_bytestr:
				return ArrayLiteral(
				    expr.typ, [
				        IntLiteral(self.comp.uint8_t, str(b))
				        for b in list(bytes)
				    ]
				)
			return StringLiteral(expr.typ, escaped_val, str(size))
		elif isinstance(expr, ast.EnumVariantExpr):
			return IntLiteral(
			    expr.typ.get_sym().info.underlying_typ, str(expr.info.value)
			)
		elif isinstance(expr, ast.SelfExpr):
			return Ident(self.unwrap(expr.typ), "self")
		elif isinstance(expr, ast.Ident):
			if isinstance(expr.sym, sym.Const):
				return self.convert_const(expr.sym)
			elif isinstance(expr.sym, sym.Static):
				unwrapped_typ = self.unwrap(expr.typ)
				if expr.sym.is_extern:
					return Ident(unwrapped_typ, expr.sym.name)
				return Ident(unwrapped_typ, mangle_symbol(expr.sym))
			# comptime values
			elif expr.is_comptime:
				if expr.name == "_FILE_":
					return StringLiteral(
					    self.comp.str_t, expr.pos.file, len(expr.pos.file)
					)
				elif expr.name == "_LINE_":
					line = str(expr.pos.line + 1)
					return StringLiteral(self.comp.str_t, line, len(line))
				elif expr.name == "_COLUMN_":
					col = str(expr.pos.col)
					return StringLiteral(self.comp.str_t, col, len(col))
				elif expr.name == "_FUNCTION_":
					return StringLiteral(
					    self.comp.str_t, self.cur_fn_qualname,
					    len(self.cur_fn_qualname)
					)
				elif expr.name == "_RIVET_VERSION_":
					return StringLiteral(
					    self.comp.str_t, utils.VERSION, len(utils.VERSION)
					)
				elif expr.name == "_RIVET_COMMIT_":
					commit = utils.commit_hash()
					return StringLiteral(self.comp.str_t, commit, len(commit))
			elif isinstance(expr.sym, sym.Fn):
				return Ident(self.unwrap(expr.typ), mangle_symbol(expr.sym))
			# runtime object
			return Ident(self.unwrap(expr.typ), expr.name)
		elif isinstance(expr, ast.BuiltinCallExpr):
			if expr.name in ("compile_warn", "compile_error"):
				msg = self.convert_expr(expr.args[0])
				if isinstance(msg, StringLiteral):
					if expr.name == "compile_warn":
						report.warn(msg.lit, expr.pos)
					else:
						report.error(msg.lit, expr.pos)
				else:
					report.error(
					    f"`{expr.name}` can only use string comptime values",
					    expr.pos
					)
			elif expr.name == "mangle_of":
				arg0 = expr.args[0]
				if isinstance(arg0, ast.Ident):
					mangled_name = mangle_symbol(arg0.sym)
				else:
					mangled_name = mangle_symbol(arg0.field_info)
				return StringLiteral(
				    self.comp.str_t, mangled_name, len(mangled_name)
				)
			elif expr.name in ("size_of", "align_of"):
				size, align = self.comp.type_size(self.unwrap(expr.args[0].typ))
				if expr.name == "size_of":
					return IntLiteral(self.comp.usize_t, str(size))
				else:
					return IntLiteral(self.comp.usize_t, str(align))
			elif expr.name == "assert":
				msg_ = f"`{expr.args[0]}`"
				msg = utils.smart_quote(msg_, False)
				_, size = utils.bytestr(msg_)
				self.cur_fn.add_call(
				    "_R4core6assertF", [
				        self.convert_expr(expr.args[0]),
				        StringLiteral(self.comp.str_t, msg, size)
				    ]
				)
			elif expr.name == "unreachable":
				self.panic("entered unreachable code")
				self.cur_fn.unreachable()
			elif expr.name == "breakpoint":
				if self.comp.prefs.build_mode != prefs.BuildMode.Release:
					self.cur_fn.breakpoint()
		elif isinstance(expr, ast.CastExpr):
			unwrapped_typ = self.unwrap(expr.typ)
			res = self.convert_expr_with_cast(unwrapped_typ, expr.expr)
			if isinstance(res, IntLiteral):
				if self.comp.is_int(
				    unwrapped_typ
				) or unwrapped_typ == self.comp.bool_t:
					self.check_number_limit(
					    unwrapped_typ, res.value(), expr.pos
					)
					res.typ = unwrapped_typ
					return res
			typ_sym = expr.expr.typ.get_sym()
			expr_typ_sym = unwrapped_typ.get_sym()
			if typ_sym.kind == sym.TypeKind.Union:
				if not typ_sym.info.is_c_union:
					msg = utils.smart_quote(
					    f"cannot cast union value `{expr.expr}` to `{expr.typ}`",
					    False
					)
					self.cur_fn.add_call(
					    "_R4core8panic_ifF", [
					        Inst(
					            InstKind.Cmp, [
					                Name("!="),
					                Selector(
					                    self.comp.usize_t, res, Name("idx")
					                ),
					                IntLiteral(
					                    self.comp.usize_t,
					                    str(expr_typ_sym.index)
					                )
					            ]
					        ),
					        StringLiteral(self.comp.str_t, msg, len(msg))
					    ]
					)
				return Selector(
				    unwrapped_typ, res, Name(mangle_symbol(expr_typ_sym))
				)
			tmp = self.cur_fn.local_name()
			self.cur_fn.alloca(
			    unwrapped_typ, tmp,
			    Inst(InstKind.Cast, [res, Type(unwrapped_typ)])
			)
			return Ident(unwrapped_typ, tmp)
		elif isinstance(expr, ast.StructLiteral):
			typ_sym = expr.typ.get_sym()
			tmp = Ident(expr.typ, self.cur_fn.local_name())
			self.cur_fn.alloca_var(tmp)
			initted_fields = {}
			for f in expr.fields:
				initted_fields[f.name] = True
				field_expr = self.convert_expr_with_cast(f.typ, f.expr)
				if isinstance(field_expr,
				              IntLiteral) and self.comp.is_int(f.typ):
					self.check_number_limit(
					    f.typ, field_expr.value(), f.expr.pos
					)
				self.cur_fn.store(
				    Selector(f.typ, tmp, Name(f.name)), field_expr
				)
			for f in typ_sym.fields:
				if f.name in initted_fields:
					continue
				if f.has_def_expr:
					val = self.convert_expr_with_cast(f.typ, f.def_expr)
				else:
					val = self.default_value(f.typ)
				self.cur_fn.store(Selector(f.typ, tmp, Name(f.name)), val)
			return tmp
		elif isinstance(expr, ast.TupleLiteral):
			unwrapped_typ = self.unwrap(expr.typ)
			expr_sym = unwrapped_typ.get_sym()
			tmp = Ident(unwrapped_typ, self.cur_fn.local_name())
			self.cur_fn.alloca_var(tmp)
			for i, elem in enumerate(expr.exprs):
				unwrapped_elem_typ = self.unwrap(expr_sym.info.types[i])
				field_expr = self.convert_expr_with_cast(
				    unwrapped_elem_typ, elem
				)
				if isinstance(field_expr, IntLiteral
				              ) and self.comp.is_int(unwrapped_elem_typ):
					self.check_number_limit(
					    unwrapped_elem_typ, field_expr.value(), elem.pos
					)
				self.cur_fn.store(
				    Selector(unwrapped_elem_typ, tmp, Name(f"f{i}")), field_expr
				)
			return tmp
		elif isinstance(expr, ast.ArrayLiteral):
			unwrapped_typ = self.unwrap(expr.typ)
			if len(expr.elems) == 0:
				return self.default_value(unwrapped_typ)
			elem_typ = unwrapped_typ.get_sym().info.elem_typ
			elems = []
			for i, elem in enumerate(expr.elems):
				element = self.convert_expr_with_cast(elem_typ, elem)
				if isinstance(element,
				              IntLiteral) and self.comp.is_int(elem_typ):
					self.check_number_limit(elem_typ, element.value(), elem.pos)
				elems.append(element)
			return ArrayLiteral(unwrapped_typ, elems)
		elif isinstance(expr, ast.CallExpr):
			if expr.is_ctor:
				value = expr.args[0].expr
				typ_sym = expr.typ.get_sym()
				if typ_sym.kind == sym.TypeKind.Trait:
					return self.trait_value(
					    self.convert_expr_with_cast(value.typ, value),
					    value.typ, expr.typ
					)
				value_sym = self.comp.untyped_to_type(value.typ).get_sym()
				tmp = Ident(expr.typ, self.cur_fn.local_name())
				self.cur_fn.alloca_var(tmp)
				self.cur_fn.store(
				    Selector(value.typ, tmp, Name(mangle_symbol(value_sym))),
				    self.convert_expr_with_cast(value.typ, value)
				)
				if not typ_sym.info.is_c_union:
					self.cur_fn.store(
					    Selector(self.comp.usize_t, tmp, Name("idx")),
					    IntLiteral(self.comp.usize_t, str(value_sym.index))
					)
				return tmp
			args = []
			is_trait_call = False
			if not expr.info: raise Exception(f"{expr.info} <{expr.pos}>")
			if expr.info.is_method:
				left_sym = expr.left.left_typ.get_sym()
				if left_sym.kind == TypeKind.Trait:
					is_trait_call = True
					self_expr = Inst(
					    InstKind.LoadPtr, [
					        self.convert_expr_with_cast(
					            expr.info.self_typ, expr.left.left
					        )
					    ]
					)
					args.append(
					    Selector(
					        type.Ptr(self.comp.void_t),
					        Inst(
					            InstKind.LoadPtr, [
					                Inst(
					                    InstKind.GetElementPtr, [
					                        Name(
					                            mangle_symbol(left_sym) +
					                            "4VTBL"
					                        ),
					                        Selector(
					                            self.comp.usize_t, self_expr,
					                            Name("idx")
					                        )
					                    ]
					                )
					            ]
					        ), Name(expr.info.name)
					    )
					)
					args.append(
					    Selector(
					        type.Ptr(self.comp.void_t), self_expr, Name("obj")
					    )
					)
			if not is_trait_call:
				if expr.is_closure:
					name = self.convert_expr_with_cast(expr.left.typ, expr.left)
				elif expr.info.is_extern:
					name = Ident(expr.typ, expr.info.name)
				else:
					name = Ident(expr.typ, mangle_symbol(expr.info))
				args.append(name)
				if expr.info.is_method:
					self_expr = self.convert_expr_with_cast(
					    expr.info.self_typ, expr.left.left
					)
					if expr.info.rec_is_ref and not isinstance(
					    expr.left.left_typ, type.Ref
					):
						self_expr = Inst(InstKind.GetRef, [self_expr])
					args.append(self_expr)
			args_len = expr.info.args_len()
			for i, arg in enumerate(expr.args):
				if expr.info.is_variadic and i == args_len:
					break
				arg_typ = expr.info.args[i].typ
				arg_expr = self.convert_expr_with_cast(arg_typ, arg.expr)
				if isinstance(arg_expr,
				              IntLiteral) and self.comp.is_int(arg_typ):
					self.check_number_limit(arg_typ, arg_expr.value(), arg.pos)
				args.append(arg_expr)
			if expr.info.is_variadic:
				args_nr = args_len
				variadic_count = len(expr.args) - args_nr
				if expr.info.is_extern:
					for i in range(args_nr + 1, len(expr.args)):
						arg = expr.args[i]
						args.append(
						    self.convert_expr_with_cast(arg.typ, arg.expr)
						)
				else:
					var_arg = expr.info.args[-1]
					if variadic_count == 1 and len(expr.args
					                               ) > 0 and isinstance(
					                                   expr.args[-1].expr.typ,
					                                   type.Variadic
					                               ):
						arg = expr.args[-1]
						args.append(
						    self.convert_expr_with_cast(arg.typ, arg.expr)
						)
					elif variadic_count > 0:
						vargs = []
						for i in range(args_nr, len(expr.args)):
							vargs.append(
							    self.convert_expr_with_cast(
							        var_arg.typ.typ, expr.args[i].expr
							    )
							)
						args.append(self.variadic_args(vargs, var_arg.typ.typ))
					else:
						args.append(Ident(var_arg.typ, "_R4core11empty_slice"))
			inst = Inst(InstKind.Call, args)
			if expr.info.ret_typ in self.void_types:
				self.cur_fn.add_inst(inst)
			else:
				is_void_value = expr.typ in self.void_types
				tmp = self.cur_fn.local_name()
				self.cur_fn.alloca(self.unwrap(expr.info.ret_typ), tmp, inst)

				if expr.has_err_handler():
					err_handler_is_void = (
					    not expr.err_handler.is_propagate
					) and expr.err_handler.expr.typ in self.void_types
					res_value = Ident(self.unwrap(expr.info.ret_typ), tmp)
					panic_l = self.cur_fn.local_name()
					else_value = "" if err_handler_is_void else self.cur_fn.local_name(
					)
					exit_l = "" if expr.err_handler.is_propagate else self.cur_fn.local_name(
					)
					if err_handler_is_void:
						self.cur_fn.add_cond_br(
						    Selector(
						        self.comp.bool_t, res_value, Name("is_err")
						    ), panic_l, exit_l
						)
					else:
						self.cur_fn.add_cond_br(
						    Selector(
						        self.comp.bool_t, res_value, Name("is_err")
						    ), panic_l, else_value
						)
					self.cur_fn.add_label(panic_l)
					if expr.err_handler.is_propagate:
						if self.cur_fn_is_main:
							self.cur_fn.add_call(
							    "_R4core6_error5printM", [
							        Inst(
							            InstKind.GetRef, [
							                Selector(
							                    self.comp.error_t, res_value,
							                    Name("err")
							                )
							            ]
							        )
							    ]
							)
							self.cur_fn.unreachable()
						else:
							tmp2 = Ident(
							    self.unwrap(self.cur_fn.ret_typ),
							    self.cur_fn.local_name()
							)
							self.cur_fn.alloca_var(tmp2)
							self.cur_fn.store(
							    Selector(
							        self.comp.bool_t, tmp2, Name("is_err")
							    ), IntLiteral(self.comp.bool_t, "1")
							)
							self.cur_fn.store(
							    Selector(self.comp.error_t, tmp2, Name("err")),
							    Selector(
							        self.comp.error_t, res_value, Name("err")
							    )
							)
							self.cur_fn.add_ret(tmp2)
						self.cur_fn.add_label(else_value)
						if is_void_value:
							return Skip()
						return Selector(
						    self.unwrap(expr.info.ret_typ.typ), res_value,
						    Name("value")
						)
					else: # `catch`
						if expr.err_handler.has_varname():
							self.cur_fn.alloca(
							    self.comp.error_t, expr.err_handler.varname,
							    Selector(
							        self.comp.error_t, res_value, Name("err")
							    )
							)
						if err_handler_is_void:
							self.convert_expr_with_cast(
							    expr.info.ret_typ.typ, expr.err_handler.expr
							)
							self.cur_fn.add_label(exit_l)
							return Selector(
							    self.unwrap(expr.typ), res_value, Name("value")
							)
						tmp2 = Ident(
						    self.unwrap(expr.info.ret_typ.typ),
						    self.cur_fn.local_name()
						)
						self.cur_fn.alloca_var(tmp2)
						self.cur_fn.store(
						    tmp2,
						    self.convert_expr_with_cast(
						        self.unwrap(expr.info.ret_typ.typ),
						        expr.err_handler.expr
						    )
						)
						self.cur_fn.add_br(exit_l)
						self.cur_fn.add_label(else_value)
						self.cur_fn.store(
						    tmp2, Selector(expr.typ, res_value, Name("value"))
						)
						self.cur_fn.add_label(exit_l)
						return tmp2
				id = Ident(expr.info.ret_typ, tmp)
				id.use_arr_field = isinstance(expr.info.ret_typ, type.Array)
				return id
		elif isinstance(expr, ast.BranchExpr):
			if expr.op == Kind.KeyContinue:
				self.cur_fn.add_br(self.loop_entry_label)
			else:
				self.cur_fn.add_br(self.loop_exit_label)
			return Skip()
		elif isinstance(expr, ast.RaiseExpr):
			name = mangle_symbol(self.cur_fn.ret_typ.sym)
			errtype_tag = str(expr.expr.typ.sym.info.nr)
			vargs = []
			if len(expr.expr.args) == 0:
				msg = StringLiteral(self.comp.str_t, "", 0)
			else:
				msg = self.convert_expr_with_cast(
				    self.comp.str_t, expr.expr.args[0].expr
				)
				vargs = [
				    self.convert_expr_with_cast(
				        type.Type(self.comp.trait_to_string), a.expr
				    ) for a in expr.expr.args[1:]
				]
			self.cur_fn.add_ret(
			    self.result_err(expr.expr.typ, msg, errtype_tag, vargs)
			)
			return Skip()
		elif isinstance(expr, ast.ReturnExpr):
			wrap_result = isinstance(self.cur_fn.ret_typ, type.Result)
			ret_typ = self.cur_fn.ret_typ.typ if wrap_result else self.cur_fn.ret_typ
			if expr.has_expr:
				expr = self.convert_expr_with_cast(ret_typ, expr.expr)
				if wrap_result:
					expr = self.result_ok(self.cur_fn.ret_typ, expr)
				self.cur_fn.add_ret(expr)
			elif wrap_result:
				self.cur_fn.add_ret(self.result_void_ok(self.cur_fn.ret_typ))
			else:
				self.cur_fn.add_ret_void()
			return Skip()
		elif isinstance(expr, ast.SelectorExpr):
			left_sym = expr.left_typ.get_sym()
			left = self.convert_expr_with_cast(expr.left_typ, expr.left)
			if expr.is_indirect:
				tmp = self.cur_fn.local_name()
				self.cur_fn.alloca(
				    expr.typ, tmp, Inst(InstKind.LoadPtr, [left])
				)
				return Ident(expr.typ, tmp)
			elif isinstance(expr.left_typ, (type.Ref, type.Ptr)):
				left = Inst(InstKind.LoadPtr, [left])

			if expr.is_nonecheck:
				panic_l = self.cur_fn.local_name()
				exit_l = self.cur_fn.local_name()
				if isinstance(expr.typ, type.Ref):
					self.cur_fn.add_cond_br(
					    Inst(InstKind.Cmp,
					         [Name("=="), left, NoneLiteral()]), panic_l, exit_l
					)
					self.cur_fn.add_label(panic_l)
					self.panic(f"attempt to use none value (`{expr.left}`)")
					self.cur_fn.unreachable()
					self.cur_fn.add_label(exit_l)
					return left
				else:
					self.cur_fn.add_cond_br(
					    Selector(self.comp.bool_t, left, Name("is_none")),
					    panic_l, exit_l
					)
					self.cur_fn.add_label(panic_l)
					self.panic(f"attempt to use none value (`{expr.left}`)")
					self.cur_fn.unreachable()
					self.cur_fn.add_label(exit_l)
					return Selector(expr.typ, left, Name("value"))
			elif isinstance(left, StringLiteral):
				if expr.field_name == "ptr":
					return StringLiteral(
					    type.Ptr(self.comp.uint8_t), left.lit, left.len, True
					)
				elif expr.field_name == "len":
					return IntLiteral(self.comp.usize_t, str(left.len))
				elif expr.field_name == "size":
					return IntLiteral(self.comp.usize_t, str(left.size))
			elif left_sym.kind == TypeKind.Array and expr.field_name == "len":
				return IntLiteral(self.comp.usize_t, left_sym.info.size.lit)
			return Selector(
			    expr.typ, left,
			    Name(
			        f"f{expr.field_name}" if left_sym.kind ==
			        sym.TypeKind.Tuple else expr.field_name
			    )
			)
		elif isinstance(expr, ast.PathExpr):
			if isinstance(expr.field_info, sym.Const):
				return self.convert_const(expr.field_info)
			elif isinstance(
			    expr.left_info, sym.Type
			) and expr.left_info.kind == sym.TypeKind.Enum:
				if v := expr.left_info.info.get_variant(expr.field_name):
					return IntLiteral(
					    expr.left_info.info.underlying_typ, str(v.value)
					)
			elif isinstance(expr.left_info, sym.Fn):
				return Ident(expr.typ, mangle_symbol(expr.left_info))
			elif isinstance(
			    expr.field_info, sym.Static
			) and expr.field_info.is_extern:
				return Ident(expr.typ, expr.field_info.name)
			return Ident(expr.typ, mangle_symbol(expr.field_info))
		elif isinstance(expr, ast.IndexExpr):
			s = expr.left.typ.get_sym()
			left = self.convert_expr_with_cast(expr.left_typ, expr.left)
			if isinstance(expr.index, ast.RangeExpr):
				if expr.index.has_start:
					start = self.convert_expr(expr.index.start)
				else:
					start = IntLiteral(self.comp.usize_t, "0")
				if expr.index.has_end:
					end = self.convert_expr(expr.index.end)
				else:
					if s.kind == sym.TypeKind.Array:
						end = IntLiteral(self.comp.usize_t, s.info.size.lit)
					elif isinstance(left, StringLiteral):
						end = IntLiteral(self.comp.usize_t, left.len)
					else:
						end = None
				if isinstance(start,
				              IntLiteral) and isinstance(end, IntLiteral):
					start_int, end_int = int(start.lit), int(end.lit)
					if start_int < 0:
						report.error(
						    "slice bounds out of range", expr.index.pos
						)
						report.note("start index is negative")
					elif s.kind == sym.TypeKind.Array and end_int > int(
					    s.info.size.lit
					):
						report.error(
						    "slice bounds out of range", expr.index.pos
						)
						report.note(
						    f"the size is {s.info.size.lit} but the index is {end.lit}"
						)
					elif start_int > end_int:
						report.error(
						    "slice bounds out of range", expr.index.pos
						)
						report.note("start index > end index")
					elif isinstance(left, StringLiteral): # comptime slicing
						slen = end_int - start_int
						s, _ = utils.bytestr(left.lit)
						return StringLiteral(
						    self.comp.str_t,
						    s[start_int:end_int].decode("utf-8"), slen
						)
				tmp = self.cur_fn.local_name()
				if s.kind == sym.TypeKind.Str:
					if end == None:
						inst = Inst(
						    InstKind.Call, [
						        Name("_R4core4_str10slice_fromM"),
						        Inst(InstKind.GetRef, [left]), start
						    ]
						)
					else:
						inst = Inst(
						    InstKind.Call, [
						        Name("_R4core4_str5sliceM"),
						        Inst(InstKind.GetRef, [left]), start, end
						    ]
						)
				elif s.kind == sym.TypeKind.Slice:
					if end == None:
						inst = Inst(
						    InstKind.Call, [
						        Name("_R4core6_slice10slice_fromM"),
						        Inst(InstKind.GetRef, [left]), start
						    ]
						)
					else:
						inst = Inst(
						    InstKind.Call, [
						        Name("_R4core6_slice5sliceM"),
						        Inst(InstKind.GetRef, [left]), start, end
						    ]
						)
				else:
					size, _ = self.comp.type_size(s.info.elem_typ)
					if end == None:
						inst = Inst(
						    InstKind.Call, [
						        Name("_R4core16array_slice_fromF"),
						        Inst(InstKind.GetRef, [left]),
						        IntLiteral(self.comp.usize_t, str(size)),
						        IntLiteral(self.comp.usize_t, s.info.size.lit),
						        start
						    ]
						)
					else:
						inst = Inst(
						    InstKind.Call, [
						        Name("_R4core11array_sliceF"),
						        Inst(InstKind.GetRef, [left]),
						        IntLiteral(self.comp.usize_t, str(size)),
						        IntLiteral(self.comp.usize_t, s.info.size.lit),
						        start, end
						    ]
						)
				self.cur_fn.alloca(expr.typ, tmp, inst)
				return Ident(expr.typ, tmp)
			idx = self.convert_expr(expr.index)
			if isinstance(idx, IntLiteral):
				idx_lit = int(idx.lit)
				if idx_lit < 0:
					report.error("index cannot be negative", expr.index.pos)
					report.note(f"the index is {idx.lit}")
					return Skip()
				if isinstance(s.info, sym.ArrayInfo
				              ) or isinstance(left, StringLiteral):
					size = int(left.len) if isinstance(left,
					                                   StringLiteral) else int(
					                                       s.info.size.lit
					                                   )
					if idx_lit >= size:
						if isinstance(left, StringLiteral):
							report.error(
							    "string index out of range", expr.index.pos
							)
						else:
							report.error(
							    "array index out of range", expr.index.pos
							)
						report.note(
						    f"the size is {s.info.size.lit} but the index is {idx.lit}"
						)
						if idx_lit == size and idx_lit >= 0:
							report.help(f"use `{idx_lit-1}` instead")
						return Skip()
			elif isinstance(s.info, sym.ArrayInfo):
				self.cur_fn.add_call(
				    "_R4core11array_indexF",
				    [IntLiteral(self.comp.usize_t, s.info.size.lit), idx]
				)
			tmp = self.cur_fn.local_name()
			if s.kind == sym.TypeKind.Str:
				if isinstance(left,
				              StringLiteral) and isinstance(idx, IntLiteral):
					return IntLiteral(
					    self.comp.uint8_t,
					    str(bytearray(left.lit, "utf-8")[idx.value()])
					)
				self.cur_fn.alloca(
				    expr.typ, tmp,
				    Inst(
				        InstKind.Call, [
				            Name("_R4core4_str2atM"),
				            Inst(InstKind.GetRef, [left]), idx
				        ]
				    )
				)
				return Ident(expr.typ, tmp)
			elif s.kind == sym.TypeKind.Slice:
				value = Inst(
				    InstKind.Cast, [
				        Inst(
				            InstKind.Call, [
				                Name("_R4core6_slice3getM"),
				                Inst(InstKind.GetRef, [left]), idx
				            ]
				        ),
				        Type(type.Ptr(expr.typ))
				    ]
				)
			else:
				value = Inst(InstKind.GetElementPtr, [left, idx])
			self.cur_fn.alloca(type.Ptr(expr.typ), tmp, value)
			return Ident(type.Ptr(expr.typ), tmp)
		elif isinstance(expr, ast.UnaryExpr):
			right = self.convert_expr_with_cast(expr.right_typ, expr.right)
			if expr.op == Kind.Amp:
				tmp = self.cur_fn.local_name()
				self.cur_fn.alloca(
				    expr.typ, tmp, Inst(InstKind.GetRef, [right])
				)
				return Ident(expr.typ, tmp)

			# comptime calculation
			if isinstance(right, IntLiteral):
				computed = True
				res = 0
				if expr.op == Kind.Bang:
					if right.lit == "0":
						res = 1
					elif right.lit == "1":
						res = 0
					else:
						computed = False
				elif expr.op == Kind.BitNot:
					res = ~right.value()
				elif expr.op == Kind.Minus:
					res = -right.value()
				else:
					computed = False
				if computed:
					return IntLiteral(expr.typ, str(res))

			# runtime calculation
			if expr.op == Kind.Bang:
				kind = InstKind.BooleanNot
			elif expr.op == Kind.BitNot:
				kind = InstKind.BitNot
			else:
				kind = InstKind.Neg
			tmp = self.cur_fn.local_name()
			self.cur_fn.alloca(expr.typ, tmp, Inst(kind, [right]))
			return Ident(expr.typ, tmp)
		elif isinstance(expr, ast.BinaryExpr):
			expr_left_typ = self.unwrap(expr.left.typ)
			expr_right_typ = self.unwrap(expr.right.typ)
			if isinstance(expr_left_typ, type.Optional):
				if expr.op in (
				    Kind.Eq, Kind.Ne
				) and not isinstance(expr_left_typ.typ, type.Ref):
					left = self.convert_expr_with_cast(expr_left_typ, expr.left)
					val = Selector(self.comp.bool_t, left, Name("is_none"))
					if expr.op == Kind.Ne:
						val = Inst(InstKind.BooleanNot, [val])
					return val
				elif expr.op == Kind.KeyOrElse:
					expr_typ = expr_left_typ
					left = self.convert_expr_with_cast(expr_typ, expr.left)
					is_none_label = self.cur_fn.local_name()
					is_not_none_label = self.cur_fn.local_name()
					exit_label = self.cur_fn.local_name()
					if isinstance(expr_typ.typ, type.Ref):
						cond = Inst(
						    InstKind.Cmp,
						    [Name("=="), left, NoneLiteral()]
						)
					else:
						cond = Selector(self.comp.bool_t, left, Name("is_none"))
					tmp = Ident(expr_typ.typ, self.cur_fn.local_name())
					self.cur_fn.alloca_var(tmp)
					self.cur_fn.add_cond_br(
					    cond, is_none_label, is_not_none_label
					)
					self.cur_fn.add_label(is_none_label)
					right = self.convert_expr_with_cast(
					    expr_typ.typ, expr.right
					)
					self.cur_fn.store(tmp, right)
					self.cur_fn.add_br(exit_label)
					self.cur_fn.add_label(is_not_none_label)
					if isinstance(expr_typ.typ, type.Ref):
						self.cur_fn.store(tmp, left)
					else:
						self.cur_fn.store(
						    tmp, Selector(expr_typ.typ, left, Name("value"))
						)
					self.cur_fn.add_label(exit_label)
					return tmp
			elif expr.op in (Kind.KeyAnd, Kind.KeyOr):
				left = self.convert_expr_with_cast(expr_left_typ, expr.left)
				if isinstance(left, IntLiteral):
					if left.lit == "0" and expr.op == Kind.KeyAnd:
						return left
					elif left.lit == "1" and expr.op == Kind.KeyOr:
						return left
					return self.convert_expr_with_cast(
					    expr_right_typ, expr.right
					)

				tmp = Ident(self.comp.bool_t, self.cur_fn.local_name())
				self.cur_fn.alloca_var(tmp)
				self.cur_fn.store(tmp, left)
				left_l = self.cur_fn.local_name()
				exit_l = self.cur_fn.local_name()

				if expr.op == Kind.KeyAnd:
					self.cur_fn.add_cond_br(left, left_l, exit_l)
				else:
					self.cur_fn.add_cond_br(left, exit_l, left_l)

				self.cur_fn.add_label(left_l)
				self.cur_fn.store(
				    tmp, self.convert_expr_with_cast(expr_left_typ, expr.right)
				)

				self.cur_fn.add_label(exit_l)
				return tmp
			elif expr.op in (Kind.KeyIs, Kind.KeyNotIs):
				left = self.convert_expr_with_cast(expr_left_typ, expr.left)
				tmp = self.cur_fn.local_name()
				if expr.op == Kind.KeyIs:
					kind = "=="
				else:
					kind = "!="
				left_sym = expr_left_typ.get_sym()
				if expr_left_typ == self.comp.error_t:
					self.cur_fn.alloca(
					    expr.typ, tmp,
					    Inst(
					        InstKind.Cmp, [
					            Name(kind),
					            Selector(expr.typ, left, Name("tag")),
					            IntLiteral(
					                self.comp.usize_t,
					                str(expr_right_typ.sym.info.nr)
					            )
					        ]
					    )
					)
				else:
					self.cur_fn.alloca(
					    expr.typ, tmp,
					    Inst(
					        InstKind.Cmp, [
					            Name(kind),
					            Selector(expr.typ, left, Name("idx")),
					            IntLiteral(
					                self.comp.usize_t,
					                str(expr_right_typ.sym.index)
					            )
					        ]
					    )
					)
				return Ident(expr.typ, tmp)

			left = self.convert_expr_with_cast(expr_left_typ, expr.left)
			right = self.convert_expr_with_cast(expr_right_typ, expr.right)

			if self.comp.is_unsigned_int(expr_left_typ
			                             ) and isinstance(right, IntLiteral):
				if expr.op == Kind.Lt and right.lit == "0":
					report.warn(
					    "comparison is useless due to type limits",
					    expr.right.pos
					)
				elif expr.op in (Kind.Eq, Kind.Ne, Kind.Le,
				                 Kind.Ge) and right.value() < 0:
					report.error(
					    "unsigned integer cannot be compared with negative value",
					    expr.right.pos
					)
				else:
					self.check_number_limit(
					    expr_left_typ, right.value(), expr.right.pos
					)
			elif isinstance(left, IntLiteral
			                ) and self.comp.is_unsigned_int(expr_right_typ):
				if expr.op == Kind.Lt and left.lit == "0":
					report.warn(
					    "comparison is useless due to type limits",
					    expr.left.pos
					)
				elif expr.op in (Kind.Eq, Kind.Ne, Kind.Le,
				                 Kind.Ge) and left.value() < 0:
					report.error(
					    "unsigned integer cannot be compared with negative value",
					    expr.left.pos
					)
				else:
					self.check_number_limit(
					    expr_left_typ, left.value(), expr.right.pos
					)
			elif expr.op in (Kind.Lshift,
			                 Kind.Rshift) and isinstance(right, IntLiteral):
				ivalue = right.value()
				if ivalue < 0:
					report.error("invalid negative shift count", expr.right.pos)
				if expr_left_typ in (self.comp.int8_t, self.comp.uint8_t):
					moffset = 7
				elif expr_left_typ in (self.comp.int16_t, self.comp.uint16_t):
					moffset = 15
				elif expr_left_typ in (
				    self.comp.int32_t, self.comp.uint32_t,
				    self.comp.untyped_int_t
				):
					moffset = 31
				elif expr_left_typ in (self.comp.int64_t, self.comp.uint64_t):
					moffset = 63
				else:
					moffset = 64
				if ivalue > moffset:
					report.error(
					    f"shift count for type `{expr_left_typ}` too large",
					    expr.right.pos
					)
					report.note(f"maximum: {moffset} bits")
				if isinstance(left, IntLiteral):
					if left.value() < 0:
						report.error(
						    "invalid bitshift of a negative number",
						    expr.left.pos
						)

			# comptime calculation
			skip_calc = False
			if expr.op in (Kind.Div,
			               Kind.Mod) and isinstance(right, IntLiteral):
				val = right.value()
				if expr.op == Kind.Div and val == 0:
					report.error("division by zero", expr.pos)
					skip_calc = True
				elif val <= 0:
					report.error("module by zero or negative value", expr.pos)
					skip_calc = True

			if not skip_calc:
				if isinstance(left,
				              IntLiteral) and isinstance(right, IntLiteral):
					computed = True
					if expr.op == Kind.Plus:
						res = left.value() + right.value()
					elif expr.op == Kind.Minus:
						res = left.value() - right.value()
					elif expr.op == Kind.Mult:
						res = left.value() * right.value()
					elif expr.op == Kind.Div:
						res = left.value() // right.value()
					elif expr.op == Kind.Mod:
						res = left.value() % right.value()
					elif expr.op == Kind.Amp:
						res = left.value() & right.value()
					elif expr.op == Kind.Pipe:
						res = left.value() | right.value()
					elif expr.op == Kind.Xor:
						res = left.value() ^ right.value()
					elif expr.op == Kind.Lshift:
						res = left.value() << right.value()
					elif expr.op == Kind.Rshift:
						res = left.value() >> right.value()
					elif expr.op == Kind.Eq:
						res = int(left.value() == right.value())
					elif expr.op == Kind.Ne:
						res = int(left.value() != right.value())
					elif expr.op == Kind.Lt:
						res = int(left.value() < right.value())
					elif expr.op == Kind.Gt:
						res = int(left.value() > right.value())
					elif expr.op == Kind.Le:
						res = int(left.value() <= right.value())
					elif expr.op == Kind.Ge:
						res = int(left.value() >= right.value())
					else:
						computed = False
					if computed:
						return IntLiteral(expr.typ, str(res))
				elif isinstance(left, FloatLiteral
				                ) and isinstance(right, FloatLiteral):
					computed = True
					if expr.op == Kind.Plus:
						res = float(left.lit) + float(right.lit)
					elif expr.op == Kind.Minus:
						res = float(left.lit) - float(right.lit)
					elif expr.op == Kind.Mult:
						res = float(left.lit) * float(right.lit)
					elif expr.op == Kind.Div:
						res = float(left.lit) / float(right.lit)
					elif expr.op == Kind.Eq:
						res = float(left.lit) == float(right.lit)
					elif expr.op == Kind.Ne:
						res = float(left.lit) != float(right.lit)
					elif expr.op == Kind.Lt:
						res = float(left.lit) < float(right.lit)
					elif expr.op == Kind.Gt:
						res = float(left.lit) > float(right.lit)
					elif expr.op == Kind.Le:
						res = float(left.lit) <= float(right.lit)
					elif expr.op == Kind.Ge:
						res = float(left.lit) >= float(right.lit)
					else:
						computed = False
					if computed:
						return FloatLiteral(expr.typ, str(res))
				elif isinstance(left, StringLiteral
				                ) and isinstance(right, StringLiteral):
					computed = True
					if expr.op == Kind.Eq:
						res = int(left.lit == right.lit)
					elif expr.op == Kind.Ne:
						res = int(left.lit != right.lit)
					elif expr.op == Kind.Lt:
						res = int(left.lit < right.lit)
					elif expr.op == Kind.Gt:
						res = int(left.lit > right.lit)
					elif expr.op == Kind.Le:
						res = int(left.lit <= right.lit)
					elif expr.op == Kind.Ge:
						res = int(left.lit >= right.lit)
					else:
						computed = False
					if computed:
						return IntLiteral(expr.typ, str(res))

			# runtime calculation
			tmp = self.cur_fn.local_name()
			typ_sym = expr_left_typ.get_sym()
			if expr.op.is_overloadable_op() and typ_sym.kind in (
			    TypeKind.Array, TypeKind.Slice, TypeKind.Str, TypeKind.Struct
			) and not isinstance(expr_left_typ, type.Ptr):
				if typ_sym.kind == TypeKind.Array:
					if expr.op == Kind.Eq:
						name = "_R4core8array_eqF"
					elif expr.op == Kind.Ne:
						name = "_R4core8array_neF"
					size, _ = self.comp.type_size(expr_left_typ)
					self.cur_fn.alloca(
					    expr.typ, tmp,
					    Inst(
					        InstKind.Call, [
					            Name(name), left, right,
					            IntLiteral(self.comp.usize_t, str(size))
					        ]
					    )
					)
				else:
					op_method = OVERLOADABLE_OPERATORS_STR[str(expr.op)]
					self.cur_fn.alloca(
					    expr.typ, tmp,
					    Inst(
					        InstKind.Call, [
					            Name(
					                mangle_symbol(typ_sym) +
					                f"{len(op_method)}{op_method}M"
					            ),
					            Inst(InstKind.GetRef, [left]),
					            Inst(InstKind.GetRef, [right])
					        ]
					    )
					)
				return Ident(expr.typ, tmp)
			if expr.op.is_relational():
				if expr.op == Kind.Eq:
					kind = "=="
				elif expr.op == Kind.Ne:
					kind = "!="
				elif expr.op == Kind.Lt:
					kind = "<"
				elif expr.op == Kind.Gt:
					kind = ">"
				elif expr.op == Kind.Le:
					kind = "<="
				else:
					kind = ">="
				self.cur_fn.alloca(
				    expr.typ, tmp,
				    Inst(InstKind.Cmp, [Name(kind), left, right])
				)
			elif expr.op in (Kind.Div, Kind.Mod):
				is_div = expr.op == Kind.Div
				kind = InstKind.Div if is_div else InstKind.Mod
				if not isinstance(right, IntLiteral):
					msg = utils.smart_quote(
					    f"attempt to divide `{expr.left}` by zero"
					    if is_div else
					    f"attempt to calculate the remainder of `{expr.left}` with a divisor of zero or negative value",
					    False
					)
					self.cur_fn.add_call(
					    "_R4core8panic_ifF", [
					        Inst(
					            InstKind.Cmp, [
					                Name("==" if is_div else "<="), right,
					                IntLiteral(expr.typ, "0")
					            ]
					        ),
					        StringLiteral(self.comp.str_t, msg, len(msg))
					    ]
					)
				self.cur_fn.alloca(expr.typ, tmp, Inst(kind, [left, right]))
			else:
				if expr.op == Kind.Plus:
					kind = InstKind.Add
				elif expr.op == Kind.Minus:
					kind = InstKind.Sub
				elif expr.op == Kind.Mult:
					kind = InstKind.Mult
				elif expr.op == Kind.Amp:
					kind = InstKind.BitAnd
				elif expr.op == Kind.Pipe:
					kind = InstKind.BitOr
				elif expr.op == Kind.Xor:
					kind = InstKind.BitXor
				elif expr.op == Kind.Lshift:
					kind = InstKind.Lshift
				elif expr.op == Kind.Rshift:
					kind = InstKind.Rshift
				else:
					assert False, expr.op # unreachable
				self.cur_fn.alloca(expr.typ, tmp, Inst(kind, [left, right]))
			return Ident(expr.typ, tmp)
		elif isinstance(expr, ast.PostfixExpr):
			left = self.convert_expr_with_cast(expr.typ, expr.left)

			# comptime calculation
			if isinstance(left, IntLiteral):
				return left

			# runtime calculation
			if expr.op == Kind.Inc:
				kind = InstKind.Inc
			else:
				kind = InstKind.Dec
			tmp = self.cur_fn.local_name()
			self.cur_fn.alloca(expr.typ, tmp, Inst(kind, [left]))
			return Ident(expr.typ, tmp)
		elif isinstance(expr, ast.Block):
			self.convert_stmts(expr.stmts)
			if expr.is_expr:
				return self.convert_expr(expr.expr)
		elif isinstance(expr, ast.IfExpr):
			is_void_value = expr.typ in self.void_types
			if expr.is_comptime:
				if expr.branch_idx == -1:
					return Skip()
				else:
					return self.convert_expr(
					    expr.branches[expr.branch_idx].expr
					)
			if len(expr.branches) == 2 and not is_void_value:
				b2 = expr.branches[1]
				if b2.is_else:
					b1 = expr.branches[0]
					cond = self.convert_expr_with_cast(expr.typ, b1.cond)
					if isinstance(cond, IntLiteral):
						if cond.lit == "1":
							# use first value if cond is true
							return self.convert_expr_with_cast(
							    expr.typ, b1.expr
							)
						else:
							# use second value instead
							return self.convert_expr_with_cast(
							    expr.typ, b2.expr
							)
			gen_branch = True
			exit_label = self.cur_fn.local_name()
			else_label = self.cur_fn.local_name(
			) if expr.has_else else exit_label
			tmp = Ident(
			    expr.typ,
			    self.cur_fn.local_name() if not is_void_value else ""
			)
			if not is_void_value:
				self.cur_fn.alloca_var(tmp)
			self.cur_fn.add_comment(f"if expr (end: {exit_label})")
			next_branch = ""
			for i, b in enumerate(expr.branches):
				if not gen_branch:
					break
				self.cur_fn.add_comment(f"if branch (is_else: {b.is_else})")
				if b.is_else:
					self.cur_fn.add_label(else_label)
				else:
					if isinstance(b.cond, ast.GuardExpr):
						gexpr = self.convert_expr_with_cast(
						    b.cond.expr.typ, b.cond.expr
						)
						if b.cond.is_result:
							cond = Inst(
							    InstKind.BooleanNot, [
							        Selector(
							            self.comp.bool_t, gexpr, Name("is_err")
							        )
							    ]
							)
						else:
							cond = Inst(
							    InstKind.BooleanNot, [
							        Selector(
							            self.comp.bool_t, gexpr,
							            Name("is_none")
							        )
							    ]
							)
						self.cur_fn.alloca(
						    b.cond.expr.typ.typ, b.cond.vars[0],
						    Selector(b.cond.expr.typ.typ, gexpr, Name("value"))
						)
					else:
						cond = self.convert_expr_with_cast(
						    self.comp.bool_t, b.cond
						)
					if isinstance(cond, IntLiteral) and cond.lit == "0":
						continue # skip `if` branch with false condition
					branch_label = self.cur_fn.local_name()
					if i == len(expr.branches) - 1:
						next_branch = exit_label
					elif i + 1 == len(expr.branches
					                  ) - 1 and expr.branches[i + 1].is_else:
						next_branch = else_label
					else:
						next_branch = self.cur_fn.local_name()
					if isinstance(cond, IntLiteral) and cond.lit == "1":
						gen_branch = False
					else:
						self.cur_fn.add_cond_br(cond, branch_label, next_branch)
						self.cur_fn.add_label(branch_label)
						if isinstance(b.cond, ast.GuardExpr):
							if b.cond.has_cond:
								gcond = self.convert_expr_with_cast(
								    self.comp.bool_t, b.cond.cond
								)
								self.cur_fn.add_cond_br(
								    gcond, branch_label, next_branch
								)
				if is_void_value:
					self.convert_expr_with_cast(
					    expr.typ, b.expr
					) # ignore void value
				else:
					self.cur_fn.store(
					    tmp, self.convert_expr_with_cast(expr.typ, b.expr)
					)
				if gen_branch:
					self.cur_fn.add_comment(
					    "if expr branch (goto to other branch)"
					)
					self.cur_fn.add_br(exit_label)
				if len(next_branch) > 0 and next_branch != else_label:
					self.cur_fn.add_label(next_branch)
			if gen_branch:
				self.cur_fn.add_label(exit_label)
			if not is_void_value:
				return tmp
		elif isinstance(expr, ast.MatchExpr):
			is_error_t = expr.expr.typ == self.comp.error_t
			is_void_value = expr.typ in self.void_types
			exit_match = self.cur_fn.local_name()
			self.cur_fn.add_comment(f"match expr (end: {exit_match})")
			tmp = Ident(
			    expr.typ,
			    self.cur_fn.local_name() if not is_void_value else ""
			)
			if not is_void_value:
				self.cur_fn.alloca_var(tmp)
			is_guard_expr = isinstance(expr.expr, ast.GuardExpr)
			if is_guard_expr:
				gexpr = self.convert_expr_with_cast(
				    expr.expr.typ, expr.expr.expr
				)
				if expr.expr.is_result:
					cond = Selector(self.comp.bool_t, gexpr, Name("is_err"))
				else:
					cond = Selector(self.comp.bool_t, gexpr, Name("is_none"))
				self.cur_fn.alloca(
				    expr.expr.typ, expr.expr.vars[0],
				    Selector(expr.expr.typ, gexpr, Name("value"))
				)
				self.cur_fn.add_cond_single_br(cond, exit_match)
				if expr.expr.has_cond:
					self.cur_fn.add_cond_single_br(
					    Inst(
					        InstKind.BooleanNot, [
					            self.convert_expr_with_cast(
					                self.comp.bool_t, expr.expr.cond
					            )
					        ]
					    ), exit_match
					)
				match_expr = Ident(expr.expr.typ, expr.expr.vars[0])
			else:
				match_expr = self.convert_expr_with_cast(
				    expr.expr.typ, expr.expr
				)
			for b in expr.branches:
				b_label = "" if b.is_else else self.cur_fn.local_name()
				b_exit = exit_match if b.is_else else self.cur_fn.local_name()
				if not b.is_else:
					self.cur_fn.add_comment(
					    f"match expr patterns (len: {len(b.pats)})"
					)
				for i, p in enumerate(b.pats):
					next_pat = self.cur_fn.local_name(
					) if i < len(b.pats) - 1 else b_exit
					tmp2 = self.cur_fn.local_name()
					if expr.is_typematch:
						field_name = "tag" if is_error_t else "idx"
						type_nr = p.typ.sym.info.nr if is_error_t else p.typ.sym.index
						self.cur_fn.alloca(
						    self.comp.bool_t, tmp2,
						    Inst(
						        InstKind.Cmp, [
						            Name("=="),
						            Selector(
						                expr.expr.typ, match_expr,
						                Name(field_name)
						            ),
						            IntLiteral(self.comp.usize_t, str(type_nr))
						        ]
						    )
						)
					else:
						p_conv = self.convert_expr_with_cast(p.typ, p)
						if p.typ == self.comp.str_t:
							inst = Inst(
							    InstKind.Call, [
							        Name("_R4core4_str4_eq_M"),
							        Inst(InstKind.GetRef, [match_expr]),
							        Inst(InstKind.GetRef, [p_conv]),
							    ]
							)
						else:
							inst = Inst(
							    InstKind.Cmp, [Name("=="), match_expr, p_conv]
							)
						self.cur_fn.alloca(self.comp.bool_t, tmp2, inst)
					self.cur_fn.add_cond_br(
					    Ident(self.comp.bool_t, tmp2), b_label, next_pat
					)
					if i < len(b.pats) - 1:
						self.cur_fn.add_label(next_pat)
				if not b.is_else:
					self.cur_fn.add_label(b_label)
				if b.has_var:
					union_value = Selector(
					    b.var_type, match_expr,
					    Name(mangle_symbol(b.var_type.get_sym()))
					)
					if b.var_is_ref:
						union_value = Inst(InstKind.GetRef, [union_value])
					self.cur_fn.alloca(b.var_type, b.var_name, union_value)
				if is_void_value:
					self.convert_expr_with_cast(
					    expr.typ, b.expr
					) # ignore void value
				else:
					self.cur_fn.store(
					    tmp, self.convert_expr_with_cast(expr.typ, b.expr)
					)
				self.cur_fn.add_br(exit_match)
				if not b.is_else:
					self.cur_fn.add_label(b_exit)
			self.cur_fn.add_label(exit_match)
			if not is_void_value:
				return tmp
		else:
			raise Exception(expr.__class__)
		return Skip()

	def convert_const(self, const_sym):
		if const_sym.has_evaled_expr:
			const_sym.has_ir_expr = True
			const_sym.ir_expr = self.convert_expr_with_cast(
			    const_sym.typ, const_sym.evaled_expr
			)
			return const_sym.ir_expr
		if const_sym.has_ir_expr:
			return const_sym.ir_expr
		const_sym.has_ir_expr = True
		const_sym.ir_expr = self.convert_expr_with_cast(
		    const_sym.typ, const_sym.expr
		)
		return const_sym.ir_expr

	def result_ok(self, typ, value):
		tmp = Ident(self.unwrap(typ), self.cur_fn.local_name())
		self.cur_fn.alloca_var(tmp)
		self.cur_fn.store(
		    Selector(self.comp.bool_t, tmp, Name("is_err")),
		    IntLiteral(self.comp.bool_t, "0")
		)
		self.cur_fn.store(
		    Selector(self.unwrap(self.cur_fn.ret_typ.typ), tmp, Name("value")),
		    value
		)
		return tmp

	def result_void_ok(self, typ):
		tmp = Ident(self.unwrap(typ), self.cur_fn.local_name())
		self.cur_fn.alloca_var(tmp)
		self.cur_fn.store(
		    Selector(self.comp.bool_t, tmp, Name("is_err")),
		    IntLiteral(self.comp.bool_t, "0")
		)
		return tmp

	def result_err(self, typ_, msg, tag, args):
		typ = self.unwrap(typ_)
		tmp = Ident(self.unwrap(self.cur_fn.ret_typ), self.cur_fn.local_name())
		self.cur_fn.alloca_var(tmp)
		self.cur_fn.store(
		    Selector(self.comp.bool_t, tmp, Name("is_err")),
		    IntLiteral(self.comp.bool_t, "1")
		)
		errtype_name = typ.get_sym().qualname()
		self.cur_fn.store(
		    Selector(self.comp.error_t, tmp, Name("err")),
		    Inst(
		        InstKind.Call, [
		            Name("_R4core6_error3newF"),
		            StringLiteral(
		                self.comp.str_t, errtype_name, len(errtype_name)
		            ),
		            IntLiteral(self.comp.uint8_t, str(tag)), msg,
		            self.variadic_args(
		                args, type.Type(self.comp.trait_to_string)
		            )
		        ]
		    )
		)
		return tmp

	def optional_ok(self, typ_, value):
		typ = self.unwrap(typ_)
		tmp = Ident(typ, self.cur_fn.local_name())
		self.cur_fn.alloca_var(tmp)
		self.cur_fn.store(
		    Selector(self.comp.bool_t, tmp, Name("is_none")),
		    IntLiteral(self.comp.bool_t, "0")
		)
		self.cur_fn.store(Selector(typ.typ, tmp, Name("value")), value)
		return tmp

	def optional_none(self, typ_):
		typ = self.unwrap(typ_)
		tmp = Ident(typ, self.cur_fn.local_name())
		self.cur_fn.alloca_var(tmp)
		self.cur_fn.store(
		    Selector(self.comp.bool_t, tmp, Name("is_none")),
		    IntLiteral(self.comp.bool_t, "1")
		)
		return tmp

	def trait_value(self, value, value_typ_, trait_typ):
		value_typ = self.unwrap(value_typ_)
		value_sym = self.comp.untyped_to_type(value_typ).get_sym()
		typ_sym = trait_typ.get_sym()
		tmp = Ident(trait_typ, self.cur_fn.local_name())
		self.cur_fn.alloca_var(tmp)
		self.cur_fn.store(
		    Selector(type.Ptr(self.comp.void_t), tmp, Name("obj")),
		    Inst(InstKind.GetRef, [value])
		)
		self.cur_fn.store(
		    Selector(self.comp.usize_t, tmp, Name("idx")),
		    IntLiteral(self.comp.usize_t, str(typ_sym.info.indexof(value_sym)))
		)
		return tmp

	def panic(self, msg):
		_, size = utils.bytestr(msg)
		self.cur_fn.add_call(
		    "_R4core5panicF", [
		        StringLiteral(
		            self.comp.str_t, utils.smart_quote(msg, False), str(size)
		        ),
		        Name("_R4core11empty_slice")
		    ]
		)

	def variadic_args(self, vargs, var_arg_typ_):
		var_arg_typ = self.unwrap(var_arg_typ_)
		if len(vargs) == 0:
			return Name("_R4core11empty_slice")
		elem_size, _ = self.comp.type_size(var_arg_typ)
		return Inst(
		    InstKind.Call, [
		        Name("_R4core6_slice10from_arrayF"),
		        ArrayLiteral(var_arg_typ, vargs, True),
		        IntLiteral(self.comp.usize_t, str(elem_size)),
		        IntLiteral(self.comp.usize_t, str(len(vargs)))
		    ]
		)

	def default_value(self, typ_):
		typ = self.unwrap(typ_)
		if isinstance(typ, type.Ptr) or isinstance(typ, type.Ref):
			return NoneLiteral(self.comp.none_t)
		if typ == self.comp.rune_t:
			return RuneLiteral("0")
		elif typ in (
		    self.comp.void_t, self.comp.bool_t, self.comp.int8_t,
		    self.comp.int16_t, self.comp.int32_t, self.comp.int64_t,
		    self.comp.uint8_t, self.comp.uint16_t, self.comp.uint32_t,
		    self.comp.uint64_t, self.comp.isize_t, self.comp.usize_t
		):
			return IntLiteral(typ, "0")
		elif typ in (self.comp.float32_t, self.comp.float64_t):
			return FloatLiteral(typ, "0.0")
		elif typ == self.comp.str_t:
			tmp = Ident(typ, self.cur_fn.local_name())
			self.cur_fn.alloca_var(tmp)
			self.cur_fn.store(
			    Selector(type.Ptr(self.comp.uint8_t), tmp, Name("ptr")),
			    StringLiteral(type.Ptr(self.comp.uint8_t), "", 0)
			)
			self.cur_fn.store(
			    Selector(self.comp.usize_t, tmp, Name("len")),
			    IntLiteral(self.comp.usize_t, "0")
			)
			return tmp
		elif isinstance(typ, type.Optional):
			return self.optional_ok(typ, self.default_value(typ.typ))
		elif isinstance(typ, type.Result):
			if typ.typ == self.comp.void_t:
				return self.result_void_ok(typ)
			return self.result_ok(typ, self.default_value(typ.typ))
		# TODO(StunxFS): Union,Trait
		typ_sym = typ.get_sym()
		if typ_sym.kind == TypeKind.Array:
			value = self.default_value(typ_sym.info.elem_typ)
			return ArrayLiteral(
			    typ, [value for _ in range(0, int(typ_sym.info.size.lit))]
			)
		elif typ_sym.kind == TypeKind.Slice:
			return Ident(typ, "_R4core11empty_slice")
		elif typ_sym.kind == TypeKind.Enum:
			return IntLiteral(typ_sym.info.underlying_typ, "0")
		elif typ_sym.kind == TypeKind.Tuple:
			tmp = Ident(typ, self.cur_fn.local_name())
			self.cur_fn.alloca_var(tmp)
			for i, typ in enumerate(typ_sym.info.types):
				self.cur_fn.store(
				    Selector(typ, tmp, Name(f"f{i}")), self.default_value(typ)
				)
			return tmp
		elif typ_sym.kind == TypeKind.Struct:
			tmp = Ident(typ, self.cur_fn.local_name())
			self.cur_fn.alloca_var(tmp)
			for f in typ_sym.fields:
				if f.has_def_expr:
					val = self.convert_expr_with_cast(f.typ, f.def_expr)
				else:
					val = self.default_value(f.typ)
				self.cur_fn.store(Selector(f.typ, tmp, Name(f.name)), val)
			return tmp
		return None

	def check_number_limit(self, typ, val, pos):
		if typ == self.comp.int8_t and (val < MIN_INT8 or val > MAX_INT8):
			report.error("literal out of range for `i8`", pos)
			report.note(
			    f"the literal `{val}` does not fit into the type `i8` whose "
			    f"range is `{MIN_INT8}..={MAX_INT8}`"
			)
		elif typ == self.comp.int16_t and (val < MIN_INT16 or val > MAX_INT16):
			report.error("literal out of range for `i16`", pos)
			report.note(
			    f"the literal `{val}` does not fit into the type `i16` whose "
			    f"range is `{MIN_INT16}..={MAX_INT16}`"
			)
		elif typ == self.comp.int32_t and (val < MIN_INT32 or val > MAX_INT32):
			report.error("literal out of range for `i32`", pos)
			report.note(
			    f"the literal `{val}` does not fit into the type `i32` whose "
			    f"range is `{MIN_INT32}..={MAX_INT32}`"
			)
		elif typ == self.comp.int64_t and (val < MIN_INT64 or val > MAX_INT64):
			report.error("literal out of range for `i64`", pos)
			report.note(
			    f"the literal `{val}` does not fit into the type `i64` whose "
			    f"range is `{MIN_INT64}..={MAX_INT64}`"
			)
		elif typ == self.comp.uint8_t and (val < 0 or val > MAX_UINT8):
			report.error("literal out of range for `u8`", pos)
			report.note(
			    f"the literal `{val}` does not fit into the type `u8` whose range is `0..={MAX_UINT8}`"
			)
		elif typ == self.comp.uint16_t and (val < 0 or val > MAX_UINT16):
			report.error("literal out of range for `u16`", pos)
			report.note(
			    f"the literal `{val}` does not fit into the type `u16` whose range is `0..={MAX_UINT16}`"
			)
		elif typ == self.comp.uint32_t and (val < 0 or val > MAX_UINT32):
			report.error("literal out of range for `u32`", pos)
			report.note(
			    f"the literal `{val}` does not fit into the type `u32` whose range is `0..={MAX_UINT32}`"
			)
		elif typ == self.comp.uint64_t and (val < 0 or val > MAX_UINT64):
			report.error("literal out of range for `u64`", pos)
			report.note(
			    f"the literal `{val}` does not fit into the type `u64` whose range is `0..={MAX_UINT64}`"
			)
		elif typ == self.comp.isize_t:
			if self.comp.prefs.target_bits == prefs.Bits.X64:
				min, max = MIN_INT64, MAX_INT64
			else:
				min, max = MIN_INT32, MAX_INT32
			if val < min or val > max:
				report.error("literal out of range for `isize`", pos)
				report.note(
				    f"the literal `{val}` does not fit into the type `isize` whose range is `{min}..={max}`"
				)
		elif typ == self.comp.usize_t:
			if self.comp.prefs.target_bits == prefs.Bits.X64:
				max = MAX_UINT64
			else:
				max = MAX_UINT32
			if val < 0 or val > max:
				report.error("literal out of range for `usize`", pos)
				report.note(
				    f"the literal `{val}` does not fit into the type `usize` whose range is `0..={max}`"
				)
		elif typ == self.comp.rune_t and (val < 0 or val > MAX_RUNE):
			report.error("literal out of range for `rune`", pos)
			report.note(
			    f"the literal `{val}` does not fit into the type `rune` whose range is `0..={MAX_RUNE}`"
			)

	def get_type_symbols(self, root):
		ts = list()
		for s in root.syms:
			if isinstance(s, sym.Type):
				if s.name == "error" and root.is_universe:
					continue
				ts.append(s)
			elif isinstance(s, sym.Pkg):
				ts += self.get_type_symbols(s)
			elif isinstance(s, sym.Mod):
				ts += self.get_type_symbols(s)
		return ts

	def sort_type_symbols(self, tss):
		dg = utils.DepGraph()
		typ_names = list()
		for ts in tss:
			if ts.kind in (
			    sym.TypeKind.Alias, sym.TypeKind.ErrType, sym.TypeKind.NoReturn
			):
				continue
			ts.mangled_name = mangle_symbol(ts)
			typ_names.append(ts.mangled_name)
		for ts in tss:
			has_generic = False
			if ts.kind in (
			    sym.TypeKind.Alias, sym.TypeKind.ErrType, sym.TypeKind.NoReturn,
			    sym.TypeKind.TypeArg
			):
				continue
			field_deps = list()
			if ts.kind == sym.TypeKind.Array:
				dsym = ts.info.elem_typ.get_sym()
				if dsym.kind == TypeKind.TypeArg:
					has_generic = True
				dep = mangle_symbol(dsym)
				if dep in typ_names:
					field_deps.append(dep)
			elif ts.kind == sym.TypeKind.Tuple:
				for f in ts.info.types:
					dsym = f.get_sym()
					if dsym.kind == TypeKind.TypeArg:
						has_generic = True
					dep = mangle_symbol(dsym)
					if dep not in typ_names or dep in field_deps or isinstance(
					    f, type.Ref
					):
						continue
					field_deps.append(dep)
			elif ts.kind == sym.TypeKind.Union:
				for v in ts.info.variants:
					dep = mangle_symbol(v.get_sym())
					if dep not in typ_names or dep in field_deps or isinstance(
					    f.typ, type.Optional
					):
						continue
					field_deps.append(dep)
			elif ts.kind == sym.TypeKind.Struct:
				for f in ts.fields:
					dsym = f.typ.get_sym()
					if dsym.kind == TypeKind.TypeArg:
						has_generic = True
					dep = mangle_symbol(dsym)
					if dep not in typ_names or dep in field_deps or isinstance(
					    f.typ, type.Optional
					):
						continue
					field_deps.append(dep)
			if not has_generic:
				dg.add(ts.mangled_name, field_deps)
		dg_sorted = dg.resolve()
		if not dg_sorted.acyclic:
			utils.error(
			    "codegen: the following types form a dependency cycle:\n" +
			    dg_sorted.display_cycles()
			)
		types_sorted = list()
		for node in dg_sorted.nodes:
			for ts in tss:
				if ts.mangled_name == node.name:
					types_sorted.append(ts)
		return types_sorted

	def unwrap(self, typ):
		if len(self.cur_concrete_types) == 0:
			return typ
		elif isinstance(typ, type.Type):
			if typ.sym.kind == TypeKind.TypeArg and typ.expr.type_arg_idx >= 0:
				return self.cur_concrete_types[typ.expr.name]
			return type.Type(self.unwrap_symbol(typ.sym))
		elif isinstance(typ, (type.Result, type.Optional, type.Ptr, type.Ref)):
			return type.resolve_generic(
			    self.comp.universe, typ, typ.typ, self.unwrap(typ.typ)
			)
		#elif isinstance(typ, type.Fn):
		#	for i in range(len(self.args)):
		#		self.args[i].typ=self.unwrap(self.args[i].typ)
		#	self.ret_typ=self.unwrap(ret_typ)
		return type.Type(self.unwrap_symbol(typ.get_sym()))

	def unwrap_symbol(self, tsym):
		if tsym.kind == TypeKind.Array:
			return self.comp.universe.add_or_get_array(
			    type.resolve_generic(
			        self.comp.universe, typ, tsym.info.elem_typ,
			        self.unwrap(tsym.info.elem_typ)
			    ), tsym.info.size
			)
		elif tsym.kind == TypeKind.Slice:
			return self.comp.universe.add_or_get_slice(
			    self.comp.universe, typ, tsym.info.elem_typ,
			    self.unwrap(tsym.info.elem_typ)
			)
		elif tsym.kind == TypeKind.Tuple:
			new_types = []
			for old_t in tsym.info.types:
				new_types.append(
				    type.resolve_generic(
				        self.comp.universe, old_t, old_t, self.unwrap(old_t)
				    )
				)
			return self.comp.universe.add_or_get_tuple(new_types)
		return tsym
