// simple comment

/*
* multi-comment
*/

extern pkg core;
extern pkg std;

type c_int = i32;

const MAX_SIZE: i32 = 10;
const MIN_SIZE: i32 = 1;

static STATIC_VALUE: i32 = 10;
static mut UNSAFE_STATIC_VALUE: i32 = 5;

type Integer32 = i32;
pub type WideChar = u16;
pub type WideStr = *u16;

pub(pkg) type Byte = u8;
pub type Int = i32;

errtype RuntimeError;
pub errtype FileNotFoundError;

type EventHandler = fn(mut Byte, WideChar) void;

fn event_handler(f: EventHandler) void {
    f(b'2', 76);
}

fn fn_pointer(func: fn() void) void {
    func();
}

unsafe fn unsafe_fn_pointer(
    a: unsafe fn(usize) ptr, // `malloc` type
    b: unsafe extern "C" fn(ptr) c_void, // `free` type
    c: extern "C" fn(c_int) void // `exit` type
) void { }

fn println(s: str) void { }
fn exists(s: str) bool { return true; }
fn print_target_info() void { }
fn print_info(info: str) void { }
fn generate_unique_id() i32 { return 0; }

mod capsule {
    pub errtype RuntimeError;
}

fn test_assign(a: i32 = 5) void {
    let x = 1;
    let y = $if (_LINUX_) {
        trace!("None");
        0
    } $else {
        trace!("Some");
        5
    };
}

fn open(path: str) !str {
    $if (_LINUX_) {
        if (!exists(path)) {
            raise FileNotFoundError();
        }
        return path;
    }
    raise RuntimeError("unsupported OS for `open`");
}

enum Service {
    VIP,
    Fast,
    Unique,
    Small,
    Free
}

type Windows = [(WideStr, Integer32, &WideChar); 11];

struct Account {
    pub mut name: str;
    pub id: i32; // unique ID
    pub mut password: str;
    pub mut is_active: bool;

    /// Custom services. A private field.
    mut services: [Service; 3] = [Service::VIP, .Small, .Unique];

    #[inline]
    pub fn new(name: str, password: str) Self {
        return Self{
            name: name,
            id: generate_unique_id(),
            password: password
        };
    }

    other_field: bool;
    small_field: Windows;

    #[if (DEFINE_FIELD2)]
    other_field2: bool;

    fn method(self) void {
        while { // infinite loop == while (true)
            if (1 >= 3) {
                break;
            }
            continue;
        }
    }

    fn method2(&self) void { }

    fn method3(mut &self) void { }

    fn associated_function() void {
    L1:
        trace!("garrotero");
        unsafe { goto L1; }
    }

    ~self {
        // struct destructor
        trace!("~Account() called");
    }
}

trait Printable {
    fn to_str() str;
}

trait Writable {
	fn write(buf: [u8]) !?i32;
	fn write_to(pos: u64, buf: [u8]) !?i32;
}

trait Widget {
    fn id() str;

    fn id_and_name() str {
        return self.id();
    }
}

fn optional() ?i32 {
    return none;
}

fn error() !void {
    trace!("Error =D");
    raise RuntimeError("simple error =D");
}

test "Test body with cool name =D!" {
    trace!("inside test");
    assert!(2 >= 5);

    let mut x = optional() orelse {
        5
    };
    assert!(x == 5);

    x = 10;
    assert!(x == 10);

    x += 10;
    assert!(x == 20);

    let (a, b, c) = (1, 2, 3);
    assert!(a == 1 and b == 2 and c == 3);

    error() catch {
        trace!("error catched");
    };

    let m = error() catch |err| {
        assert!(err is RuntimeError);
        assert!(err.msg.len == 15);
        ()
    };

    error() catch return;
    optional() orelse raise RuntimeError("`none` detected");
}

extend EmptyStruct {
    fn julian() void {}
}

type Alias = i32;

struct EmptyStruct {
    fff: Alias;
}

#[no_tag]
union LikeC {
    f32, i32
}

union Object {
    str, i64;

    fn to_str() str {
        if (self is str) {
            return cast(self, str);
        }
        return "<i64-value>";
    }
}

enum ReportLevel {
    Low,
    High
}

enum NPCRol {
    Enemy,
    Friend,
    Helper,
    Bot,
    Police;

    pub fn to_str() str {
        if (self == .Enemy) {
            return "<Enemy>";
        }
        return "<Friend =D>";
    }
}

#[if (DEFINE_EXIT_FUNCS)]
extern "C" {
    fn exit(status: i32) c_void;
    fn abort() c_void;
}

extern "C" fn abs(a: c_int) c_int;

/// A simple module for doc-comments.
///
/// Other new line in doc-comment. More text, simple =D.
mod simple { }

pub mod simple2 {
    pub mod inner_mod {
        pub mod pub_inner_mod { }
    }

    mod snacks { }
}

static mut VALUE: i32 = 5;

unsafe fn get_mutable_pointer() mut &i32 {
    return unsafe { &VALUE };
}

extend u8 {
    pub fn to_str() str { return ""; }
}

#[if (EXTEND_CUSTOM_TYPE)]
extend CustomType {
    pub fn custom_fn() void { }
}

pub fn pub_basic_fn(alpha: i32, arr: [i32; 5], slice: [i32]) void { }

#[inline]
fn basic_fn(return_none: bool) ?i32 { return if (return_none) none else 5; }

#[abstract; virtual] // <- attributes
unsafe fn def_arg(a: i32 = 10, tuple: (bool, void, u8)) void { }

fn result() !i32 { }

unsafe fn call_unsafe() void { }
fn run() void { }

fn expr_stmt() void { }

fn install_app() void { }

struct Player { }

fn simple_fn() !void {
    call_unsafe(unsafe {
        trace!("inside unsafe!");
        x()
    });

    unsafe {
        x();
    }

    run(player: Player{
        name: "StunxFS",
        rol: .Sheriff
    }).!;

    expr_stmt({
        // block expression
        println();
        println();
        2 / 5
    });

    { // block statement
        expr_stmt(
            {
                // block expression
                println();
                println();
                2 / 5
            },
            {
                // block expr
                println();
                println();
            },
            if (true) { // if expr
                install_app();
                .Installed
            } else {
                panic!("error");
            },
            match (5) { // match expr
                5 => 5,
                8 => 6,
                else => 333
            },
            array: [1, 2, 3, 4, 5, 6, 7, 8],
            slice: [1, 2, 3, 4, 5, 6][0..4],
            tuple: (1, 2, 3, 4, 5, 6, 7, 8)
        );
    }

    // if stmt
    if (true) {
        println();
    } elif (false) {
        println();
    } else {
        println();
    }

    // match stmt
    match (555) {
        555 => println("555"),
        777 => println("777"),
        888, 999 => println("888 or 999"),
        else => println("finch")
    }

    // typematch
    let union_value = Object(5);
    match (union_value) is {
        str => println("str"),
        i32 => println("i32"),
        bool => {
            // block expr
            while { println("simple block expr"); }
        },
        else => println("unknown type")
    }

    let mut x = 1;
    while (x < 5) {
        x++;
    }

    while {
        x++;
        if (x < 5) {
            println();
        }
    }
}

mod real {
    pub fn scrash() void {
        match {
            2 >= 4 and 3 + 3 == 6 => trace!("yeah!"),
            else => {}
        }
        return (); // == return;
    }

    pub mod sis {
        fn inner(a: &[i32], mut b: [u8; 4]) void { }
    }

    fn x() !i32 { }

    fn z(a: *i32, b: ***i32) ?bool {}

    fn arrays() [i32; 5] { }

    fn slices() &[i32] { }
}

fn comptime() void {
    print_target_info($_OS_, $_ARCH_, $_ENDIAN_, $_BITS_, $_BACKEND_);
    print_info($_FILE_, $_FUNCTION_, $_LINE_, $_COLUMN_);
    $if (_LINUX_ or true) {
        compile_warn!("comptime works!");
    } $else {
        compile_warn!("comptime doesn't works =(");
    }
}

/// doc-comment
fn main() void {
    // Unlike `while`, `for` is only valid with values that implement
    // the `Iterator` trait.
    for (x in [1, 2, 3, 4]) {
        // ...
    }

    // The `for` is just a shorthand way of writing the following:
    let _T0 = [1, 2, 3, 4].iter();
    let _T1 = _T0.next();
    while (_T1 != none) {
        // ...
        _T1 = _T0.next();
    }

    $if (false) {
        let map: Map = Map::new([("Key", 5)]);
        for ((key, mut &value) in map) {
            assert!(key == "Key" and value.* == 5);
        }
    }
}
