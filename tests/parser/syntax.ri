//! module-level doc-comment

/*
* Multi-comment
*/

extern pkg core;
extern pkg std;

mod simple { }

[unsafe; abstract; virtual] // <- attributes
pub mod simple2 {
    [inline]
    pub mod inner_mod {
        [unsafe]
        [simple]
        pub mod pub_inner_mod { }
    }

    mod snacks { }
}

pub fn pub_basic_fn(alpha: i32, arr: [i32; 5], slice: [i32]) void {
}

fn basic_fn() ?i32 {
}

fn def_arg(a: i32 = 10, tuple: (bool, void, u8)) {}

/*
extern "C" {
    fn exit(status: i32);
    fn abort();
}

extern "C" fn x();

mod real {
    pub fn scrash() {}

    pub mod sis {
        fn inner(a: &[i32], mut b: [u8; 4]) {
        }
    }

    fn x() !i32 {
    }

    fn z(a: *i32, b: ***i32) ?bool {}
}

/// symbol-level doc-comment
fn main() {
    // simple comment

    let mut x = 1;
    while (x < 5) {
        x++;
    }

    loop {
        x++;
        if (x < 5) {
            break;
        }
    }

    // Unlike `while` and `loop`, `for` is only valid with values
    // that implement the `Iterator` trait.
    for (x in [1, 2, 3, 4]) {
        // ...
    }

    // The `for` is just a shorthand way of writing the following:
    let _T0 = [1, 2, 3, 4].iter();
    let _T1 = _T0.next();
    while (_T1 != none) {
        // ...
        _T1 = _T0.next();
    }
}
*/
