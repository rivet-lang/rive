class A {
    mut i: i32 = 10;
}

class B : A {
    c: i32;

    func set_i(mut self, i: i32) {
        self.i = i;
    }

    func set_base_i(mut self, i: i32) {
        base.i = i;
    }
}

test "inheritance: using inherited fields" {
    let b = B(i: 99);
    @assert(b.i == 99);

    let b2 = B();
    @assert(b2.i == 10);

    let b3 = B(1, 2);
    @assert(b3.i == 1);
    @assert(b3.c == 2);
}

test "inheritance: using `base`" {
    let mut b2 = B();
    @assert(b2.i == 10);

    b2.set_i(5);
    @assert(b2.i == 5);

    b2.set_base_i(8);
    @assert(b2.i == 8);
}

test "inheritance: downcast" {
    let b = B(c: 5);

    let a = @as(A, b);
    @assert(a.i == 10);

    let b2 = @as(B, a);
    @assert(b2.c == 5);
}

test "inheritance: typeswitch" {
    let b = B(c: 5);
    let a = @as(A, b);
    @assert(switch a is {
        B => true,
        else => false
    });
}

class Animal {
    public func speak(self) string {
        return "~ Animal.speaks() ~";
    }
}

class Dog : Animal {
    #[override]
    public func speak(self) string {
        return "woof";
    }
}

class Cat : Animal {
    #[override]
    public func speak(self) string {
        return "meow";
    }
}

class NonAnimal : Animal { }

test "inheritance: virtual methods and `#[override]`" {
    let non_animal = NonAnimal();
    @assert(non_animal.speak() == "~ Animal.speaks() ~");

    let dog = Dog();
    @assert(dog.speak() == "woof");

    let cat = Cat();
    @assert(cat.speak() == "meow");
}
